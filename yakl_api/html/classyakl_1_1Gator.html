<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YAKL: yakl::Gator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YAKL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceyakl.html">yakl</a></li><li class="navelem"><a class="el" href="classyakl_1_1Gator.html">Gator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classyakl_1_1Gator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">yakl::Gator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>YAKL Pool allocator class.  
 <a href="classyakl_1_1Gator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="YAKL__Gator_8h_source.html">YAKL_Gator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyakl_1_1Gator_1_1WaitEntry.html">WaitEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74a54c9e952d68a3feb9f3ac87f24cb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a74a54c9e952d68a3feb9f3ac87f24cb8">Gator</a> ()</td></tr>
<tr class="memdesc:a74a54c9e952d68a3feb9f3ac87f24cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Please use the <a class="el" href="classyakl_1_1Gator.html#a1a49cefe55594fd3667ece915d9e0b9a" title="Initialize the pool.">init()</a> function to specify parameters, not the constructor.  <a href="classyakl_1_1Gator.html#a74a54c9e952d68a3feb9f3ac87f24cb8">More...</a><br /></td></tr>
<tr class="separator:a74a54c9e952d68a3feb9f3ac87f24cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383e25888880698d369a782f144c3c86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a383e25888880698d369a782f144c3c86">Gator</a> (const <a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;)=delete</td></tr>
<tr class="memdesc:a383e25888880698d369a782f144c3c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied.  <a href="classyakl_1_1Gator.html#a383e25888880698d369a782f144c3c86">More...</a><br /></td></tr>
<tr class="separator:a383e25888880698d369a782f144c3c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2658b0c306af125d83e486582fb1ed27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a2658b0c306af125d83e486582fb1ed27">Gator</a> (<a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a2658b0c306af125d83e486582fb1ed27"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied.  <a href="classyakl_1_1Gator.html#a2658b0c306af125d83e486582fb1ed27">More...</a><br /></td></tr>
<tr class="separator:a2658b0c306af125d83e486582fb1ed27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acba519517cd3ec3c17f2d4e26142c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a2acba519517cd3ec3c17f2d4e26142c9">~Gator</a> ()</td></tr>
<tr class="memdesc:a2acba519517cd3ec3c17f2d4e26142c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">All pools are automatically finalized when a <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object is destroyed.  <a href="classyakl_1_1Gator.html#a2acba519517cd3ec3c17f2d4e26142c9">More...</a><br /></td></tr>
<tr class="separator:a2acba519517cd3ec3c17f2d4e26142c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe683d1012ee692e1521c2e6a1265ded"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#abe683d1012ee692e1521c2e6a1265ded">allocate</a> (size_t bytes, char const *label=&quot;&quot;)</td></tr>
<tr class="memdesc:abe683d1012ee692e1521c2e6a1265ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the requested number of bytes using the requested label, and return the pointer to allocated space.  <a href="classyakl_1_1Gator.html#abe683d1012ee692e1521c2e6a1265ded">More...</a><br /></td></tr>
<tr class="separator:abe683d1012ee692e1521c2e6a1265ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba398e8fc4a9a6f3e81a808abea0400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a0ba398e8fc4a9a6f3e81a808abea0400">finalize</a> ()</td></tr>
<tr class="memdesc:a0ba398e8fc4a9a6f3e81a808abea0400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the pool allocator, deallocate all individual pools.  <a href="classyakl_1_1Gator.html#a0ba398e8fc4a9a6f3e81a808abea0400">More...</a><br /></td></tr>
<tr class="separator:a0ba398e8fc4a9a6f3e81a808abea0400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129917d97451251350dac68ea495ebed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a129917d97451251350dac68ea495ebed">free</a> (void *ptr, char const *label=&quot;&quot;)</td></tr>
<tr class="memdesc:a129917d97451251350dac68ea495ebed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the passed pointer, and return the pointer to allocated space.  <a href="classyakl_1_1Gator.html#a129917d97451251350dac68ea495ebed">More...</a><br /></td></tr>
<tr class="separator:a129917d97451251350dac68ea495ebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77663fefd3675366b300a98a0ca24224"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a77663fefd3675366b300a98a0ca24224">free_completed_waiting_entries</a> ()</td></tr>
<tr class="memdesc:a77663fefd3675366b300a98a0ca24224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check all deallcation entries that are waiting on stream events to see if those events have completed. If the events are completed, then free the entry from the pool.  <a href="classyakl_1_1Gator.html#a77663fefd3675366b300a98a0ca24224">More...</a><br /></td></tr>
<tr class="separator:a77663fefd3675366b300a98a0ca24224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8142ab6d1539d98ea17cd090242e74b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#ae8142ab6d1539d98ea17cd090242e74b">free_with_event_dependencies</a> (void *ptr, std::vector&lt; <a class="el" href="structyakl_1_1Event.html">Event</a> &gt; events_in, char const *label=&quot;&quot;)</td></tr>
<tr class="memdesc:ae8142ab6d1539d98ea17cd090242e74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the passed pointer, and return the pointer to allocated space.  <a href="classyakl_1_1Gator.html#ae8142ab6d1539d98ea17cd090242e74b">More...</a><br /></td></tr>
<tr class="separator:ae8142ab6d1539d98ea17cd090242e74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ffecc5258be2c655aceb0f95ffab3a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a07ffecc5258be2c655aceb0f95ffab3a">get_bytes_currently_allocated</a> () const</td></tr>
<tr class="memdesc:a07ffecc5258be2c655aceb0f95ffab3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current number of bytes that have been allocated in the pools (this is actual allocation, not pool capacity)  <a href="classyakl_1_1Gator.html#a07ffecc5258be2c655aceb0f95ffab3a">More...</a><br /></td></tr>
<tr class="separator:a07ffecc5258be2c655aceb0f95ffab3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83af4ef3780f046958edc64453edd0bf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a83af4ef3780f046958edc64453edd0bf">get_high_water_mark</a> () const</td></tr>
<tr class="memdesc:a83af4ef3780f046958edc64453edd0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current memory high water mark in bytes for all allocations passing through the pool.  <a href="classyakl_1_1Gator.html#a83af4ef3780f046958edc64453edd0bf">More...</a><br /></td></tr>
<tr class="separator:a83af4ef3780f046958edc64453edd0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9677a332d76dfe99c7c91cf632aa37"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#acb9677a332d76dfe99c7c91cf632aa37">get_num_allocs</a> () const</td></tr>
<tr class="memdesc:acb9677a332d76dfe99c7c91cf632aa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of allocations in all of the pools put together.  <a href="classyakl_1_1Gator.html#acb9677a332d76dfe99c7c91cf632aa37">More...</a><br /></td></tr>
<tr class="separator:acb9677a332d76dfe99c7c91cf632aa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360b86241105b1b178879986d26a16d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a360b86241105b1b178879986d26a16d0">get_num_pools</a> () const</td></tr>
<tr class="memdesc:a360b86241105b1b178879986d26a16d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current number of pools that have been allocated.  <a href="classyakl_1_1Gator.html#a360b86241105b1b178879986d26a16d0">More...</a><br /></td></tr>
<tr class="separator:a360b86241105b1b178879986d26a16d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae558caa1a22f5bf125bc5e8488f9edd0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#ae558caa1a22f5bf125bc5e8488f9edd0">get_pool_capacity</a> () const</td></tr>
<tr class="memdesc:ae558caa1a22f5bf125bc5e8488f9edd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total capacity of all of the pools put together.  <a href="classyakl_1_1Gator.html#ae558caa1a22f5bf125bc5e8488f9edd0">More...</a><br /></td></tr>
<tr class="separator:ae558caa1a22f5bf125bc5e8488f9edd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946f077f54c9bffee34f22dc58783dfe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a946f077f54c9bffee34f22dc58783dfe">get_pool_high_water_space_efficiency</a> () const</td></tr>
<tr class="memdesc:a946f077f54c9bffee34f22dc58783dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the proportion of total capacity among pools that has been allocated at this largest past memory usage.  <a href="classyakl_1_1Gator.html#a946f077f54c9bffee34f22dc58783dfe">More...</a><br /></td></tr>
<tr class="separator:a946f077f54c9bffee34f22dc58783dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4747756b5b867222463bb5c8674516ea"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a4747756b5b867222463bb5c8674516ea">get_pool_space_efficiency</a> () const</td></tr>
<tr class="memdesc:a4747756b5b867222463bb5c8674516ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current proportion of total capacity among pools that is actually allocated.  <a href="classyakl_1_1Gator.html#a4747756b5b867222463bb5c8674516ea">More...</a><br /></td></tr>
<tr class="separator:a4747756b5b867222463bb5c8674516ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a49cefe55594fd3667ece915d9e0b9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a1a49cefe55594fd3667ece915d9e0b9a">init</a> (std::function&lt; void *(size_t)&gt; mymalloc=[](size_t bytes) -&gt; void *{ return ::malloc(bytes);}, std::function&lt; void(void *)&gt; myfree=[](void *ptr) { ::<a class="el" href="classyakl_1_1Gator.html#a129917d97451251350dac68ea495ebed">free</a>(ptr);}, std::function&lt; void(void *, size_t)&gt; myzero=[](void *ptr, size_t bytes) {}, size_t initialSize=1024 *1024 *1024, size_t growSize=1024 *1024 *1024, size_t blockSize=16 *sizeof(size_t), std::string pool_name=&quot;Gator&quot;, std::string error_message_out_of_memory=&quot;&quot;, std::string error_message_cannot_grow=&quot;&quot;)</td></tr>
<tr class="memdesc:a1a49cefe55594fd3667ece915d9e0b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the pool.  <a href="classyakl_1_1Gator.html#a1a49cefe55594fd3667ece915d9e0b9a">More...</a><br /></td></tr>
<tr class="separator:a1a49cefe55594fd3667ece915d9e0b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6853e3caf452ecab45e7e323c887cb73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a6853e3caf452ecab45e7e323c887cb73">operator=</a> (const <a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6853e3caf452ecab45e7e323c887cb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied.  <a href="classyakl_1_1Gator.html#a6853e3caf452ecab45e7e323c887cb73">More...</a><br /></td></tr>
<tr class="separator:a6853e3caf452ecab45e7e323c887cb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47308e77a115582395046dc4eb22497b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a47308e77a115582395046dc4eb22497b">operator=</a> (<a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a47308e77a115582395046dc4eb22497b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied.  <a href="classyakl_1_1Gator.html#a47308e77a115582395046dc4eb22497b">More...</a><br /></td></tr>
<tr class="separator:a47308e77a115582395046dc4eb22497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd0901f081efbf328b9a282d20466a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#acfd0901f081efbf328b9a282d20466a8">printAllocsLeft</a> ()</td></tr>
<tr class="memdesc:acfd0901f081efbf328b9a282d20466a8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[USEFUL FOR DEBUGGING]</b> Print all allocations left in this pool object.  <a href="classyakl_1_1Gator.html#acfd0901f081efbf328b9a282d20466a8">More...</a><br /></td></tr>
<tr class="separator:acfd0901f081efbf328b9a282d20466a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae818776d896e0b08da983f2fa15b35cb"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#ae818776d896e0b08da983f2fa15b35cb">mtx2</a></td></tr>
<tr class="separator:ae818776d896e0b08da983f2fa15b35cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e3dd35007340385b8ec817396877a9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structyakl_1_1Gator_1_1WaitEntry.html">WaitEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#aa6e3dd35007340385b8ec817396877a9">waiting_entries</a></td></tr>
<tr class="separator:aa6e3dd35007340385b8ec817396877a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf75f6f98dc2d343d0d88c65fdc26aa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structyakl_1_1Event.html">Event</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#adaf75f6f98dc2d343d0d88c65fdc26aa">waiting_events</a></td></tr>
<tr class="separator:adaf75f6f98dc2d343d0d88c65fdc26aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>YAKL Pool allocator class. </p>
<p>Growable pool allocator for efficient frequent allocations and deallocations. User determines allocation, free, initial pool size, additional pool size, and other pool allocator characteristics upon initiailization.</p>
<p>Once existing pools run out of memory, additional pools are create. Each pool is based on a simple linear search for free slots that is as efficient in memory usage as possible. While search time is linear rather than log in complexity, allocations and frees are typically overlapped with kernel execution.</p>
<p><a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> objects <b>are thread safe</b> for <a class="el" href="classyakl_1_1Gator.html#abe683d1012ee692e1521c2e6a1265ded" title="Allocate the requested number of bytes using the requested label, and return the pointer to allocated...">allocate()</a> and <a class="el" href="classyakl_1_1Gator.html#a129917d97451251350dac68ea495ebed" title="Free the passed pointer, and return the pointer to allocated space.">free()</a> calls. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a74a54c9e952d68a3feb9f3ac87f24cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a54c9e952d68a3feb9f3ac87f24cb8">&#9670;&nbsp;</a></span>Gator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yakl::Gator::Gator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Please use the <a class="el" href="classyakl_1_1Gator.html#a1a49cefe55594fd3667ece915d9e0b9a" title="Initialize the pool.">init()</a> function to specify parameters, not the constructor. </p>

</div>
</div>
<a id="a2658b0c306af125d83e486582fb1ed27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2658b0c306af125d83e486582fb1ed27">&#9670;&nbsp;</a></span>Gator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">yakl::Gator::Gator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied. </p>

</div>
</div>
<a id="a383e25888880698d369a782f144c3c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383e25888880698d369a782f144c3c86">&#9670;&nbsp;</a></span>Gator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yakl::Gator::Gator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied. </p>

</div>
</div>
<a id="a2acba519517cd3ec3c17f2d4e26142c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acba519517cd3ec3c17f2d4e26142c9">&#9670;&nbsp;</a></span>~Gator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yakl::Gator::~Gator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All pools are automatically finalized when a <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object is destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abe683d1012ee692e1521c2e6a1265ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe683d1012ee692e1521c2e6a1265ded">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* yakl::Gator::allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate the requested number of bytes using the requested label, and return the pointer to allocated space. </p>
<p>The pool allocator will search from beginning to end for a slot large enough to fit this allocation request. This minimizes segmentation at the cost of a linear search time. If the current pool(s) do not contain enough room, a new pool is created.</p>
<p>Attempting to allocate zero bytes will return <code>nullptr</code>. This is a thread safe call.</p>
<p>This always checks to see if entries waiting on stream events are able to be deallocated before allocating. </p>

</div>
</div>
<a id="a0ba398e8fc4a9a6f3e81a808abea0400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba398e8fc4a9a6f3e81a808abea0400">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::Gator::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalize the pool allocator, deallocate all individual pools. </p>

</div>
</div>
<a id="a129917d97451251350dac68ea495ebed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129917d97451251350dac68ea495ebed">&#9670;&nbsp;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::Gator::free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the passed pointer, and return the pointer to allocated space. </p>
<p>Attempting to free a pointer not found in the list of pools will result in a thrown exception </p>

</div>
</div>
<a id="a77663fefd3675366b300a98a0ca24224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77663fefd3675366b300a98a0ca24224">&#9670;&nbsp;</a></span>free_completed_waiting_entries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::Gator::free_completed_waiting_entries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check all deallcation entries that are waiting on stream events to see if those events have completed. If the events are completed, then free the entry from the pool. </p>

</div>
</div>
<a id="ae8142ab6d1539d98ea17cd090242e74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8142ab6d1539d98ea17cd090242e74b">&#9670;&nbsp;</a></span>free_with_event_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::Gator::free_with_event_dependencies </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structyakl_1_1Event.html">Event</a> &gt;&#160;</td>
          <td class="paramname"><em>events_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the passed pointer, and return the pointer to allocated space. </p>
<p>Attempting to free a pointer not found in the list of pools will result in a thrown exception </p>

</div>
</div>
<a id="a07ffecc5258be2c655aceb0f95ffab3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ffecc5258be2c655aceb0f95ffab3a">&#9670;&nbsp;</a></span>get_bytes_currently_allocated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t yakl::Gator::get_bytes_currently_allocated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current number of bytes that have been allocated in the pools (this is actual allocation, not pool capacity) </p>

</div>
</div>
<a id="a83af4ef3780f046958edc64453edd0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83af4ef3780f046958edc64453edd0bf">&#9670;&nbsp;</a></span>get_high_water_mark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t yakl::Gator::get_high_water_mark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current memory high water mark in bytes for all allocations passing through the pool. </p>

</div>
</div>
<a id="acb9677a332d76dfe99c7c91cf632aa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9677a332d76dfe99c7c91cf632aa37">&#9670;&nbsp;</a></span>get_num_allocs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t yakl::Gator::get_num_allocs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of allocations in all of the pools put together. </p>

</div>
</div>
<a id="a360b86241105b1b178879986d26a16d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360b86241105b1b178879986d26a16d0">&#9670;&nbsp;</a></span>get_num_pools()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int yakl::Gator::get_num_pools </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current number of pools that have been allocated. </p>

</div>
</div>
<a id="ae558caa1a22f5bf125bc5e8488f9edd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae558caa1a22f5bf125bc5e8488f9edd0">&#9670;&nbsp;</a></span>get_pool_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t yakl::Gator::get_pool_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total capacity of all of the pools put together. </p>

</div>
</div>
<a id="a946f077f54c9bffee34f22dc58783dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946f077f54c9bffee34f22dc58783dfe">&#9670;&nbsp;</a></span>get_pool_high_water_space_efficiency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double yakl::Gator::get_pool_high_water_space_efficiency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the proportion of total capacity among pools that has been allocated at this largest past memory usage. </p>

</div>
</div>
<a id="a4747756b5b867222463bb5c8674516ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4747756b5b867222463bb5c8674516ea">&#9670;&nbsp;</a></span>get_pool_space_efficiency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double yakl::Gator::get_pool_space_efficiency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current proportion of total capacity among pools that is actually allocated. </p>

</div>
</div>
<a id="a1a49cefe55594fd3667ece915d9e0b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a49cefe55594fd3667ece915d9e0b9a">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::Gator::init </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void *(size_t)&gt;&#160;</td>
          <td class="paramname"><em>mymalloc</em> = <code>[]&#160;(size_t&#160;bytes)&#160;-&gt;&#160;void&#160;*&#160;{&#160;return&#160;::malloc(bytes);&#160;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(void *)&gt;&#160;</td>
          <td class="paramname"><em>myfree</em> = <code>[]&#160;(void&#160;*ptr)&#160;{&#160;::<a class="el" href="classyakl_1_1Gator.html#a129917d97451251350dac68ea495ebed">free</a>(ptr);&#160;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(void *, size_t)&gt;&#160;</td>
          <td class="paramname"><em>myzero</em> = <code>[]&#160;(void&#160;*ptr,&#160;size_t&#160;bytes)&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initialSize</em> = <code>1024*1024*1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>growSize</em> = <code>1024*1024*1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSize</em> = <code>16*sizeof(size_t)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pool_name</em> = <code>&quot;Gator&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>error_message_out_of_memory</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>error_message_cannot_grow</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myalloc</td><td>The allocator to use when creating the initial and additional pools </td></tr>
    <tr><td class="paramname">myfree</td><td>The deallocator to use when destroying all pools upon the <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object destruction. </td></tr>
    <tr><td class="paramname">myzero</td><td>[NOT CURRENTLY USED] The function to use to memset the memory to a value (presumably zero) after initial allocationa and an entry free </td></tr>
    <tr><td class="paramname">initialSize</td><td>Size of the initial pool in bytes </td></tr>
    <tr><td class="paramname">growSize</td><td>Size of additional pools once the previous pools run out of memory </td></tr>
    <tr><td class="paramname">blockSize</td><td>Size of an individual block (the smallest possible entry size. The entry size must increment by this size as well. </td></tr>
    <tr><td class="paramname">pool_name</td><td>The label for this pool used in debugging </td></tr>
    <tr><td class="paramname">error_message_out_of_memory</td><td>The string printed when a pool allocation fails </td></tr>
    <tr><td class="paramname">error_message_cannot_grow</td><td>The string printed when an allocation is requested that overflows initial memory and exceeds the size of additional pools </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6853e3caf452ecab45e7e323c887cb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6853e3caf452ecab45e7e323c887cb73">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyakl_1_1Gator.html">Gator</a>&amp; yakl::Gator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied. </p>

</div>
</div>
<a id="a47308e77a115582395046dc4eb22497b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47308e77a115582395046dc4eb22497b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyakl_1_1Gator.html">Gator</a>&amp; yakl::Gator::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied. </p>

</div>
</div>
<a id="acfd0901f081efbf328b9a282d20466a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd0901f081efbf328b9a282d20466a8">&#9670;&nbsp;</a></span>printAllocsLeft()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::Gator::printAllocsLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[USEFUL FOR DEBUGGING]</b> Print all allocations left in this pool object. </p>
<p>If you call this regularly in a loop, you can determine if an object fails to be deallocated properly by looking for repeated entries that grow in number each iteration. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae818776d896e0b08da983f2fa15b35cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae818776d896e0b08da983f2fa15b35cb">&#9670;&nbsp;</a></span>mtx2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex yakl::Gator::mtx2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6e3dd35007340385b8ec817396877a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e3dd35007340385b8ec817396877a9">&#9670;&nbsp;</a></span>waiting_entries</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structyakl_1_1Gator_1_1WaitEntry.html">WaitEntry</a>&gt; yakl::Gator::waiting_entries</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adaf75f6f98dc2d343d0d88c65fdc26aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf75f6f98dc2d343d0d88c65fdc26aa">&#9670;&nbsp;</a></span>waiting_events</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structyakl_1_1Event.html">Event</a>&gt; yakl::Gator::waiting_events</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>YAKL/src/<a class="el" href="YAKL__Gator_8h_source.html">YAKL_Gator.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
