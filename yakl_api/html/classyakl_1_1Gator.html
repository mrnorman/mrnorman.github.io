<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YAKL: yakl::Gator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YAKL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceyakl.html">yakl</a></li><li class="navelem"><a class="el" href="classyakl_1_1Gator.html">Gator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classyakl_1_1Gator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">yakl::Gator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>YAKL Pool allocator class.  
 <a href="classyakl_1_1Gator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="YAKL__Gator_8h_source.html">YAKL_Gator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74a54c9e952d68a3feb9f3ac87f24cb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a74a54c9e952d68a3feb9f3ac87f24cb8">Gator</a> ()</td></tr>
<tr class="memdesc:a74a54c9e952d68a3feb9f3ac87f24cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Please use the <a class="el" href="classyakl_1_1Gator.html#a795d5e1f2f8b10ea2e4afbe1b285629e" title="Initialize the pool.">init()</a> function to specify parameters, not the constructor.  <a href="classyakl_1_1Gator.html#a74a54c9e952d68a3feb9f3ac87f24cb8">More...</a><br /></td></tr>
<tr class="separator:a74a54c9e952d68a3feb9f3ac87f24cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383e25888880698d369a782f144c3c86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a383e25888880698d369a782f144c3c86">Gator</a> (const <a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;)=delete</td></tr>
<tr class="memdesc:a383e25888880698d369a782f144c3c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied.  <a href="classyakl_1_1Gator.html#a383e25888880698d369a782f144c3c86">More...</a><br /></td></tr>
<tr class="separator:a383e25888880698d369a782f144c3c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2658b0c306af125d83e486582fb1ed27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a2658b0c306af125d83e486582fb1ed27">Gator</a> (<a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a2658b0c306af125d83e486582fb1ed27"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied.  <a href="classyakl_1_1Gator.html#a2658b0c306af125d83e486582fb1ed27">More...</a><br /></td></tr>
<tr class="separator:a2658b0c306af125d83e486582fb1ed27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acba519517cd3ec3c17f2d4e26142c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a2acba519517cd3ec3c17f2d4e26142c9">~Gator</a> ()</td></tr>
<tr class="memdesc:a2acba519517cd3ec3c17f2d4e26142c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">All pools are automatically finalized when a <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object is destroyed.  <a href="classyakl_1_1Gator.html#a2acba519517cd3ec3c17f2d4e26142c9">More...</a><br /></td></tr>
<tr class="separator:a2acba519517cd3ec3c17f2d4e26142c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe683d1012ee692e1521c2e6a1265ded"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#abe683d1012ee692e1521c2e6a1265ded">allocate</a> (size_t bytes, char const *label=&quot;&quot;)</td></tr>
<tr class="memdesc:abe683d1012ee692e1521c2e6a1265ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the requested number of bytes using the requested label, and return the pointer to allocated space.  <a href="classyakl_1_1Gator.html#abe683d1012ee692e1521c2e6a1265ded">More...</a><br /></td></tr>
<tr class="separator:abe683d1012ee692e1521c2e6a1265ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba398e8fc4a9a6f3e81a808abea0400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a0ba398e8fc4a9a6f3e81a808abea0400">finalize</a> ()</td></tr>
<tr class="memdesc:a0ba398e8fc4a9a6f3e81a808abea0400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the pool allocator, deallocate all individual pools.  <a href="classyakl_1_1Gator.html#a0ba398e8fc4a9a6f3e81a808abea0400">More...</a><br /></td></tr>
<tr class="separator:a0ba398e8fc4a9a6f3e81a808abea0400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129917d97451251350dac68ea495ebed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a129917d97451251350dac68ea495ebed">free</a> (void *ptr, char const *label=&quot;&quot;)</td></tr>
<tr class="memdesc:a129917d97451251350dac68ea495ebed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the passed pointer, and return the pointer to allocated space.  <a href="classyakl_1_1Gator.html#a129917d97451251350dac68ea495ebed">More...</a><br /></td></tr>
<tr class="separator:a129917d97451251350dac68ea495ebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795d5e1f2f8b10ea2e4afbe1b285629e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a795d5e1f2f8b10ea2e4afbe1b285629e">init</a> (std::function&lt; void *(size_t)&gt; mymalloc=[](size_t bytes) -&gt; void *{ return ::malloc(bytes);}, std::function&lt; void(void *)&gt; myfree=[](void *ptr) { ::<a class="el" href="classyakl_1_1Gator.html#a129917d97451251350dac68ea495ebed">free</a>(ptr);}, std::function&lt; void(void *, size_t)&gt; myzero=[](void *ptr, size_t bytes) {}, size_t initialSize=1024 *1024 *1024, size_t growSize=1024 *1024 *1024, size_t blockSize=sizeof(size_t), std::string pool_name=&quot;Gator&quot;, std::string error_message_out_of_memory=&quot;&quot;, std::string error_message_cannot_grow=&quot;&quot;)</td></tr>
<tr class="memdesc:a795d5e1f2f8b10ea2e4afbe1b285629e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the pool.  <a href="classyakl_1_1Gator.html#a795d5e1f2f8b10ea2e4afbe1b285629e">More...</a><br /></td></tr>
<tr class="separator:a795d5e1f2f8b10ea2e4afbe1b285629e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8b2d0f447f6a1242310bf9a573d2fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#aea8b2d0f447f6a1242310bf9a573d2fa">numAllocs</a> () const</td></tr>
<tr class="memdesc:aea8b2d0f447f6a1242310bf9a573d2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of allocations in all of the pools put together.  <a href="classyakl_1_1Gator.html#aea8b2d0f447f6a1242310bf9a573d2fa">More...</a><br /></td></tr>
<tr class="separator:aea8b2d0f447f6a1242310bf9a573d2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6853e3caf452ecab45e7e323c887cb73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a6853e3caf452ecab45e7e323c887cb73">operator=</a> (const <a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6853e3caf452ecab45e7e323c887cb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied.  <a href="classyakl_1_1Gator.html#a6853e3caf452ecab45e7e323c887cb73">More...</a><br /></td></tr>
<tr class="separator:a6853e3caf452ecab45e7e323c887cb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47308e77a115582395046dc4eb22497b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a47308e77a115582395046dc4eb22497b">operator=</a> (<a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a47308e77a115582395046dc4eb22497b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied.  <a href="classyakl_1_1Gator.html#a47308e77a115582395046dc4eb22497b">More...</a><br /></td></tr>
<tr class="separator:a47308e77a115582395046dc4eb22497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0618249e8907a63377ad643a669fd464"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#a0618249e8907a63377ad643a669fd464">poolSize</a> () const</td></tr>
<tr class="memdesc:a0618249e8907a63377ad643a669fd464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of all of the pools put together.  <a href="classyakl_1_1Gator.html#a0618249e8907a63377ad643a669fd464">More...</a><br /></td></tr>
<tr class="separator:a0618249e8907a63377ad643a669fd464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd0901f081efbf328b9a282d20466a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html#acfd0901f081efbf328b9a282d20466a8">printAllocsLeft</a> ()</td></tr>
<tr class="memdesc:acfd0901f081efbf328b9a282d20466a8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[USEFUL FOR DEBUGGING]</b> Print all allocations left in this pool object.  <a href="classyakl_1_1Gator.html#acfd0901f081efbf328b9a282d20466a8">More...</a><br /></td></tr>
<tr class="separator:acfd0901f081efbf328b9a282d20466a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>YAKL Pool allocator class. </p>
<p>Growable pool allocator for efficient frequent allocations and deallocations. User determines allocation, free, initial pool size, additional pool size, and other pool allocator characteristics upon initiailization.</p>
<p>Once existing pools run out of memory, additional pools are create. Each pool is based on a simple linear search for free slots that is as efficient in memory usage as possible. While search time is linear rather than log in complexity, allocations and frees are typically overlapped with kernel execution.</p>
<p><a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> objects <b>are thread safe</b> for <a class="el" href="classyakl_1_1Gator.html#abe683d1012ee692e1521c2e6a1265ded" title="Allocate the requested number of bytes using the requested label, and return the pointer to allocated...">allocate()</a> and <a class="el" href="classyakl_1_1Gator.html#a129917d97451251350dac68ea495ebed" title="Free the passed pointer, and return the pointer to allocated space.">free()</a> calls. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a74a54c9e952d68a3feb9f3ac87f24cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a54c9e952d68a3feb9f3ac87f24cb8">&#9670;&nbsp;</a></span>Gator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yakl::Gator::Gator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Please use the <a class="el" href="classyakl_1_1Gator.html#a795d5e1f2f8b10ea2e4afbe1b285629e" title="Initialize the pool.">init()</a> function to specify parameters, not the constructor. </p>

</div>
</div>
<a id="a2658b0c306af125d83e486582fb1ed27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2658b0c306af125d83e486582fb1ed27">&#9670;&nbsp;</a></span>Gator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">yakl::Gator::Gator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied. </p>

</div>
</div>
<a id="a383e25888880698d369a782f144c3c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383e25888880698d369a782f144c3c86">&#9670;&nbsp;</a></span>Gator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yakl::Gator::Gator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied. </p>

</div>
</div>
<a id="a2acba519517cd3ec3c17f2d4e26142c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acba519517cd3ec3c17f2d4e26142c9">&#9670;&nbsp;</a></span>~Gator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yakl::Gator::~Gator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All pools are automatically finalized when a <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object is destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abe683d1012ee692e1521c2e6a1265ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe683d1012ee692e1521c2e6a1265ded">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* yakl::Gator::allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate the requested number of bytes using the requested label, and return the pointer to allocated space. </p>
<p>The pool allocator will search from beginning to end for a slot large enough to fit this allocation request. This minimizes segmentation at the cost of a linear search time. If the current pool(s) do not contain enough room, a new pool is created.</p>
<p>Attempting to allocate zero bytes will return <code>nullptr</code>. This is a thread safe call. </p>

</div>
</div>
<a id="a0ba398e8fc4a9a6f3e81a808abea0400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba398e8fc4a9a6f3e81a808abea0400">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::Gator::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalize the pool allocator, deallocate all individual pools. </p>

</div>
</div>
<a id="a129917d97451251350dac68ea495ebed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129917d97451251350dac68ea495ebed">&#9670;&nbsp;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::Gator::free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the passed pointer, and return the pointer to allocated space. </p>
<p>Attempting to free a pointer not found in the list of pools will result in a thrown exception </p>

</div>
</div>
<a id="a795d5e1f2f8b10ea2e4afbe1b285629e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795d5e1f2f8b10ea2e4afbe1b285629e">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::Gator::init </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void *(size_t)&gt;&#160;</td>
          <td class="paramname"><em>mymalloc</em> = <code>[]&#160;(size_t&#160;bytes)&#160;-&gt;&#160;void&#160;*&#160;{&#160;return&#160;::malloc(bytes);&#160;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(void *)&gt;&#160;</td>
          <td class="paramname"><em>myfree</em> = <code>[]&#160;(void&#160;*ptr)&#160;{&#160;::<a class="el" href="classyakl_1_1Gator.html#a129917d97451251350dac68ea495ebed">free</a>(ptr);&#160;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(void *, size_t)&gt;&#160;</td>
          <td class="paramname"><em>myzero</em> = <code>[]&#160;(void&#160;*ptr,&#160;size_t&#160;bytes)&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initialSize</em> = <code>1024*1024*1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>growSize</em> = <code>1024*1024*1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSize</em> = <code>sizeof(size_t)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pool_name</em> = <code>&quot;Gator&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>error_message_out_of_memory</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>error_message_cannot_grow</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myalloc</td><td>The allocator to use when creating the initial and additional pools </td></tr>
    <tr><td class="paramname">myfree</td><td>The deallocator to use when destroying all pools upon the <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object destruction. </td></tr>
    <tr><td class="paramname">myzero</td><td>[NOT CURRENTLY USED] The function to use to memset the memory to a value (presumably zero) after initial allocationa and an entry free </td></tr>
    <tr><td class="paramname">initialSize</td><td>Size of the initial pool in bytes </td></tr>
    <tr><td class="paramname">growSize</td><td>Size of additional pools once the previous pools run out of memory </td></tr>
    <tr><td class="paramname">blockSize</td><td>Size of an individual block (the smallest possible entry size. The entry size must increment by this size as well. </td></tr>
    <tr><td class="paramname">pool_name</td><td>The label for this pool used in debugging </td></tr>
    <tr><td class="paramname">error_message_out_of_memory</td><td>The string printed when a pool allocation fails </td></tr>
    <tr><td class="paramname">error_message_cannot_grow</td><td>The string printed when an allocation is requested that overflows initial memory and exceeds the size of additional pools </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea8b2d0f447f6a1242310bf9a573d2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8b2d0f447f6a1242310bf9a573d2fa">&#9670;&nbsp;</a></span>numAllocs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t yakl::Gator::numAllocs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of allocations in all of the pools put together. </p>

</div>
</div>
<a id="a6853e3caf452ecab45e7e323c887cb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6853e3caf452ecab45e7e323c887cb73">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyakl_1_1Gator.html">Gator</a>&amp; yakl::Gator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied. </p>

</div>
</div>
<a id="a47308e77a115582395046dc4eb22497b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47308e77a115582395046dc4eb22497b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyakl_1_1Gator.html">Gator</a>&amp; yakl::Gator::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Gator.html">Gator</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classyakl_1_1Gator.html" title="YAKL Pool allocator class.">Gator</a> object may be moved but not copied. </p>

</div>
</div>
<a id="a0618249e8907a63377ad643a669fd464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0618249e8907a63377ad643a669fd464">&#9670;&nbsp;</a></span>poolSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t yakl::Gator::poolSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total size of all of the pools put together. </p>

</div>
</div>
<a id="acfd0901f081efbf328b9a282d20466a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd0901f081efbf328b9a282d20466a8">&#9670;&nbsp;</a></span>printAllocsLeft()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::Gator::printAllocsLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[USEFUL FOR DEBUGGING]</b> Print all allocations left in this pool object. </p>
<p>If you call this regularly in a loop, you can determine if an object fails to be deallocated properly by looking for repeated entries that grow in number each iteration. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>YAKL/src/<a class="el" href="YAKL__Gator_8h_source.html">YAKL_Gator.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
