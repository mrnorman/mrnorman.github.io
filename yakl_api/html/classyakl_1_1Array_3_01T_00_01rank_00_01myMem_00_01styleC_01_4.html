<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YAKL: yakl::Array&lt; T, rank, myMem, styleC &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YAKL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceyakl.html">yakl</a></li><li class="navelem"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html">Array&lt; T, rank, myMem, styleC &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">yakl::Array&lt; T, rank, myMem, styleC &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This implements the yakl:<a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> class with <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d" title="Template parameter for yakl::Array that specifies it should follow C-style behavior.">yakl::styleC</a> behavior.  
 <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="YAKL__CArray_8h_source.html">YAKL_CArray.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for yakl::Array&lt; T, rank, myMem, styleC &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4__inherit__graph.png" border="0" usemap="#yakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="yakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4_inherit__map" id="yakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4_inherit__map">
<area shape="rect" title="This implements the yakl:Array class with yakl::styleC behavior." alt="" coords="17,95,175,136"/>
<area shape="rect" href="classyakl_1_1ArrayBase.html" title=" " alt="" coords="5,5,187,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for yakl::Array&lt; T, rank, myMem, styleC &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4__coll__graph.png" border="0" usemap="#yakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="yakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4_coll__map" id="yakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4_coll__map">
<area shape="rect" title="This implements the yakl:Array class with yakl::styleC behavior." alt="" coords="17,95,175,136"/>
<area shape="rect" href="classyakl_1_1ArrayBase.html" title=" " alt="" coords="5,5,187,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7fee476637337e1e949af60de2b0ffe5"><td class="memItemLeft" align="right" valign="top">typedef std::add_const&lt; <a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a> &gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a7fee476637337e1e949af60de2b0ffe5">const_value_type</a></td></tr>
<tr class="memdesc:a7fee476637337e1e949af60de2b0ffe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type <code>T</code> with <code>const</code> added to it.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a7fee476637337e1e949af60de2b0ffe5">More...</a><br /></td></tr>
<tr class="separator:a7fee476637337e1e949af60de2b0ffe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2418211857fefc3acc91e34027c86ff"><td class="memItemLeft" align="right" valign="top">typedef std::remove_const&lt; <a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a> &gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#af2418211857fefc3acc91e34027c86ff">non_const_value_type</a></td></tr>
<tr class="memdesc:af2418211857fefc3acc91e34027c86ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type <code>T</code> with <code>const</code> removed from it.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#af2418211857fefc3acc91e34027c86ff">More...</a><br /></td></tr>
<tr class="separator:af2418211857fefc3acc91e34027c86ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad139bae81491baf46c8e9879867f3487"><td class="memItemLeft" align="right" valign="top">typedef std::remove_cv&lt; T &gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a></td></tr>
<tr class="memdesc:ad139bae81491baf46c8e9879867f3487"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type <code>T</code> without <code>const</code> and <code>volatile</code> modifiers.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">More...</a><br /></td></tr>
<tr class="separator:ad139bae81491baf46c8e9879867f3487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b855430663e628219f5dedcdad5acde"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a4b855430663e628219f5dedcdad5acde">value_type</a></td></tr>
<tr class="memdesc:a4b855430663e628219f5dedcdad5acde"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type <code>T</code> exactly as it was defined upon array object creation.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a4b855430663e628219f5dedcdad5acde">More...</a><br /></td></tr>
<tr class="separator:a4b855430663e628219f5dedcdad5acde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classyakl_1_1ArrayBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classyakl_1_1ArrayBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase&lt; T, rank, myMem, styleC &gt;</a></td></tr>
<tr class="memitem:ab93d72c9e827137a972b928af87a9e3f inherit pub_types_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">typedef std::add_const&lt; <a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a> &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#ab93d72c9e827137a972b928af87a9e3f">const_value_type</a></td></tr>
<tr class="memdesc:ab93d72c9e827137a972b928af87a9e3f inherit pub_types_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type <code>T</code> with <code>const</code> added to it (if the original type has <code>volatile</code>, then so will this type.  <a href="classyakl_1_1ArrayBase.html#ab93d72c9e827137a972b928af87a9e3f">More...</a><br /></td></tr>
<tr class="separator:ab93d72c9e827137a972b928af87a9e3f inherit pub_types_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4212fa32ba3a9a87a5a4fde69d4a2f0 inherit pub_types_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">typedef std::remove_const&lt; <a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a> &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#ae4212fa32ba3a9a87a5a4fde69d4a2f0">non_const_value_type</a></td></tr>
<tr class="memdesc:ae4212fa32ba3a9a87a5a4fde69d4a2f0 inherit pub_types_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type <code>T</code> with <code>const</code> removed from it (if the original type has <code>volatile</code>, then so will this type.  <a href="classyakl_1_1ArrayBase.html#ae4212fa32ba3a9a87a5a4fde69d4a2f0">More...</a><br /></td></tr>
<tr class="separator:ae4212fa32ba3a9a87a5a4fde69d4a2f0 inherit pub_types_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c8aec2f010ccfe2a8db0c760b7bb71 inherit pub_types_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">typedef std::remove_cv&lt; T &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a></td></tr>
<tr class="memdesc:a99c8aec2f010ccfe2a8db0c760b7bb71 inherit pub_types_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type <code>T</code> without <code>const</code> and <code>volatile</code> modifiers.  <a href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">More...</a><br /></td></tr>
<tr class="separator:a99c8aec2f010ccfe2a8db0c760b7bb71 inherit pub_types_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dd11d776c327372882831924e08461 inherit pub_types_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a16dd11d776c327372882831924e08461">value_type</a></td></tr>
<tr class="memdesc:a16dd11d776c327372882831924e08461 inherit pub_types_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type <code>T</code> exactly as it was defined upon array object creation.  <a href="classyakl_1_1ArrayBase.html#a16dd11d776c327372882831924e08461">More...</a><br /></td></tr>
<tr class="separator:a16dd11d776c327372882831924e08461 inherit pub_types_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7e9c91ae56f5cd72538dc79b0c3d6782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a7e9c91ae56f5cd72538dc79b0c3d6782">Array</a> ()</td></tr>
<tr class="memdesc:a7e9c91ae56f5cd72538dc79b0c3d6782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty, unallocated object.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a7e9c91ae56f5cd72538dc79b0c3d6782">More...</a><br /></td></tr>
<tr class="separator:a7e9c91ae56f5cd72538dc79b0c3d6782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6955263a2b4ff3bfeedffdc8fcff245f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a6955263a2b4ff3bfeedffdc8fcff245f">Array</a> (<a class="el" href="classyakl_1_1Array.html">Array</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a6955263a2b4ff3bfeedffdc8fcff245f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move metadata and data pointer. No deep copy.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a6955263a2b4ff3bfeedffdc8fcff245f">More...</a><br /></td></tr>
<tr class="separator:a6955263a2b4ff3bfeedffdc8fcff245f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b6933742f1de190087027336b25623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#af5b6933742f1de190087027336b25623">Array</a> (<a class="el" href="classyakl_1_1Array.html">Array</a>&lt; <a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a7fee476637337e1e949af60de2b0ffe5">const_value_type</a>, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:af5b6933742f1de190087027336b25623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy metadata, share data pointer; if owned, increment reference counter. No deep copy.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#af5b6933742f1de190087027336b25623">More...</a><br /></td></tr>
<tr class="separator:af5b6933742f1de190087027336b25623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af461f4f73f3ea101ad2c987292922332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#af461f4f73f3ea101ad2c987292922332">Array</a> (<a class="el" href="classyakl_1_1Array.html">Array</a>&lt; <a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#af2418211857fefc3acc91e34027c86ff">non_const_value_type</a>, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:af461f4f73f3ea101ad2c987292922332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy metadata, share data pointer; if owned, increment reference counter. No deep copy.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#af461f4f73f3ea101ad2c987292922332">More...</a><br /></td></tr>
<tr class="separator:af461f4f73f3ea101ad2c987292922332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd269370824d087b09cc59187482bb91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#afd269370824d087b09cc59187482bb91">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>)</td></tr>
<tr class="memdesc:afd269370824d087b09cc59187482bb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty, unallocated object with a label.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#afd269370824d087b09cc59187482bb91">More...</a><br /></td></tr>
<tr class="separator:afd269370824d087b09cc59187482bb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd98ee051c06a076d2f2446c4b65e36a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#afd98ee051c06a076d2f2446c4b65e36a">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, <a class="el" href="classyakl_1_1Dims.html">Dims</a> const dims)</td></tr>
<tr class="memdesc:afd98ee051c06a076d2f2446c4b65e36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic initializer-list or std::vector based owned constructor.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#afd98ee051c06a076d2f2446c4b65e36a">More...</a><br /></td></tr>
<tr class="separator:afd98ee051c06a076d2f2446c4b65e36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0d499950eb0a4b0f7c4144291c62a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a6b0d499950eb0a4b0f7c4144291c62a5">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d1)</td></tr>
<tr class="memdesc:a6b0d499950eb0a4b0f7c4144291c62a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-D owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a6b0d499950eb0a4b0f7c4144291c62a5">More...</a><br /></td></tr>
<tr class="separator:a6b0d499950eb0a4b0f7c4144291c62a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55db2a1e3d34e5d61365710efde9c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ac55db2a1e3d34e5d61365710efde9c78">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d2)</td></tr>
<tr class="memdesc:ac55db2a1e3d34e5d61365710efde9c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-D owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ac55db2a1e3d34e5d61365710efde9c78">More...</a><br /></td></tr>
<tr class="separator:ac55db2a1e3d34e5d61365710efde9c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2251b5e420b2b729a128206eb76cbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a1d2251b5e420b2b729a128206eb76cbb">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d3)</td></tr>
<tr class="memdesc:a1d2251b5e420b2b729a128206eb76cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-D owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a1d2251b5e420b2b729a128206eb76cbb">More...</a><br /></td></tr>
<tr class="separator:a1d2251b5e420b2b729a128206eb76cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cb661028a9405ddbf55768e45a74c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a62cb661028a9405ddbf55768e45a74c6">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d4)</td></tr>
<tr class="memdesc:a62cb661028a9405ddbf55768e45a74c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">4-D owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a62cb661028a9405ddbf55768e45a74c6">More...</a><br /></td></tr>
<tr class="separator:a62cb661028a9405ddbf55768e45a74c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab016166d28c859cc0c44c45a3f7a502f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ab016166d28c859cc0c44c45a3f7a502f">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d5)</td></tr>
<tr class="memdesc:ab016166d28c859cc0c44c45a3f7a502f"><td class="mdescLeft">&#160;</td><td class="mdescRight">5-D owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ab016166d28c859cc0c44c45a3f7a502f">More...</a><br /></td></tr>
<tr class="separator:ab016166d28c859cc0c44c45a3f7a502f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d43ca02394f6e9551a95b0021274ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ab7d43ca02394f6e9551a95b0021274ef">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d5, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d6)</td></tr>
<tr class="memdesc:ab7d43ca02394f6e9551a95b0021274ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">6-D owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ab7d43ca02394f6e9551a95b0021274ef">More...</a><br /></td></tr>
<tr class="separator:ab7d43ca02394f6e9551a95b0021274ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3a0dad5b4e079752be4313eea6387d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a4f3a0dad5b4e079752be4313eea6387d">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d5, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d6, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d7)</td></tr>
<tr class="memdesc:a4f3a0dad5b4e079752be4313eea6387d"><td class="mdescLeft">&#160;</td><td class="mdescRight">7-D owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a4f3a0dad5b4e079752be4313eea6387d">More...</a><br /></td></tr>
<tr class="separator:a4f3a0dad5b4e079752be4313eea6387d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873a3e30f35db44f66fbd943023edfac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a873a3e30f35db44f66fbd943023edfac">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d5, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d6, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d7, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> d8)</td></tr>
<tr class="memdesc:a873a3e30f35db44f66fbd943023edfac"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-D owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a873a3e30f35db44f66fbd943023edfac">More...</a><br /></td></tr>
<tr class="separator:a873a3e30f35db44f66fbd943023edfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d34ff7c19edb7acc89c378fafc61c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a3d34ff7c19edb7acc89c378fafc61c9f">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, T *<a class="el" href="classyakl_1_1ArrayBase.html#a143863763b2e52aa5f9e9817ce9d5320">data</a>, <a class="el" href="classyakl_1_1Dims.html">Dims</a> const dims)</td></tr>
<tr class="memdesc:a3d34ff7c19edb7acc89c378fafc61c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic initializer-list or std::vector based owned constructor.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a3d34ff7c19edb7acc89c378fafc61c9f">More...</a><br /></td></tr>
<tr class="separator:a3d34ff7c19edb7acc89c378fafc61c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4fec56a13a1c98863e2e02c058c304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#aca4fec56a13a1c98863e2e02c058c304">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, T *<a class="el" href="classyakl_1_1ArrayBase.html#a143863763b2e52aa5f9e9817ce9d5320">data</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d1)</td></tr>
<tr class="memdesc:aca4fec56a13a1c98863e2e02c058c304"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-D non-owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#aca4fec56a13a1c98863e2e02c058c304">More...</a><br /></td></tr>
<tr class="separator:aca4fec56a13a1c98863e2e02c058c304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1f087d0c99bf9b699cd8dfb8b4e0e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a9a1f087d0c99bf9b699cd8dfb8b4e0e2">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, T *<a class="el" href="classyakl_1_1ArrayBase.html#a143863763b2e52aa5f9e9817ce9d5320">data</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d2)</td></tr>
<tr class="memdesc:a9a1f087d0c99bf9b699cd8dfb8b4e0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-D non-owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a9a1f087d0c99bf9b699cd8dfb8b4e0e2">More...</a><br /></td></tr>
<tr class="separator:a9a1f087d0c99bf9b699cd8dfb8b4e0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7585e6342f843b7c7aed7fc0a44828a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a7585e6342f843b7c7aed7fc0a44828a7">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, T *<a class="el" href="classyakl_1_1ArrayBase.html#a143863763b2e52aa5f9e9817ce9d5320">data</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d3)</td></tr>
<tr class="memdesc:a7585e6342f843b7c7aed7fc0a44828a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-D non-owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a7585e6342f843b7c7aed7fc0a44828a7">More...</a><br /></td></tr>
<tr class="separator:a7585e6342f843b7c7aed7fc0a44828a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e363a537044ab79f44333d2bdc10467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a3e363a537044ab79f44333d2bdc10467">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, T *<a class="el" href="classyakl_1_1ArrayBase.html#a143863763b2e52aa5f9e9817ce9d5320">data</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d4)</td></tr>
<tr class="memdesc:a3e363a537044ab79f44333d2bdc10467"><td class="mdescLeft">&#160;</td><td class="mdescRight">4-D non-owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a3e363a537044ab79f44333d2bdc10467">More...</a><br /></td></tr>
<tr class="separator:a3e363a537044ab79f44333d2bdc10467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98da60e952b9721b5c3efc8edd52c00f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a98da60e952b9721b5c3efc8edd52c00f">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, T *<a class="el" href="classyakl_1_1ArrayBase.html#a143863763b2e52aa5f9e9817ce9d5320">data</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d5)</td></tr>
<tr class="memdesc:a98da60e952b9721b5c3efc8edd52c00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">5-D non-owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a98da60e952b9721b5c3efc8edd52c00f">More...</a><br /></td></tr>
<tr class="separator:a98da60e952b9721b5c3efc8edd52c00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23dfe84342f3677e31175f9c6198b7f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a23dfe84342f3677e31175f9c6198b7f4">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, T *<a class="el" href="classyakl_1_1ArrayBase.html#a143863763b2e52aa5f9e9817ce9d5320">data</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d5, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d6)</td></tr>
<tr class="memdesc:a23dfe84342f3677e31175f9c6198b7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">6-D non-owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a23dfe84342f3677e31175f9c6198b7f4">More...</a><br /></td></tr>
<tr class="separator:a23dfe84342f3677e31175f9c6198b7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1187bc957c8c5cc55bc715d83aa569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#acb1187bc957c8c5cc55bc715d83aa569">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, T *<a class="el" href="classyakl_1_1ArrayBase.html#a143863763b2e52aa5f9e9817ce9d5320">data</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d5, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d6, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d7)</td></tr>
<tr class="memdesc:acb1187bc957c8c5cc55bc715d83aa569"><td class="mdescLeft">&#160;</td><td class="mdescRight">7-D non-owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#acb1187bc957c8c5cc55bc715d83aa569">More...</a><br /></td></tr>
<tr class="separator:acb1187bc957c8c5cc55bc715d83aa569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6eaa1639c8546d2913f2f7e8541036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#add6eaa1639c8546d2913f2f7e8541036">Array</a> (char const *<a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a>, T *<a class="el" href="classyakl_1_1ArrayBase.html#a143863763b2e52aa5f9e9817ce9d5320">data</a>, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d5, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d6, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d7, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const d8)</td></tr>
<tr class="memdesc:add6eaa1639c8546d2913f2f7e8541036"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-D non-owned constructor  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#add6eaa1639c8546d2913f2f7e8541036">More...</a><br /></td></tr>
<tr class="separator:add6eaa1639c8546d2913f2f7e8541036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9c489c3fb8078a791f06ab3268603b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#acc9c489c3fb8078a791f06ab3268603b">~Array</a> ()</td></tr>
<tr class="memdesc:acc9c489c3fb8078a791f06ab3268603b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If owned, decrement reference counter, and deallocate data when it reaches zero. If non-owned, does nothing.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#acc9c489c3fb8078a791f06ab3268603b">More...</a><br /></td></tr>
<tr class="separator:acc9c489c3fb8078a791f06ab3268603b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af3e12b6800b654d3461920bcf068f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, 1, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a4af3e12b6800b654d3461920bcf068f6">collapse</a> () const</td></tr>
<tr class="memdesc:a4af3e12b6800b654d3461920bcf068f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse this array into a 1-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a4af3e12b6800b654d3461920bcf068f6">More...</a><br /></td></tr>
<tr class="separator:a4af3e12b6800b654d3461920bcf068f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333fb42a173963bd6728bdcd06197aaf"><td class="memTemplParams" colspan="2">template&lt;class TLOC  = T&gt; </td></tr>
<tr class="memitem:a333fb42a173963bd6728bdcd06197aaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; TLOC, rank, <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce">memDevice</a>, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a333fb42a173963bd6728bdcd06197aaf">createDeviceCopy</a> () const</td></tr>
<tr class="memdesc:a333fb42a173963bd6728bdcd06197aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">[DEEP_COPY] Create a copy of this array in <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> space  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a333fb42a173963bd6728bdcd06197aaf">More...</a><br /></td></tr>
<tr class="separator:a333fb42a173963bd6728bdcd06197aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68f2ef882c1cd4374ab960290782b5d"><td class="memTemplParams" colspan="2">template&lt;class TLOC  = typename std::remove_cv&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:ab68f2ef882c1cd4374ab960290782b5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; typename std::remove_cv&lt; TLOC &gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a>, rank, <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce">memDevice</a>, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ab68f2ef882c1cd4374ab960290782b5d">createDeviceObject</a> () const</td></tr>
<tr class="memdesc:ab68f2ef882c1cd4374ab960290782b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and allocate a <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> array object of the same type, rank, dimensions, and style.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ab68f2ef882c1cd4374ab960290782b5d">More...</a><br /></td></tr>
<tr class="separator:ab68f2ef882c1cd4374ab960290782b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87232915db9a00c55ffc1cbdc2be9927"><td class="memTemplParams" colspan="2">template&lt;class TLOC  = T&gt; </td></tr>
<tr class="memitem:a87232915db9a00c55ffc1cbdc2be9927"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; TLOC, rank, <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98">memHost</a>, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a87232915db9a00c55ffc1cbdc2be9927">createHostCopy</a> () const</td></tr>
<tr class="memdesc:a87232915db9a00c55ffc1cbdc2be9927"><td class="mdescLeft">&#160;</td><td class="mdescRight">[DEEP_COPY] Create a copy of this array in <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> space  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a87232915db9a00c55ffc1cbdc2be9927">More...</a><br /></td></tr>
<tr class="separator:a87232915db9a00c55ffc1cbdc2be9927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e59efa937ef10e35bdaf87a80d0011"><td class="memTemplParams" colspan="2">template&lt;class TLOC  = typename std::remove_cv&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:ac0e59efa937ef10e35bdaf87a80d0011"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; typename std::remove_cv&lt; TLOC &gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a>, rank, <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98">memHost</a>, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ac0e59efa937ef10e35bdaf87a80d0011">createHostObject</a> () const</td></tr>
<tr class="memdesc:ac0e59efa937ef10e35bdaf87a80d0011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and allocate a <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> array object of the same type, rank, dimensions, and style.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ac0e59efa937ef10e35bdaf87a80d0011">More...</a><br /></td></tr>
<tr class="separator:ac0e59efa937ef10e35bdaf87a80d0011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35520392cca515a1cdfbaf189a7e2903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a35520392cca515a1cdfbaf189a7e2903">extent</a> (int dim) const</td></tr>
<tr class="memdesc:a35520392cca515a1cdfbaf189a7e2903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extent of the requested dimension of this array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a35520392cca515a1cdfbaf189a7e2903">More...</a><br /></td></tr>
<tr class="separator:a35520392cca515a1cdfbaf189a7e2903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf268893531899a1cbaab7db0218edf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>, 1, rank &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#adf268893531899a1cbaab7db0218edf3">get_dimensions</a> () const</td></tr>
<tr class="memdesc:adf268893531899a1cbaab7db0218edf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimensions of this array as a <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a> object.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#adf268893531899a1cbaab7db0218edf3">More...</a><br /></td></tr>
<tr class="separator:adf268893531899a1cbaab7db0218edf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9336df9b02fdc612af2cb8e0dc4b409"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>, 1, rank &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ae9336df9b02fdc612af2cb8e0dc4b409">get_lbounds</a> () const</td></tr>
<tr class="memdesc:ae9336df9b02fdc612af2cb8e0dc4b409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lower bound of each dimension of this array (which are always all zero) as a <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a> object.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ae9336df9b02fdc612af2cb8e0dc4b409">More...</a><br /></td></tr>
<tr class="separator:ae9336df9b02fdc612af2cb8e0dc4b409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47342fd163789a54fcce61e03a4e1a3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>, 1, rank &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a47342fd163789a54fcce61e03a4e1a3a">get_ubounds</a> () const</td></tr>
<tr class="memdesc:a47342fd163789a54fcce61e03a4e1a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper bound of each dimension of this array as a <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a> object.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a47342fd163789a54fcce61e03a4e1a3a">More...</a><br /></td></tr>
<tr class="separator:a47342fd163789a54fcce61e03a4e1a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca05dc9bd3def425e479437fb19e80b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#aca05dc9bd3def425e479437fb19e80b6">operator()</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0) const</td></tr>
<tr class="memdesc:aca05dc9bd3def425e479437fb19e80b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to element at the requested index (1-D)  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#aca05dc9bd3def425e479437fb19e80b6">More...</a><br /></td></tr>
<tr class="separator:aca05dc9bd3def425e479437fb19e80b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3005e09d2fb85d7b063cab02240a3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a5b3005e09d2fb85d7b063cab02240a3e">operator()</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1) const</td></tr>
<tr class="memdesc:a5b3005e09d2fb85d7b063cab02240a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to element at the requested indices (2-D)  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a5b3005e09d2fb85d7b063cab02240a3e">More...</a><br /></td></tr>
<tr class="separator:a5b3005e09d2fb85d7b063cab02240a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7cad1389b17dfb822bd0805e13a736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ada7cad1389b17dfb822bd0805e13a736">operator()</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i2) const</td></tr>
<tr class="memdesc:ada7cad1389b17dfb822bd0805e13a736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to element at the requested indices (3-D)  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ada7cad1389b17dfb822bd0805e13a736">More...</a><br /></td></tr>
<tr class="separator:ada7cad1389b17dfb822bd0805e13a736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c4120190ec4bbb66d57e1a91c65ec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ab2c4120190ec4bbb66d57e1a91c65ec1">operator()</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i3) const</td></tr>
<tr class="memdesc:ab2c4120190ec4bbb66d57e1a91c65ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to element at the requested indices (4-D)  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ab2c4120190ec4bbb66d57e1a91c65ec1">More...</a><br /></td></tr>
<tr class="separator:ab2c4120190ec4bbb66d57e1a91c65ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71332c2aaead8c758194e236d9a4fc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ac71332c2aaead8c758194e236d9a4fc5">operator()</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i4) const</td></tr>
<tr class="memdesc:ac71332c2aaead8c758194e236d9a4fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to element at the requested indices (5-D)  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ac71332c2aaead8c758194e236d9a4fc5">More...</a><br /></td></tr>
<tr class="separator:ac71332c2aaead8c758194e236d9a4fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fd635d3ff308e5150c03c48882081f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a96fd635d3ff308e5150c03c48882081f">operator()</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i5) const</td></tr>
<tr class="memdesc:a96fd635d3ff308e5150c03c48882081f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to element at the requested indices (6-D)  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a96fd635d3ff308e5150c03c48882081f">More...</a><br /></td></tr>
<tr class="separator:a96fd635d3ff308e5150c03c48882081f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c17fbb79a84b25e3e4f3cd43e3928c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a9c17fbb79a84b25e3e4f3cd43e3928c5">operator()</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i5, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i6) const</td></tr>
<tr class="memdesc:a9c17fbb79a84b25e3e4f3cd43e3928c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to element at the requested indices (7-D)  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a9c17fbb79a84b25e3e4f3cd43e3928c5">More...</a><br /></td></tr>
<tr class="separator:a9c17fbb79a84b25e3e4f3cd43e3928c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a3d7ceeabc81decbc982daa9fdb846"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a20a3d7ceeabc81decbc982daa9fdb846">operator()</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i5, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i6, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i7) const</td></tr>
<tr class="memdesc:a20a3d7ceeabc81decbc982daa9fdb846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to element at the requested indices (8-D)  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a20a3d7ceeabc81decbc982daa9fdb846">More...</a><br /></td></tr>
<tr class="separator:a20a3d7ceeabc81decbc982daa9fdb846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6f6fd8e7717d5fd1960c57ea5c0083"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#afc6f6fd8e7717d5fd1960c57ea5c0083">operator=</a> (<a class="el" href="classyakl_1_1Array.html">Array</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:afc6f6fd8e7717d5fd1960c57ea5c0083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move metadata and data pointer. No deep copy.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#afc6f6fd8e7717d5fd1960c57ea5c0083">More...</a><br /></td></tr>
<tr class="separator:afc6f6fd8e7717d5fd1960c57ea5c0083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf06bdd76d6ab9017b7f7a6375acba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#aecf06bdd76d6ab9017b7f7a6375acba3">operator=</a> (<a class="el" href="classyakl_1_1Array.html">Array</a>&lt; <a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a7fee476637337e1e949af60de2b0ffe5">const_value_type</a>, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:aecf06bdd76d6ab9017b7f7a6375acba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy metadata, share data pointer; if owned, increment reference counter. No deep copy.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#aecf06bdd76d6ab9017b7f7a6375acba3">More...</a><br /></td></tr>
<tr class="separator:aecf06bdd76d6ab9017b7f7a6375acba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a8cb42e0c7198fe61be37984d17101"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a62a8cb42e0c7198fe61be37984d17101">operator=</a> (<a class="el" href="classyakl_1_1Array.html">Array</a>&lt; <a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#af2418211857fefc3acc91e34027c86ff">non_const_value_type</a>, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a62a8cb42e0c7198fe61be37984d17101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy metadata, share data pointer; if owned, increment reference counter. No deep copy.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a62a8cb42e0c7198fe61be37984d17101">More...</a><br /></td></tr>
<tr class="separator:a62a8cb42e0c7198fe61be37984d17101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac315417bc8e21bd35a4f365bb2adf4"><td class="memTemplParams" colspan="2">template&lt;class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </td></tr>
<tr class="memitem:a2ac315417bc8e21bd35a4f365bb2adf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classyakl_1_1Array.html">Array</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a2ac315417bc8e21bd35a4f365bb2adf4">operator=</a> (TLOC const &amp;rhs)</td></tr>
<tr class="memdesc:a2ac315417bc8e21bd35a4f365bb2adf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">[ASYNCHRONOUS] Assign a scalar arithmetic value to all entries in this array object  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a2ac315417bc8e21bd35a4f365bb2adf4">More...</a><br /></td></tr>
<tr class="separator:a2ac315417bc8e21bd35a4f365bb2adf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6092733c7d4bea64f455361a2d5d6"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a93e6092733c7d4bea64f455361a2d5d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, N, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a93e6092733c7d4bea64f455361a2d5d6">reshape</a> (<a class="el" href="classyakl_1_1Dims.html">Dims</a> const &amp;dims) const</td></tr>
<tr class="memdesc:a93e6092733c7d4bea64f455361a2d5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape array using initializer list or std::vector indices.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a93e6092733c7d4bea64f455361a2d5d6">More...</a><br /></td></tr>
<tr class="separator:a93e6092733c7d4bea64f455361a2d5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfedf0478cdcd4a52538784832ed340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, 1, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a4cfedf0478cdcd4a52538784832ed340">reshape</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0) const</td></tr>
<tr class="memdesc:a4cfedf0478cdcd4a52538784832ed340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape array into a 1-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a4cfedf0478cdcd4a52538784832ed340">More...</a><br /></td></tr>
<tr class="separator:a4cfedf0478cdcd4a52538784832ed340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c1110515f50978d4b27003aeaa7380"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, 2, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#af5c1110515f50978d4b27003aeaa7380">reshape</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1) const</td></tr>
<tr class="memdesc:af5c1110515f50978d4b27003aeaa7380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape array into a 2-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#af5c1110515f50978d4b27003aeaa7380">More...</a><br /></td></tr>
<tr class="separator:af5c1110515f50978d4b27003aeaa7380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6116e8055009ca9f199fce739af527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, 3, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#acc6116e8055009ca9f199fce739af527">reshape</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i2) const</td></tr>
<tr class="memdesc:acc6116e8055009ca9f199fce739af527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape array into a 3-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#acc6116e8055009ca9f199fce739af527">More...</a><br /></td></tr>
<tr class="separator:acc6116e8055009ca9f199fce739af527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b1eac9efc94c888a54dd23a9408242"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, 4, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a24b1eac9efc94c888a54dd23a9408242">reshape</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i3) const</td></tr>
<tr class="memdesc:a24b1eac9efc94c888a54dd23a9408242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape array into a 4-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a24b1eac9efc94c888a54dd23a9408242">More...</a><br /></td></tr>
<tr class="separator:a24b1eac9efc94c888a54dd23a9408242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a88c2253ae379e75540da22b7e3fb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, 5, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad0a88c2253ae379e75540da22b7e3fb1">reshape</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i4) const</td></tr>
<tr class="memdesc:ad0a88c2253ae379e75540da22b7e3fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape array into a 5-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad0a88c2253ae379e75540da22b7e3fb1">More...</a><br /></td></tr>
<tr class="separator:ad0a88c2253ae379e75540da22b7e3fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfe677d46c6f8c1d5ddea2283961607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, 6, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a7cfe677d46c6f8c1d5ddea2283961607">reshape</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i5) const</td></tr>
<tr class="memdesc:a7cfe677d46c6f8c1d5ddea2283961607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape array into a 6-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a7cfe677d46c6f8c1d5ddea2283961607">More...</a><br /></td></tr>
<tr class="separator:a7cfe677d46c6f8c1d5ddea2283961607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c980edef0d027de290c3872ff57545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, 7, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a25c980edef0d027de290c3872ff57545">reshape</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i5, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i6) const</td></tr>
<tr class="memdesc:a25c980edef0d027de290c3872ff57545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape array into a 7-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a25c980edef0d027de290c3872ff57545">More...</a><br /></td></tr>
<tr class="separator:a25c980edef0d027de290c3872ff57545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0b479e4d54ed0981c435683f06ee74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, 8, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#aab0b479e4d54ed0981c435683f06ee74">reshape</a> (<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i0, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i1, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i2, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i3, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i4, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i5, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i6, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> i7) const</td></tr>
<tr class="memdesc:aab0b479e4d54ed0981c435683f06ee74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape array into a 8-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#aab0b479e4d54ed0981c435683f06ee74">More...</a><br /></td></tr>
<tr class="separator:aab0b479e4d54ed0981c435683f06ee74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac49af0beacfd0fa88bf58255aa6d4c2"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:aac49af0beacfd0fa88bf58255aa6d4c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, N, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#aac49af0beacfd0fa88bf58255aa6d4c2">slice</a> (<a class="el" href="classyakl_1_1Dims.html">Dims</a> const &amp;dims) const</td></tr>
<tr class="memdesc:aac49af0beacfd0fa88bf58255aa6d4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice using initializer list or std::vector indices.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#aac49af0beacfd0fa88bf58255aa6d4c2">More...</a><br /></td></tr>
<tr class="separator:aac49af0beacfd0fa88bf58255aa6d4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44195e77991a02eb12b04816b87206b"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ad44195e77991a02eb12b04816b87206b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, N, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad44195e77991a02eb12b04816b87206b">slice</a> (int i0) const</td></tr>
<tr class="memdesc:ad44195e77991a02eb12b04816b87206b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 1-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad44195e77991a02eb12b04816b87206b">More...</a><br /></td></tr>
<tr class="separator:ad44195e77991a02eb12b04816b87206b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590905f2d1a58717b4851b5f0b4e2602"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a590905f2d1a58717b4851b5f0b4e2602"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, N, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a590905f2d1a58717b4851b5f0b4e2602">slice</a> (int i0, int i1) const</td></tr>
<tr class="memdesc:a590905f2d1a58717b4851b5f0b4e2602"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 2-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a590905f2d1a58717b4851b5f0b4e2602">More...</a><br /></td></tr>
<tr class="separator:a590905f2d1a58717b4851b5f0b4e2602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e49c35a4beb93f941db93c61db206fb"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a5e49c35a4beb93f941db93c61db206fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, N, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a5e49c35a4beb93f941db93c61db206fb">slice</a> (int i0, int i1, int i2) const</td></tr>
<tr class="memdesc:a5e49c35a4beb93f941db93c61db206fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 3-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a5e49c35a4beb93f941db93c61db206fb">More...</a><br /></td></tr>
<tr class="separator:a5e49c35a4beb93f941db93c61db206fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e6861e4cc2b3ce235e7cb5e460cbba"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a74e6861e4cc2b3ce235e7cb5e460cbba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, N, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a74e6861e4cc2b3ce235e7cb5e460cbba">slice</a> (int i0, int i1, int i2, int i3) const</td></tr>
<tr class="memdesc:a74e6861e4cc2b3ce235e7cb5e460cbba"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 4-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a74e6861e4cc2b3ce235e7cb5e460cbba">More...</a><br /></td></tr>
<tr class="separator:a74e6861e4cc2b3ce235e7cb5e460cbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999d6dca55e1cf9381508e3c35a0b07b"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a999d6dca55e1cf9381508e3c35a0b07b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, N, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a999d6dca55e1cf9381508e3c35a0b07b">slice</a> (int i0, int i1, int i2, int i3, int i4) const</td></tr>
<tr class="memdesc:a999d6dca55e1cf9381508e3c35a0b07b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 5-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a999d6dca55e1cf9381508e3c35a0b07b">More...</a><br /></td></tr>
<tr class="separator:a999d6dca55e1cf9381508e3c35a0b07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cae9038b7235e62b4009a74980c20d9"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a5cae9038b7235e62b4009a74980c20d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, N, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a5cae9038b7235e62b4009a74980c20d9">slice</a> (int i0, int i1, int i2, int i3, int i4, int i5) const</td></tr>
<tr class="memdesc:a5cae9038b7235e62b4009a74980c20d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 6-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a5cae9038b7235e62b4009a74980c20d9">More...</a><br /></td></tr>
<tr class="separator:a5cae9038b7235e62b4009a74980c20d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28afdaf25967fe192a895c3bc461fe3d"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a28afdaf25967fe192a895c3bc461fe3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, N, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a28afdaf25967fe192a895c3bc461fe3d">slice</a> (int i0, int i1, int i2, int i3, int i4, int i5, int i6) const</td></tr>
<tr class="memdesc:a28afdaf25967fe192a895c3bc461fe3d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 7-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a28afdaf25967fe192a895c3bc461fe3d">More...</a><br /></td></tr>
<tr class="separator:a28afdaf25967fe192a895c3bc461fe3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fa982e94e4a11efddba58c700c8fbb"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ae9fa982e94e4a11efddba58c700c8fbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, N, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ae9fa982e94e4a11efddba58c700c8fbb">slice</a> (int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7) const</td></tr>
<tr class="memdesc:ae9fa982e94e4a11efddba58c700c8fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 8-D array.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ae9fa982e94e4a11efddba58c700c8fbb">More...</a><br /></td></tr>
<tr class="separator:ae9fa982e94e4a11efddba58c700c8fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classyakl_1_1ArrayBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classyakl_1_1ArrayBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase&lt; T, rank, myMem, styleC &gt;</a></td></tr>
<tr class="memitem:a143863763b2e52aa5f9e9817ce9d5320 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a143863763b2e52aa5f9e9817ce9d5320">data</a> () const</td></tr>
<tr class="memdesc:a143863763b2e52aa5f9e9817ce9d5320 inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw data pointer of this array object.  <a href="classyakl_1_1ArrayBase.html#a143863763b2e52aa5f9e9817ce9d5320">More...</a><br /></td></tr>
<tr class="separator:a143863763b2e52aa5f9e9817ce9d5320 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a647ff5f5afc6abf9210e72171590c inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a34a647ff5f5afc6abf9210e72171590c">deallocate</a> ()</td></tr>
<tr class="memdesc:a34a647ff5f5afc6abf9210e72171590c inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">If owned, decrement the reference counter; if ref counter reaches zero, deallocate memory; If non-owned, does nothing.  <a href="classyakl_1_1ArrayBase.html#a34a647ff5f5afc6abf9210e72171590c">More...</a><br /></td></tr>
<tr class="separator:a34a647ff5f5afc6abf9210e72171590c inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a647ff5f5afc6abf9210e72171590c inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a34a647ff5f5afc6abf9210e72171590c">deallocate</a> ()</td></tr>
<tr class="memdesc:a34a647ff5f5afc6abf9210e72171590c inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">If owned, decrement the reference counter; if ref counter reaches zero, deallocate memory; If non-owned, does nothing.  <a href="classyakl_1_1ArrayBase.html#a34a647ff5f5afc6abf9210e72171590c">More...</a><br /></td></tr>
<tr class="separator:a34a647ff5f5afc6abf9210e72171590c inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39bad525cf7d5c5e68fb2cbd76765a7 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#aa39bad525cf7d5c5e68fb2cbd76765a7">deep_copy_to</a> (<a class="el" href="classyakl_1_1Array.html">Array</a>&lt; typename std::remove_cv&lt; T &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>, theirRank, memDevice, theirStyle &gt; const &amp;lhs) const</td></tr>
<tr class="memdesc:aa39bad525cf7d5c5e68fb2cbd76765a7 inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">[ASYNCHRONOUS] [DEEP_COPY] Copy this array's contents to a <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> array.  <a href="classyakl_1_1ArrayBase.html#aa39bad525cf7d5c5e68fb2cbd76765a7">More...</a><br /></td></tr>
<tr class="separator:aa39bad525cf7d5c5e68fb2cbd76765a7 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3987baec655624d638396567c9967d2 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#ac3987baec655624d638396567c9967d2">deep_copy_to</a> (<a class="el" href="classyakl_1_1Array.html">Array</a>&lt; typename std::remove_cv&lt; T &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>, theirRank, memHost, theirStyle &gt; const &amp;lhs) const</td></tr>
<tr class="memdesc:ac3987baec655624d638396567c9967d2 inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">[ASYNCHRONOUS] [DEEP_COPY] Copy this array's contents to a <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> array.  <a href="classyakl_1_1ArrayBase.html#ac3987baec655624d638396567c9967d2">More...</a><br /></td></tr>
<tr class="separator:ac3987baec655624d638396567c9967d2 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30952cae3c858f3cc186f9b2b75436e5 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a30952cae3c858f3cc186f9b2b75436e5">get_data</a> () const</td></tr>
<tr class="memdesc:a30952cae3c858f3cc186f9b2b75436e5 inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw data pointer of this array object.  <a href="classyakl_1_1ArrayBase.html#a30952cae3c858f3cc186f9b2b75436e5">More...</a><br /></td></tr>
<tr class="separator:a30952cae3c858f3cc186f9b2b75436e5 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9c53c39898d244feb979ab56bbb91f inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a4c9c53c39898d244feb979ab56bbb91f">get_elem_count</a> () const</td></tr>
<tr class="memdesc:a4c9c53c39898d244feb979ab56bbb91f inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements in this array object.  <a href="classyakl_1_1ArrayBase.html#a4c9c53c39898d244feb979ab56bbb91f">More...</a><br /></td></tr>
<tr class="separator:a4c9c53c39898d244feb979ab56bbb91f inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5069cb724512bc32277dee3454dae0c inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#ae5069cb724512bc32277dee3454dae0c">get_rank</a> () const</td></tr>
<tr class="memdesc:ae5069cb724512bc32277dee3454dae0c inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of dimensions in this array object.  <a href="classyakl_1_1ArrayBase.html#ae5069cb724512bc32277dee3454dae0c">More...</a><br /></td></tr>
<tr class="separator:ae5069cb724512bc32277dee3454dae0c inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3373ceea89cf75ee78b2293bcafec919 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a3373ceea89cf75ee78b2293bcafec919">get_totElems</a> () const</td></tr>
<tr class="memdesc:a3373ceea89cf75ee78b2293bcafec919 inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements in this array object.  <a href="classyakl_1_1ArrayBase.html#a3373ceea89cf75ee78b2293bcafec919">More...</a><br /></td></tr>
<tr class="separator:a3373ceea89cf75ee78b2293bcafec919 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c013a8fd5591b535efc58ddd9f9e34a inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a2c013a8fd5591b535efc58ddd9f9e34a">initialized</a> () const</td></tr>
<tr class="memdesc:a2c013a8fd5591b535efc58ddd9f9e34a inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this array object has is in an initialized / allocated state.  <a href="classyakl_1_1ArrayBase.html#a2c013a8fd5591b535efc58ddd9f9e34a">More...</a><br /></td></tr>
<tr class="separator:a2c013a8fd5591b535efc58ddd9f9e34a inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e355c36b4752b538379580a463b3155 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a> () const</td></tr>
<tr class="memdesc:a8e355c36b4752b538379580a463b3155 inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this array object's string label if the <code>YAKL_DEBUG</code> CPP macro is defined. Otherwise, returns an empty string.  <a href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">More...</a><br /></td></tr>
<tr class="separator:a8e355c36b4752b538379580a463b3155 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7f82d7a960950a9f3586c763c2c0f1 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a8d7f82d7a960950a9f3586c763c2c0f1">span_is_contiguous</a> () const</td></tr>
<tr class="memdesc:a8d7f82d7a960950a9f3586c763c2c0f1 inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always true. <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects are always contiguous in memory with no padding.  <a href="classyakl_1_1ArrayBase.html#a8d7f82d7a960950a9f3586c763c2c0f1">More...</a><br /></td></tr>
<tr class="separator:a8d7f82d7a960950a9f3586c763c2c0f1 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b0d114b4b42a1719f7f7123cc84526 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a29b0d114b4b42a1719f7f7123cc84526">totElems</a> () const</td></tr>
<tr class="memdesc:a29b0d114b4b42a1719f7f7123cc84526 inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements in this array object.  <a href="classyakl_1_1ArrayBase.html#a29b0d114b4b42a1719f7f7123cc84526">More...</a><br /></td></tr>
<tr class="separator:a29b0d114b4b42a1719f7f7123cc84526 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c1fe00357c035543b73300839f9d75 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#ad9c1fe00357c035543b73300839f9d75">use_count</a> () const</td></tr>
<tr class="memdesc:ad9c1fe00357c035543b73300839f9d75 inherit pub_methods_classyakl_1_1ArrayBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many array objects share this pointer if owned; or <code>0</code> if unowned.  <a href="classyakl_1_1ArrayBase.html#ad9c1fe00357c035543b73300839f9d75">More...</a><br /></td></tr>
<tr class="separator:ad9c1fe00357c035543b73300839f9d75 inherit pub_methods_classyakl_1_1ArrayBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, int rank, int myMem&gt;<br />
class yakl::Array&lt; T, rank, myMem, styleC &gt;</h3>

<p>This implements the yakl:<a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> class with <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d" title="Template parameter for yakl::Array that specifies it should follow C-style behavior.">yakl::styleC</a> behavior. </p>
<p>C-style behavior means all lower bounds for dimensions are zero, and index ordering is row-major, meaning the right-most index varies the fastest. IMPORTANT: Please see the <a class="el" href="classyakl_1_1ArrayBase.html" title="This class implements functionality common to both yakl::styleC and yakl::styleFortran Array objects.">yakl::ArrayBase</a> class because this class includes all of its functionality. click for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of the array. For <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> arrays, this can be generally any time. For <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> arrays, this needs to be a type with no constructor, preferably an arithmetic type. </td></tr>
    <tr><td class="paramname">rank</td><td>The number of dimensions for this array object. </td></tr>
    <tr><td class="paramname">myMem</td><td>The memory space for this array object: either <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> or <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> </td></tr>
    <tr><td class="paramname">myStyle</td><td><a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d" title="Template parameter for yakl::Array that specifies it should follow C-style behavior.">yakl::styleC</a></td></tr>
  </table>
  </dd>
</dl>
<p>YAKL's multi-dimensional array objects can be considered in some ways to behave as pointers. For instance, if you assign one object to another: </p><div class="fragment"><div class="line"><a class="code" href="classyakl_1_1Array.html">yakl::Array&lt;float,1,memHost,styleC&gt;</a> arr1(<span class="stringliteral">&quot;arr1&quot;</span>,n);</div>
<div class="line"><a class="code" href="classyakl_1_1Array.html">yakl::Array&lt;float,1,memHost,styleC&gt;</a> arr2 = arr1; <span class="comment">// This is very fast; no allocation or copy of underlying data occurs</span></div>
<div class="line">arr2 = 5; <span class="comment">// This will change both arr1 and arr2 because they share the same data pointer</span></div>
</div><!-- fragment --><p>This will share the same data pointer between <code>arr1</code> and <code>arr2</code>. Further, passing <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects by value is fast because it only copies the metadata over and shares the pointer to the underlying data.</p>
<p>To copy data to another array object's data pointer, use <code><a class="el" href="classyakl_1_1ArrayBase.html#ac3987baec655624d638396567c9967d2" title="[ASYNCHRONOUS] [DEEP_COPY] Copy this array&#39;s contents to a yakl::memHost array.">deep_copy_to()</a></code>, <code><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a87232915db9a00c55ffc1cbdc2be9927" title="[DEEP_COPY] Create a copy of this array in yakl::memHost space">createHostCopy()</a></code>, or <code><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a333fb42a173963bd6728bdcd06197aaf" title="[DEEP_COPY] Create a copy of this array in yakl::memDevice space">createDeviceCopy()</a></code>. </p><div class="fragment"><div class="line"><a class="code" href="classyakl_1_1Array.html">yakl::Array&lt;float,1,memHost,styleC&gt;</a> arr1(<span class="stringliteral">&quot;arr1&quot;</span>,n);</div>
<div class="line"><a class="code" href="classyakl_1_1Array.html">yakl::Array&lt;float,1,memHost,styleC&gt;</a> arr2 = arr1.createHostCopy(); <span class="comment">// This is slow. It allocates and copies underlying data.</span></div>
<div class="line">arr2 = 5; <span class="comment">// This will *not* change arr1 because they do not share the same data pointer.</span></div>
</div><!-- fragment --><p>A note on <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects with a <code>const</code> underyling type <code>T</code>: You cannot <b>allocate</b> an array object with <code>const</code> underlying type, but you can <b>create</b> one without allocating. You may copy an array object with non-<code>const</code> underlying type to an array object with <code>const</code> underling type, but not vice versa. After copying an array of non-<code>const</code> type to an array of <code>const</code> type, if you then alter the data pointed to by the non-<code>const</code> array, results are undefined. The typical behavior is below: </p><div class="fragment"><div class="line"><span class="comment">// Passing non-const type array as a parameter to a const-type array (this is fine)</span></div>
<div class="line">real myfunc( Array&lt;float const,1,memHost,styleC&gt; arrConst ) { ... }</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">Array&lt;float,1,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n);</div>
<div class="line">myfunc(arr); <span class="comment">// Totally fine. myfunc just casts the underlying type to const giving const correctness when you want it.</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">Array&lt;float const,1,memHost,styleC&gt; arrConst;</div>
<div class="line">arrConst = arr; <span class="comment">// Again, this is totally fine, BUT, do not change the data pointed to by arr any more</span></div>
<div class="line">arr.deallocate(); <span class="comment">// This is the best practice. Once you transfer the data to a const type, deallocate the non-const type object</span></div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7fee476637337e1e949af60de2b0ffe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fee476637337e1e949af60de2b0ffe5">&#9670;&nbsp;</a></span>const_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::add_const&lt;<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a>&gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a7fee476637337e1e949af60de2b0ffe5">const_value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type <code>T</code> with <code>const</code> added to it. </p>
<p>If the original type has <code>volatile</code>, then so will this type. </p>

</div>
</div>
<a id="af2418211857fefc3acc91e34027c86ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2418211857fefc3acc91e34027c86ff">&#9670;&nbsp;</a></span>non_const_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::remove_const&lt;<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a>&gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#af2418211857fefc3acc91e34027c86ff">non_const_value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type <code>T</code> with <code>const</code> removed from it. </p>
<p>If the original type has <code>volatile</code>, then so will this type. </p>

</div>
</div>
<a id="ad139bae81491baf46c8e9879867f3487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad139bae81491baf46c8e9879867f3487">&#9670;&nbsp;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::remove_cv&lt;T&gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type <code>T</code> without <code>const</code> and <code>volatile</code> modifiers. </p>

</div>
</div>
<a id="a4b855430663e628219f5dedcdad5acde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b855430663e628219f5dedcdad5acde">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a4b855430663e628219f5dedcdad5acde">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type <code>T</code> exactly as it was defined upon array object creation. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7e9c91ae56f5cd72538dc79b0c3d6782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9c91ae56f5cd72538dc79b0c3d6782">&#9670;&nbsp;</a></span>Array() <span class="overload">[1/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty, unallocated object. </p>

</div>
</div>
<a id="afd269370824d087b09cc59187482bb91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd269370824d087b09cc59187482bb91">&#9670;&nbsp;</a></span>Array() <span class="overload">[2/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty, unallocated object with a label. </p>

</div>
</div>
<a id="a6b0d499950eb0a4b0f7c4144291c62a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0d499950eb0a4b0f7c4144291c62a5">&#9670;&nbsp;</a></span>Array() <span class="overload">[3/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1-D owned constructor </p>
<p>This is one of the yakl::CArray "owned" constructors. Create and allocate an owned and reference counted array object. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,1,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1);</div>
<div class="line">Array&lt;float const,4,memDevice,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1,n2,n3,n4);</div>
<div class="line">Array&lt;int,2,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac55db2a1e3d34e5d61365710efde9c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55db2a1e3d34e5d61365710efde9c78">&#9670;&nbsp;</a></span>Array() <span class="overload">[4/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2-D owned constructor </p>
<p>This is one of the yakl::CArray "owned" constructors. Create and allocate an owned and reference counted array object. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,1,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1);</div>
<div class="line">Array&lt;float const,4,memDevice,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1,n2,n3,n4);</div>
<div class="line">Array&lt;int,2,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1d2251b5e420b2b729a128206eb76cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2251b5e420b2b729a128206eb76cbb">&#9670;&nbsp;</a></span>Array() <span class="overload">[5/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>3-D owned constructor </p>
<p>This is one of the yakl::CArray "owned" constructors. Create and allocate an owned and reference counted array object. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,1,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1);</div>
<div class="line">Array&lt;float const,4,memDevice,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1,n2,n3,n4);</div>
<div class="line">Array&lt;int,2,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a62cb661028a9405ddbf55768e45a74c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cb661028a9405ddbf55768e45a74c6">&#9670;&nbsp;</a></span>Array() <span class="overload">[6/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>4-D owned constructor </p>
<p>This is one of the yakl::CArray "owned" constructors. Create and allocate an owned and reference counted array object. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,1,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1);</div>
<div class="line">Array&lt;float const,4,memDevice,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1,n2,n3,n4);</div>
<div class="line">Array&lt;int,2,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab016166d28c859cc0c44c45a3f7a502f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab016166d28c859cc0c44c45a3f7a502f">&#9670;&nbsp;</a></span>Array() <span class="overload">[7/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>5-D owned constructor </p>
<p>This is one of the yakl::CArray "owned" constructors. Create and allocate an owned and reference counted array object. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,1,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1);</div>
<div class="line">Array&lt;float const,4,memDevice,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1,n2,n3,n4);</div>
<div class="line">Array&lt;int,2,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab7d43ca02394f6e9551a95b0021274ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d43ca02394f6e9551a95b0021274ef">&#9670;&nbsp;</a></span>Array() <span class="overload">[8/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>6-D owned constructor </p>
<p>This is one of the yakl::CArray "owned" constructors. Create and allocate an owned and reference counted array object. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,1,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1);</div>
<div class="line">Array&lt;float const,4,memDevice,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1,n2,n3,n4);</div>
<div class="line">Array&lt;int,2,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4f3a0dad5b4e079752be4313eea6387d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3a0dad5b4e079752be4313eea6387d">&#9670;&nbsp;</a></span>Array() <span class="overload">[9/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>7-D owned constructor </p>
<p>This is one of the yakl::CArray "owned" constructors. Create and allocate an owned and reference counted array object. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,1,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1);</div>
<div class="line">Array&lt;float const,4,memDevice,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1,n2,n3,n4);</div>
<div class="line">Array&lt;int,2,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a873a3e30f35db44f66fbd943023edfac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873a3e30f35db44f66fbd943023edfac">&#9670;&nbsp;</a></span>Array() <span class="overload">[10/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>d8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>8-D owned constructor </p>
<p>This is one of the yakl::CArray "owned" constructors. Create and allocate an owned and reference counted array object. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,1,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1);</div>
<div class="line">Array&lt;float const,4,memDevice,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1,n2,n3,n4);</div>
<div class="line">Array&lt;int,2,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afd98ee051c06a076d2f2446c4b65e36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd98ee051c06a076d2f2446c4b65e36a">&#9670;&nbsp;</a></span>Array() <span class="overload">[11/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Dims.html">Dims</a> const&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic initializer-list or std::vector based owned constructor. </p>
<p>This is one of the yakl::CArray "owned" constructors. Create and allocate an owned and reference counted array object. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,1,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1);</div>
<div class="line">Array&lt;float const,4,memDevice,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,n1,n2,n3,n4);</div>
<div class="line">Array&lt;int,2,memHost,styleC&gt; arr(<span class="stringliteral">&quot;arr&quot;</span>,{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aca4fec56a13a1c98863e2e02c058c304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4fec56a13a1c98863e2e02c058c304">&#9670;&nbsp;</a></span>Array() <span class="overload">[12/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1-D non-owned constructor </p>
<p>This is one of the yakl::CArray "non-owned" constructors. Create a non-owned and non-reference-counted array object that wraps the provided data pointer. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument. When creating a non-owned array object using this form of constructor, it is up to the user to ensure that the underlying data pointer remains allocationg while it is used by this array object. Since this performs no allocations, this constructor may be called on the device, and it has very little runtime cost associated with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the allocated data being wrapped by this non-owned array object </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,2,memDevice,styleC&gt; arr_owned(<span class="stringliteral">&quot;arr_owned&quot;</span>,n1,n2); <span class="comment">// Owned Constructor</span></div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr1(<span class="stringliteral">&quot;arr1&quot;</span>,arr_owned.data(),n1,n2);</div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr2(<span class="stringliteral">&quot;arr2&quot;</span>,arr_owned.data(),{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9a1f087d0c99bf9b699cd8dfb8b4e0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1f087d0c99bf9b699cd8dfb8b4e0e2">&#9670;&nbsp;</a></span>Array() <span class="overload">[13/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2-D non-owned constructor </p>
<p>This is one of the yakl::CArray "non-owned" constructors. Create a non-owned and non-reference-counted array object that wraps the provided data pointer. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument. When creating a non-owned array object using this form of constructor, it is up to the user to ensure that the underlying data pointer remains allocationg while it is used by this array object. Since this performs no allocations, this constructor may be called on the device, and it has very little runtime cost associated with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the allocated data being wrapped by this non-owned array object </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,2,memDevice,styleC&gt; arr_owned(<span class="stringliteral">&quot;arr_owned&quot;</span>,n1,n2); <span class="comment">// Owned Constructor</span></div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr1(<span class="stringliteral">&quot;arr1&quot;</span>,arr_owned.data(),n1,n2);</div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr2(<span class="stringliteral">&quot;arr2&quot;</span>,arr_owned.data(),{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7585e6342f843b7c7aed7fc0a44828a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7585e6342f843b7c7aed7fc0a44828a7">&#9670;&nbsp;</a></span>Array() <span class="overload">[14/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>3-D non-owned constructor </p>
<p>This is one of the yakl::CArray "non-owned" constructors. Create a non-owned and non-reference-counted array object that wraps the provided data pointer. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument. When creating a non-owned array object using this form of constructor, it is up to the user to ensure that the underlying data pointer remains allocationg while it is used by this array object. Since this performs no allocations, this constructor may be called on the device, and it has very little runtime cost associated with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the allocated data being wrapped by this non-owned array object </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,2,memDevice,styleC&gt; arr_owned(<span class="stringliteral">&quot;arr_owned&quot;</span>,n1,n2); <span class="comment">// Owned Constructor</span></div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr1(<span class="stringliteral">&quot;arr1&quot;</span>,arr_owned.data(),n1,n2);</div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr2(<span class="stringliteral">&quot;arr2&quot;</span>,arr_owned.data(),{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3e363a537044ab79f44333d2bdc10467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e363a537044ab79f44333d2bdc10467">&#9670;&nbsp;</a></span>Array() <span class="overload">[15/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>4-D non-owned constructor </p>
<p>This is one of the yakl::CArray "non-owned" constructors. Create a non-owned and non-reference-counted array object that wraps the provided data pointer. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument. When creating a non-owned array object using this form of constructor, it is up to the user to ensure that the underlying data pointer remains allocationg while it is used by this array object. Since this performs no allocations, this constructor may be called on the device, and it has very little runtime cost associated with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the allocated data being wrapped by this non-owned array object </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,2,memDevice,styleC&gt; arr_owned(<span class="stringliteral">&quot;arr_owned&quot;</span>,n1,n2); <span class="comment">// Owned Constructor</span></div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr1(<span class="stringliteral">&quot;arr1&quot;</span>,arr_owned.data(),n1,n2);</div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr2(<span class="stringliteral">&quot;arr2&quot;</span>,arr_owned.data(),{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a98da60e952b9721b5c3efc8edd52c00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98da60e952b9721b5c3efc8edd52c00f">&#9670;&nbsp;</a></span>Array() <span class="overload">[16/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>5-D non-owned constructor </p>
<p>This is one of the yakl::CArray "non-owned" constructors. Create a non-owned and non-reference-counted array object that wraps the provided data pointer. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument. When creating a non-owned array object using this form of constructor, it is up to the user to ensure that the underlying data pointer remains allocationg while it is used by this array object. Since this performs no allocations, this constructor may be called on the device, and it has very little runtime cost associated with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the allocated data being wrapped by this non-owned array object </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,2,memDevice,styleC&gt; arr_owned(<span class="stringliteral">&quot;arr_owned&quot;</span>,n1,n2); <span class="comment">// Owned Constructor</span></div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr1(<span class="stringliteral">&quot;arr1&quot;</span>,arr_owned.data(),n1,n2);</div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr2(<span class="stringliteral">&quot;arr2&quot;</span>,arr_owned.data(),{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a23dfe84342f3677e31175f9c6198b7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23dfe84342f3677e31175f9c6198b7f4">&#9670;&nbsp;</a></span>Array() <span class="overload">[17/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>6-D non-owned constructor </p>
<p>This is one of the yakl::CArray "non-owned" constructors. Create a non-owned and non-reference-counted array object that wraps the provided data pointer. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument. When creating a non-owned array object using this form of constructor, it is up to the user to ensure that the underlying data pointer remains allocationg while it is used by this array object. Since this performs no allocations, this constructor may be called on the device, and it has very little runtime cost associated with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the allocated data being wrapped by this non-owned array object </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,2,memDevice,styleC&gt; arr_owned(<span class="stringliteral">&quot;arr_owned&quot;</span>,n1,n2); <span class="comment">// Owned Constructor</span></div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr1(<span class="stringliteral">&quot;arr1&quot;</span>,arr_owned.data(),n1,n2);</div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr2(<span class="stringliteral">&quot;arr2&quot;</span>,arr_owned.data(),{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acb1187bc957c8c5cc55bc715d83aa569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1187bc957c8c5cc55bc715d83aa569">&#9670;&nbsp;</a></span>Array() <span class="overload">[18/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>7-D non-owned constructor </p>
<p>This is one of the yakl::CArray "non-owned" constructors. Create a non-owned and non-reference-counted array object that wraps the provided data pointer. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument. When creating a non-owned array object using this form of constructor, it is up to the user to ensure that the underlying data pointer remains allocationg while it is used by this array object. Since this performs no allocations, this constructor may be called on the device, and it has very little runtime cost associated with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the allocated data being wrapped by this non-owned array object </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,2,memDevice,styleC&gt; arr_owned(<span class="stringliteral">&quot;arr_owned&quot;</span>,n1,n2); <span class="comment">// Owned Constructor</span></div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr1(<span class="stringliteral">&quot;arr1&quot;</span>,arr_owned.data(),n1,n2);</div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr2(<span class="stringliteral">&quot;arr2&quot;</span>,arr_owned.data(),{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="add6eaa1639c8546d2913f2f7e8541036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6eaa1639c8546d2913f2f7e8541036">&#9670;&nbsp;</a></span>Array() <span class="overload">[19/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> const&#160;</td>
          <td class="paramname"><em>d8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>8-D non-owned constructor </p>
<p>This is one of the yakl::CArray "non-owned" constructors. Create a non-owned and non-reference-counted array object that wraps the provided data pointer. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument. When creating a non-owned array object using this form of constructor, it is up to the user to ensure that the underlying data pointer remains allocationg while it is used by this array object. Since this performs no allocations, this constructor may be called on the device, and it has very little runtime cost associated with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the allocated data being wrapped by this non-owned array object </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,2,memDevice,styleC&gt; arr_owned(<span class="stringliteral">&quot;arr_owned&quot;</span>,n1,n2); <span class="comment">// Owned Constructor</span></div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr1(<span class="stringliteral">&quot;arr1&quot;</span>,arr_owned.data(),n1,n2);</div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr2(<span class="stringliteral">&quot;arr2&quot;</span>,arr_owned.data(),{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3d34ff7c19edb7acc89c378fafc61c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d34ff7c19edb7acc89c378fafc61c9f">&#9670;&nbsp;</a></span>Array() <span class="overload">[20/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Dims.html">Dims</a> const&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic initializer-list or std::vector based owned constructor. </p>
<p>This is one of the yakl::CArray "non-owned" constructors. Create a non-owned and non-reference-counted array object that wraps the provided data pointer. For C-style array objects, the right-most index varies the fastest. Constructor must match the rank template argument. When creating a non-owned array object using this form of constructor, it is up to the user to ensure that the underlying data pointer remains allocationg while it is used by this array object. Since this performs no allocations, this constructor may be called on the device, and it has very little runtime cost associated with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>String label for this array. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the allocated data being wrapped by this non-owned array object </td></tr>
    <tr><td class="paramname">d[0-7]</td><td>Size of the respective dimension. </td></tr>
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions sizes. Must match the array rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Exmaple usage: </p><div class="fragment"><div class="line">Array&lt;float,2,memDevice,styleC&gt; arr_owned(<span class="stringliteral">&quot;arr_owned&quot;</span>,n1,n2); <span class="comment">// Owned Constructor</span></div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr1(<span class="stringliteral">&quot;arr1&quot;</span>,arr_owned.data(),n1,n2);</div>
<div class="line">Array&lt;float,2,memDevice,styleC&gt; arr2(<span class="stringliteral">&quot;arr2&quot;</span>,arr_owned.data(),{n1,n2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af461f4f73f3ea101ad2c987292922332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af461f4f73f3ea101ad2c987292922332">&#9670;&nbsp;</a></span>Array() <span class="overload">[21/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; <a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#af2418211857fefc3acc91e34027c86ff">non_const_value_type</a>, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy metadata, share data pointer; if owned, increment reference counter. No deep copy. </p>

</div>
</div>
<a id="af5b6933742f1de190087027336b25623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b6933742f1de190087027336b25623">&#9670;&nbsp;</a></span>Array() <span class="overload">[22/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; <a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a7fee476637337e1e949af60de2b0ffe5">const_value_type</a>, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy metadata, share data pointer; if owned, increment reference counter. No deep copy. </p>

</div>
</div>
<a id="a6955263a2b4ff3bfeedffdc8fcff245f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6955263a2b4ff3bfeedffdc8fcff245f">&#9670;&nbsp;</a></span>Array() <span class="overload">[23/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move metadata and data pointer. No deep copy. </p>

</div>
</div>
<a id="acc9c489c3fb8078a791f06ab3268603b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9c489c3fb8078a791f06ab3268603b">&#9670;&nbsp;</a></span>~Array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::~<a class="el" href="classyakl_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If owned, decrement reference counter, and deallocate data when it reaches zero. If non-owned, does nothing. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4af3e12b6800b654d3461920bcf068f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af3e12b6800b654d3461920bcf068f6">&#9670;&nbsp;</a></span>collapse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,1,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::collapse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collapse this array into a 1-D array. </p>
<p>Returns an array object that shares the data pointer of this array object but has only one dimension, with all of this array object's dimensions collapsed into a single dimension. This is a fast operation. No allocations are performed, and no underlying data is allocated. If this is performed on the host, then the returned array is owned, and the data pointer's reference counter is incremented. This means you're guaranteed the data pointer is valid throughout the use of the returned array object. If this is performed on the device, then the returned array is non-owned. Be careful doing this in the innermost loop, even on the host, though, because it is still copying array metadata, and you may notice the extra cost. Example usage: <code>auto new_arr_1d = arr.collapse();</code> </p>

</div>
</div>
<a id="a333fb42a173963bd6728bdcd06197aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333fb42a173963bd6728bdcd06197aaf">&#9670;&nbsp;</a></span>createDeviceCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;class TLOC  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt;TLOC,rank,<a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce">memDevice</a>,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::createDeviceCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[DEEP_COPY] Create a copy of this array in <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> space </p>
<p>Create and allocate a <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> array object of the same type, rank, dimensions, and style. Then deep copy the data from this array object to the array object returned by this function. This is a slow routine. It both allocates and deep copies the underlying data.</p>
<p>Even if the current array is <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a>, this will still allocate and copy to a new object.</p>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated array of the same type, rank, and style as this one in <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> space with data copied from this array object. </dd></dl>

</div>
</div>
<a id="ab68f2ef882c1cd4374ab960290782b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68f2ef882c1cd4374ab960290782b5d">&#9670;&nbsp;</a></span>createDeviceObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;class TLOC  = typename std::remove_cv&lt;T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt;typename std::remove_cv&lt;TLOC&gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a>,rank,<a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce">memDevice</a>,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::createDeviceObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and allocate a <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> array object of the same type, rank, dimensions, and style. </p>
<p>This is the same as <a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a333fb42a173963bd6728bdcd06197aaf" title="[DEEP_COPY] Create a copy of this array in yakl::memDevice space">createDeviceCopy()</a> but without the data deep copy portion. This is a fairly fast routine <b>if the YAKL pool allocator is enabled</b>; otherwise, it may be slow. NOTE: This does not deep copy data. It merely creates and allocates a new array object and returns it. NOTE: The returned array will have a <b>non-<code>const</code></b> underlying type. </p>

</div>
</div>
<a id="a87232915db9a00c55ffc1cbdc2be9927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87232915db9a00c55ffc1cbdc2be9927">&#9670;&nbsp;</a></span>createHostCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;class TLOC  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt;TLOC,rank,<a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98">memHost</a>,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::createHostCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[DEEP_COPY] Create a copy of this array in <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> space </p>
<p>Create and allocate a <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> array object of the same type, rank, dimensions, and style. Then deep copy the data from this array object to the array object returned by this function. This is a slow routine. It both allocates and deep copies the underlying data.</p>
<p>Even if the current array is <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a>, this will still allocate and copy to a new object.</p>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated array of the same type, rank, and style as this one in <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> space with data copied from this array object. </dd></dl>

</div>
</div>
<a id="ac0e59efa937ef10e35bdaf87a80d0011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e59efa937ef10e35bdaf87a80d0011">&#9670;&nbsp;</a></span>createHostObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;class TLOC  = typename std::remove_cv&lt;T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt;typename std::remove_cv&lt;TLOC&gt;::<a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#ad139bae81491baf46c8e9879867f3487">type</a>,rank,<a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98">memHost</a>,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::createHostObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and allocate a <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> array object of the same type, rank, dimensions, and style. </p>
<p>This is the same as <a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a87232915db9a00c55ffc1cbdc2be9927" title="[DEEP_COPY] Create a copy of this array in yakl::memHost space">createHostCopy()</a> but without the data deep copy portion. This may be slow since host objects do not use the YAKL pool allocator. NOTE: This does not deep copy data. It merely creates and allocates a new array object and returns it. NOTE: The returned array will have a <b>non-<code>const</code></b> underlying type. </p>

</div>
</div>
<a id="a35520392cca515a1cdfbaf189a7e2903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35520392cca515a1cdfbaf189a7e2903">&#9670;&nbsp;</a></span>extent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::extent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the extent of the requested dimension of this array. </p>
<p>The parameter <code>dim</code> is expected to be a zero-based index. </p>

</div>
</div>
<a id="adf268893531899a1cbaab7db0218edf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf268893531899a1cbaab7db0218edf3">&#9670;&nbsp;</a></span>get_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt;<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>,1,rank&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::get_dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dimensions of this array as a <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a> object. </p>
<p>You should use zero-based indexing on the returned SArray object. </p>

</div>
</div>
<a id="ae9336df9b02fdc612af2cb8e0dc4b409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9336df9b02fdc612af2cb8e0dc4b409">&#9670;&nbsp;</a></span>get_lbounds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt;<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>,1,rank&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::get_lbounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lower bound of each dimension of this array (which are always all zero) as a <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a> object. </p>
<p>You should use zero-based indexing on the returned <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a> object. </p>

</div>
</div>
<a id="a47342fd163789a54fcce61e03a4e1a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47342fd163789a54fcce61e03a4e1a3a">&#9670;&nbsp;</a></span>get_ubounds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt;<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>,1,rank&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::get_ubounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the upper bound of each dimension of this array as a <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a> object. </p>
<p>You should use zero-based indexing on the returned <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a> object. </p>

</div>
</div>
<a id="aca05dc9bd3def425e479437fb19e80b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca05dc9bd3def425e479437fb19e80b6">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T&amp; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return reference to element at the requested index (1-D) </p>
<p>Return a reference to the element at the requested index. Number of indices must match the number of dimensions in this array, <code>N</code>. The array object must already be allocated. For index checking, please define the <code>YAKL_DEBUG</code> CPP macro. Use zero-based indexing with the right-most value varying the fastest (row-major ordering). </p>

</div>
</div>
<a id="a5b3005e09d2fb85d7b063cab02240a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3005e09d2fb85d7b063cab02240a3e">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T&amp; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return reference to element at the requested indices (2-D) </p>
<p>Return a reference to the element at the requested index. Number of indices must match the number of dimensions in this array, <code>N</code>. The array object must already be allocated. For index checking, please define the <code>YAKL_DEBUG</code> CPP macro. Use zero-based indexing with the right-most value varying the fastest (row-major ordering). </p>

</div>
</div>
<a id="ada7cad1389b17dfb822bd0805e13a736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7cad1389b17dfb822bd0805e13a736">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T&amp; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return reference to element at the requested indices (3-D) </p>
<p>Return a reference to the element at the requested index. Number of indices must match the number of dimensions in this array, <code>N</code>. The array object must already be allocated. For index checking, please define the <code>YAKL_DEBUG</code> CPP macro. Use zero-based indexing with the right-most value varying the fastest (row-major ordering). </p>

</div>
</div>
<a id="ab2c4120190ec4bbb66d57e1a91c65ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c4120190ec4bbb66d57e1a91c65ec1">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T&amp; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return reference to element at the requested indices (4-D) </p>
<p>Return a reference to the element at the requested index. Number of indices must match the number of dimensions in this array, <code>N</code>. The array object must already be allocated. For index checking, please define the <code>YAKL_DEBUG</code> CPP macro. Use zero-based indexing with the right-most value varying the fastest (row-major ordering). </p>

</div>
</div>
<a id="ac71332c2aaead8c758194e236d9a4fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71332c2aaead8c758194e236d9a4fc5">&#9670;&nbsp;</a></span>operator()() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T&amp; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return reference to element at the requested indices (5-D) </p>
<p>Return a reference to the element at the requested index. Number of indices must match the number of dimensions in this array, <code>N</code>. The array object must already be allocated. For index checking, please define the <code>YAKL_DEBUG</code> CPP macro. Use zero-based indexing with the right-most value varying the fastest (row-major ordering). </p>

</div>
</div>
<a id="a96fd635d3ff308e5150c03c48882081f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fd635d3ff308e5150c03c48882081f">&#9670;&nbsp;</a></span>operator()() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T&amp; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return reference to element at the requested indices (6-D) </p>
<p>Return a reference to the element at the requested index. Number of indices must match the number of dimensions in this array, <code>N</code>. The array object must already be allocated. For index checking, please define the <code>YAKL_DEBUG</code> CPP macro. Use zero-based indexing with the right-most value varying the fastest (row-major ordering). </p>

</div>
</div>
<a id="a9c17fbb79a84b25e3e4f3cd43e3928c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c17fbb79a84b25e3e4f3cd43e3928c5">&#9670;&nbsp;</a></span>operator()() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T&amp; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return reference to element at the requested indices (7-D) </p>
<p>Return a reference to the element at the requested index. Number of indices must match the number of dimensions in this array, <code>N</code>. The array object must already be allocated. For index checking, please define the <code>YAKL_DEBUG</code> CPP macro. Use zero-based indexing with the right-most value varying the fastest (row-major ordering). </p>

</div>
</div>
<a id="a20a3d7ceeabc81decbc982daa9fdb846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a3d7ceeabc81decbc982daa9fdb846">&#9670;&nbsp;</a></span>operator()() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T&amp; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return reference to element at the requested indices (8-D) </p>
<p>Return a reference to the element at the requested index. Number of indices must match the number of dimensions in this array, <code>N</code>. The array object must already be allocated. For index checking, please define the <code>YAKL_DEBUG</code> CPP macro. Use zero-based indexing with the right-most value varying the fastest (row-major ordering). </p>

</div>
</div>
<a id="afc6f6fd8e7717d5fd1960c57ea5c0083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6f6fd8e7717d5fd1960c57ea5c0083">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&amp; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move metadata and data pointer. No deep copy. </p>

</div>
</div>
<a id="aecf06bdd76d6ab9017b7f7a6375acba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf06bdd76d6ab9017b7f7a6375acba3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&amp; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; <a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#a7fee476637337e1e949af60de2b0ffe5">const_value_type</a>, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy metadata, share data pointer; if owned, increment reference counter. No deep copy. </p>

</div>
</div>
<a id="a62a8cb42e0c7198fe61be37984d17101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a8cb42e0c7198fe61be37984d17101">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&amp; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; <a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#af2418211857fefc3acc91e34027c86ff">non_const_value_type</a>, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy metadata, share data pointer; if owned, increment reference counter. No deep copy. </p>

</div>
</div>
<a id="a2ac315417bc8e21bd35a4f365bb2adf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac315417bc8e21bd35a4f365bb2adf4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyakl_1_1Array.html">Array</a>&amp; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">TLOC const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[ASYNCHRONOUS] Assign a scalar arithmetic value to all entries in this array object </p>

</div>
</div>
<a id="a93e6092733c7d4bea64f455361a2d5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6092733c7d4bea64f455361a2d5d6">&#9670;&nbsp;</a></span>reshape() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,N,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Dims.html">Dims</a> const &amp;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape array using initializer list or std::vector indices. </p>
<p>Returns an array object that shares the data pointer of this array object but has different dimensions, specified by the passed <a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object (or initializer list of integers). The total number of array elements must remain the same, the memory space must remain the same, the style must remain the same, and the array must already be allocated. This is a fast operation. No allocations are performed, and no underlying data is allocated. If this is performed on the host, then the returned array is owned, and the data pointer's reference counter is incremented. This means you're guaranteed the data pointer is valid throughout the use of the returned array object. If this is performed on the device, then the returned array is non-owned. Be careful doing this in the innermost loop, even on the host, though, because it is still copying array metadata, and you may notice the extra cost.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> new_arr = arr.reshape({nx,ny});</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(nz,ny,nx);</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(n);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions of the new array object that shares this object's data pointer </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>dimensions of the newly reshaped array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cfedf0478cdcd4a52538784832ed340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfedf0478cdcd4a52538784832ed340">&#9670;&nbsp;</a></span>reshape() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,1,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape array into a 1-D array. </p>
<p>Returns an array object that shares the data pointer of this array object but has different dimensions, specified by the passed <a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object (or initializer list of integers). The total number of array elements must remain the same, the memory space must remain the same, the style must remain the same, and the array must already be allocated. This is a fast operation. No allocations are performed, and no underlying data is allocated. If this is performed on the host, then the returned array is owned, and the data pointer's reference counter is incremented. This means you're guaranteed the data pointer is valid throughout the use of the returned array object. If this is performed on the device, then the returned array is non-owned. Be careful doing this in the innermost loop, even on the host, though, because it is still copying array metadata, and you may notice the extra cost.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> new_arr = arr.reshape({nx,ny});</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(nz,ny,nx);</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(n);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions of the new array object that shares this object's data pointer </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>dimensions of the newly reshaped array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5c1110515f50978d4b27003aeaa7380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c1110515f50978d4b27003aeaa7380">&#9670;&nbsp;</a></span>reshape() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,2,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape array into a 2-D array. </p>
<p>Returns an array object that shares the data pointer of this array object but has different dimensions, specified by the passed <a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object (or initializer list of integers). The total number of array elements must remain the same, the memory space must remain the same, the style must remain the same, and the array must already be allocated. This is a fast operation. No allocations are performed, and no underlying data is allocated. If this is performed on the host, then the returned array is owned, and the data pointer's reference counter is incremented. This means you're guaranteed the data pointer is valid throughout the use of the returned array object. If this is performed on the device, then the returned array is non-owned. Be careful doing this in the innermost loop, even on the host, though, because it is still copying array metadata, and you may notice the extra cost.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> new_arr = arr.reshape({nx,ny});</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(nz,ny,nx);</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(n);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions of the new array object that shares this object's data pointer </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>dimensions of the newly reshaped array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc6116e8055009ca9f199fce739af527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6116e8055009ca9f199fce739af527">&#9670;&nbsp;</a></span>reshape() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,3,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape array into a 3-D array. </p>
<p>Returns an array object that shares the data pointer of this array object but has different dimensions, specified by the passed <a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object (or initializer list of integers). The total number of array elements must remain the same, the memory space must remain the same, the style must remain the same, and the array must already be allocated. This is a fast operation. No allocations are performed, and no underlying data is allocated. If this is performed on the host, then the returned array is owned, and the data pointer's reference counter is incremented. This means you're guaranteed the data pointer is valid throughout the use of the returned array object. If this is performed on the device, then the returned array is non-owned. Be careful doing this in the innermost loop, even on the host, though, because it is still copying array metadata, and you may notice the extra cost.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> new_arr = arr.reshape({nx,ny});</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(nz,ny,nx);</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(n);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions of the new array object that shares this object's data pointer </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>dimensions of the newly reshaped array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24b1eac9efc94c888a54dd23a9408242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b1eac9efc94c888a54dd23a9408242">&#9670;&nbsp;</a></span>reshape() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,4,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape array into a 4-D array. </p>
<p>Returns an array object that shares the data pointer of this array object but has different dimensions, specified by the passed <a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object (or initializer list of integers). The total number of array elements must remain the same, the memory space must remain the same, the style must remain the same, and the array must already be allocated. This is a fast operation. No allocations are performed, and no underlying data is allocated. If this is performed on the host, then the returned array is owned, and the data pointer's reference counter is incremented. This means you're guaranteed the data pointer is valid throughout the use of the returned array object. If this is performed on the device, then the returned array is non-owned. Be careful doing this in the innermost loop, even on the host, though, because it is still copying array metadata, and you may notice the extra cost.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> new_arr = arr.reshape({nx,ny});</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(nz,ny,nx);</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(n);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions of the new array object that shares this object's data pointer </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>dimensions of the newly reshaped array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0a88c2253ae379e75540da22b7e3fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a88c2253ae379e75540da22b7e3fb1">&#9670;&nbsp;</a></span>reshape() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,5,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape array into a 5-D array. </p>
<p>Returns an array object that shares the data pointer of this array object but has different dimensions, specified by the passed <a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object (or initializer list of integers). The total number of array elements must remain the same, the memory space must remain the same, the style must remain the same, and the array must already be allocated. This is a fast operation. No allocations are performed, and no underlying data is allocated. If this is performed on the host, then the returned array is owned, and the data pointer's reference counter is incremented. This means you're guaranteed the data pointer is valid throughout the use of the returned array object. If this is performed on the device, then the returned array is non-owned. Be careful doing this in the innermost loop, even on the host, though, because it is still copying array metadata, and you may notice the extra cost.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> new_arr = arr.reshape({nx,ny});</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(nz,ny,nx);</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(n);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions of the new array object that shares this object's data pointer </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>dimensions of the newly reshaped array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cfe677d46c6f8c1d5ddea2283961607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfe677d46c6f8c1d5ddea2283961607">&#9670;&nbsp;</a></span>reshape() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,6,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape array into a 6-D array. </p>
<p>Returns an array object that shares the data pointer of this array object but has different dimensions, specified by the passed <a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object (or initializer list of integers). The total number of array elements must remain the same, the memory space must remain the same, the style must remain the same, and the array must already be allocated. This is a fast operation. No allocations are performed, and no underlying data is allocated. If this is performed on the host, then the returned array is owned, and the data pointer's reference counter is incremented. This means you're guaranteed the data pointer is valid throughout the use of the returned array object. If this is performed on the device, then the returned array is non-owned. Be careful doing this in the innermost loop, even on the host, though, because it is still copying array metadata, and you may notice the extra cost.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> new_arr = arr.reshape({nx,ny});</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(nz,ny,nx);</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(n);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions of the new array object that shares this object's data pointer </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>dimensions of the newly reshaped array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25c980edef0d027de290c3872ff57545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c980edef0d027de290c3872ff57545">&#9670;&nbsp;</a></span>reshape() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,7,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape array into a 7-D array. </p>
<p>Returns an array object that shares the data pointer of this array object but has different dimensions, specified by the passed <a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object (or initializer list of integers). The total number of array elements must remain the same, the memory space must remain the same, the style must remain the same, and the array must already be allocated. This is a fast operation. No allocations are performed, and no underlying data is allocated. If this is performed on the host, then the returned array is owned, and the data pointer's reference counter is incremented. This means you're guaranteed the data pointer is valid throughout the use of the returned array object. If this is performed on the device, then the returned array is non-owned. Be careful doing this in the innermost loop, even on the host, though, because it is still copying array metadata, and you may notice the extra cost.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> new_arr = arr.reshape({nx,ny});</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(nz,ny,nx);</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(n);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions of the new array object that shares this object's data pointer </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>dimensions of the newly reshaped array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab0b479e4d54ed0981c435683f06ee74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0b479e4d54ed0981c435683f06ee74">&#9670;&nbsp;</a></span>reshape() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,8,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>i7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape array into a 8-D array. </p>
<p>Returns an array object that shares the data pointer of this array object but has different dimensions, specified by the passed <a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object (or initializer list of integers). The total number of array elements must remain the same, the memory space must remain the same, the style must remain the same, and the array must already be allocated. This is a fast operation. No allocations are performed, and no underlying data is allocated. If this is performed on the host, then the returned array is owned, and the data pointer's reference counter is incremented. This means you're guaranteed the data pointer is valid throughout the use of the returned array object. If this is performed on the device, then the returned array is non-owned. Be careful doing this in the innermost loop, even on the host, though, because it is still copying array metadata, and you may notice the extra cost.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> new_arr = arr.reshape({nx,ny});</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(nz,ny,nx);</div>
<div class="line"><span class="keyword">auto</span> new_arr = arr.reshape(n);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object containing the dimensions of the new array object that shares this object's data pointer </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>dimensions of the newly reshaped array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac49af0beacfd0fa88bf58255aa6d4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac49af0beacfd0fa88bf58255aa6d4c2">&#9670;&nbsp;</a></span>slice() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,N,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Dims.html">Dims</a> const &amp;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice using initializer list or std::vector indices. </p>
<p>Returns an array object with the requested slice. Slices must be contiguous, and only whole dimensions may be sliced. Please use <a class="el" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853" title="This is just a convenience syntax for slicing yakl::Array objects to make it clear in the user level ...">yakl::COLON</a> to denote dimensions being sliced to make this more clear. The template parameter specifies the number of dimensions in the resulting sliced array object. The array object being sliced must be already allocated, and the number of sliced dimensions must not exceed the rank of the array being sliced. If slicing is performed on the host, then the returned array object is owned and reference counted, guaranteeing the underling data remains valid while the returned slice is used. If slicing is performed on the device, a non-owned array object is returned, though this rarely if ever presents an issue on the device.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;2&gt;({k,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>});</div>
<div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;1&gt;(i5,i4,i3,i2,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object specifying the indices at which the slice should occur as well as the dimensions that should be sliced. </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>Index of the array slice. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad44195e77991a02eb12b04816b87206b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44195e77991a02eb12b04816b87206b">&#9670;&nbsp;</a></span>slice() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,N,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 1-D array. </p>
<p>Returns an array object with the requested slice. Slices must be contiguous, and only whole dimensions may be sliced. Please use <a class="el" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853" title="This is just a convenience syntax for slicing yakl::Array objects to make it clear in the user level ...">yakl::COLON</a> to denote dimensions being sliced to make this more clear. The template parameter specifies the number of dimensions in the resulting sliced array object. The array object being sliced must be already allocated, and the number of sliced dimensions must not exceed the rank of the array being sliced. If slicing is performed on the host, then the returned array object is owned and reference counted, guaranteeing the underling data remains valid while the returned slice is used. If slicing is performed on the device, a non-owned array object is returned, though this rarely if ever presents an issue on the device.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;2&gt;({k,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>});</div>
<div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;1&gt;(i5,i4,i3,i2,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object specifying the indices at which the slice should occur as well as the dimensions that should be sliced. </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>Index of the array slice. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a590905f2d1a58717b4851b5f0b4e2602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590905f2d1a58717b4851b5f0b4e2602">&#9670;&nbsp;</a></span>slice() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,N,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 2-D array. </p>
<p>Returns an array object with the requested slice. Slices must be contiguous, and only whole dimensions may be sliced. Please use <a class="el" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853" title="This is just a convenience syntax for slicing yakl::Array objects to make it clear in the user level ...">yakl::COLON</a> to denote dimensions being sliced to make this more clear. The template parameter specifies the number of dimensions in the resulting sliced array object. The array object being sliced must be already allocated, and the number of sliced dimensions must not exceed the rank of the array being sliced. If slicing is performed on the host, then the returned array object is owned and reference counted, guaranteeing the underling data remains valid while the returned slice is used. If slicing is performed on the device, a non-owned array object is returned, though this rarely if ever presents an issue on the device.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;2&gt;({k,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>});</div>
<div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;1&gt;(i5,i4,i3,i2,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object specifying the indices at which the slice should occur as well as the dimensions that should be sliced. </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>Index of the array slice. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e49c35a4beb93f941db93c61db206fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e49c35a4beb93f941db93c61db206fb">&#9670;&nbsp;</a></span>slice() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,N,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 3-D array. </p>
<p>Returns an array object with the requested slice. Slices must be contiguous, and only whole dimensions may be sliced. Please use <a class="el" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853" title="This is just a convenience syntax for slicing yakl::Array objects to make it clear in the user level ...">yakl::COLON</a> to denote dimensions being sliced to make this more clear. The template parameter specifies the number of dimensions in the resulting sliced array object. The array object being sliced must be already allocated, and the number of sliced dimensions must not exceed the rank of the array being sliced. If slicing is performed on the host, then the returned array object is owned and reference counted, guaranteeing the underling data remains valid while the returned slice is used. If slicing is performed on the device, a non-owned array object is returned, though this rarely if ever presents an issue on the device.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;2&gt;({k,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>});</div>
<div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;1&gt;(i5,i4,i3,i2,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object specifying the indices at which the slice should occur as well as the dimensions that should be sliced. </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>Index of the array slice. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74e6861e4cc2b3ce235e7cb5e460cbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e6861e4cc2b3ce235e7cb5e460cbba">&#9670;&nbsp;</a></span>slice() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,N,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 4-D array. </p>
<p>Returns an array object with the requested slice. Slices must be contiguous, and only whole dimensions may be sliced. Please use <a class="el" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853" title="This is just a convenience syntax for slicing yakl::Array objects to make it clear in the user level ...">yakl::COLON</a> to denote dimensions being sliced to make this more clear. The template parameter specifies the number of dimensions in the resulting sliced array object. The array object being sliced must be already allocated, and the number of sliced dimensions must not exceed the rank of the array being sliced. If slicing is performed on the host, then the returned array object is owned and reference counted, guaranteeing the underling data remains valid while the returned slice is used. If slicing is performed on the device, a non-owned array object is returned, though this rarely if ever presents an issue on the device.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;2&gt;({k,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>});</div>
<div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;1&gt;(i5,i4,i3,i2,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object specifying the indices at which the slice should occur as well as the dimensions that should be sliced. </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>Index of the array slice. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a999d6dca55e1cf9381508e3c35a0b07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999d6dca55e1cf9381508e3c35a0b07b">&#9670;&nbsp;</a></span>slice() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,N,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 5-D array. </p>
<p>Returns an array object with the requested slice. Slices must be contiguous, and only whole dimensions may be sliced. Please use <a class="el" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853" title="This is just a convenience syntax for slicing yakl::Array objects to make it clear in the user level ...">yakl::COLON</a> to denote dimensions being sliced to make this more clear. The template parameter specifies the number of dimensions in the resulting sliced array object. The array object being sliced must be already allocated, and the number of sliced dimensions must not exceed the rank of the array being sliced. If slicing is performed on the host, then the returned array object is owned and reference counted, guaranteeing the underling data remains valid while the returned slice is used. If slicing is performed on the device, a non-owned array object is returned, though this rarely if ever presents an issue on the device.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;2&gt;({k,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>});</div>
<div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;1&gt;(i5,i4,i3,i2,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object specifying the indices at which the slice should occur as well as the dimensions that should be sliced. </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>Index of the array slice. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cae9038b7235e62b4009a74980c20d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cae9038b7235e62b4009a74980c20d9">&#9670;&nbsp;</a></span>slice() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,N,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 6-D array. </p>
<p>Returns an array object with the requested slice. Slices must be contiguous, and only whole dimensions may be sliced. Please use <a class="el" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853" title="This is just a convenience syntax for slicing yakl::Array objects to make it clear in the user level ...">yakl::COLON</a> to denote dimensions being sliced to make this more clear. The template parameter specifies the number of dimensions in the resulting sliced array object. The array object being sliced must be already allocated, and the number of sliced dimensions must not exceed the rank of the array being sliced. If slicing is performed on the host, then the returned array object is owned and reference counted, guaranteeing the underling data remains valid while the returned slice is used. If slicing is performed on the device, a non-owned array object is returned, though this rarely if ever presents an issue on the device.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;2&gt;({k,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>});</div>
<div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;1&gt;(i5,i4,i3,i2,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object specifying the indices at which the slice should occur as well as the dimensions that should be sliced. </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>Index of the array slice. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28afdaf25967fe192a895c3bc461fe3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28afdaf25967fe192a895c3bc461fe3d">&#9670;&nbsp;</a></span>slice() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,N,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 7-D array. </p>
<p>Returns an array object with the requested slice. Slices must be contiguous, and only whole dimensions may be sliced. Please use <a class="el" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853" title="This is just a convenience syntax for slicing yakl::Array objects to make it clear in the user level ...">yakl::COLON</a> to denote dimensions being sliced to make this more clear. The template parameter specifies the number of dimensions in the resulting sliced array object. The array object being sliced must be already allocated, and the number of sliced dimensions must not exceed the rank of the array being sliced. If slicing is performed on the host, then the returned array object is owned and reference counted, guaranteeing the underling data remains valid while the returned slice is used. If slicing is performed on the device, a non-owned array object is returned, though this rarely if ever presents an issue on the device.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;2&gt;({k,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>});</div>
<div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;1&gt;(i5,i4,i3,i2,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object specifying the indices at which the slice should occur as well as the dimensions that should be sliced. </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>Index of the array slice. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9fa982e94e4a11efddba58c700c8fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fa982e94e4a11efddba58c700c8fbb">&#9670;&nbsp;</a></span>slice() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Array.html">Array</a>&lt;T,N,myMem,<a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a>&gt; <a class="el" href="classyakl_1_1Array.html">yakl::Array</a>&lt; T, rank, myMem, <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> slice of 8-D array. </p>
<p>Returns an array object with the requested slice. Slices must be contiguous, and only whole dimensions may be sliced. Please use <a class="el" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853" title="This is just a convenience syntax for slicing yakl::Array objects to make it clear in the user level ...">yakl::COLON</a> to denote dimensions being sliced to make this more clear. The template parameter specifies the number of dimensions in the resulting sliced array object. The array object being sliced must be already allocated, and the number of sliced dimensions must not exceed the rank of the array being sliced. If slicing is performed on the host, then the returned array object is owned and reference counted, guaranteeing the underling data remains valid while the returned slice is used. If slicing is performed on the device, a non-owned array object is returned, though this rarely if ever presents an issue on the device.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;2&gt;({k,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>});</div>
<div class="line"><span class="keyword">auto</span> myslice = arr.slice&lt;1&gt;(i5,i4,i3,i2,<a class="code" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td><a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects.">yakl::Dims</a> object specifying the indices at which the slice should occur as well as the dimensions that should be sliced. </td></tr>
    <tr><td class="paramname">i[0-7]</td><td>Index of the array slice. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>YAKL/src/<a class="el" href="YAKL__CArray_8h_source.html">YAKL_CArray.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="anamespaceyakl_html_a9af6abbeffe50631799da258050ff853"><div class="ttname"><a href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">yakl::COLON</a></div><div class="ttdeci">constexpr int COLON</div><div class="ttdoc">This is just a convenience syntax for slicing yakl::Array objects to make it clear in the user level ...</div><div class="ttdef"><b>Definition:</b> YAKL_Array.h:27</div></div>
<div class="ttc" id="aclassyakl_1_1Array_html"><div class="ttname"><a href="classyakl_1_1Array.html">yakl::Array</a></div><div class="ttdoc">This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...</div><div class="ttdef"><b>Definition:</b> YAKL_Array.h:39</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
