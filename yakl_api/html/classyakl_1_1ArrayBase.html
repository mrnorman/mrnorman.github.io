<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YAKL: yakl::ArrayBase&lt; T, rank, myMem, myStyle &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YAKL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceyakl.html">yakl</a></li><li class="navelem"><a class="el" href="classyakl_1_1ArrayBase.html">ArrayBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classyakl_1_1ArrayBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">yakl::ArrayBase&lt; T, rank, myMem, myStyle &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements functionality common to both <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d" title="Template parameter for yakl::Array that specifies it should follow C-style behavior.">yakl::styleC</a> and <a class="el" href="namespaceyakl.html#a48029004bb42b7cc63974ca0433af63a" title="Template parameter for yakl::Array that specifies it should follow Fortran-style behavior.">yakl::styleFortran</a> <code><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a></code> objects.  
 <a href="classyakl_1_1ArrayBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="YAKL__ArrayBase_8h_source.html">YAKL_ArrayBase.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for yakl::ArrayBase&lt; T, rank, myMem, myStyle &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classyakl_1_1ArrayBase__coll__graph.png" border="0" usemap="#yakl_1_1ArrayBase_3_01T_00_01rank_00_01myMem_00_01myStyle_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="yakl_1_1ArrayBase_3_01T_00_01rank_00_01myMem_00_01myStyle_01_4_coll__map" id="yakl_1_1ArrayBase_3_01T_00_01rank_00_01myMem_00_01myStyle_01_4_coll__map">
<area shape="rect" title="This class implements functionality common to both yakl::styleC and yakl::styleFortran Array objects." alt="" coords="5,124,200,165"/>
<area shape="rect" title=" " alt="" coords="13,5,192,61"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab93d72c9e827137a972b928af87a9e3f"><td class="memItemLeft" align="right" valign="top">typedef std::add_const&lt; <a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a> &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#ab93d72c9e827137a972b928af87a9e3f">const_value_type</a></td></tr>
<tr class="memdesc:ab93d72c9e827137a972b928af87a9e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type <code>T</code> with <code>const</code> added to it (if the original type has <code>volatile</code>, then so will this type.  <a href="classyakl_1_1ArrayBase.html#ab93d72c9e827137a972b928af87a9e3f">More...</a><br /></td></tr>
<tr class="separator:ab93d72c9e827137a972b928af87a9e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4212fa32ba3a9a87a5a4fde69d4a2f0"><td class="memItemLeft" align="right" valign="top">typedef std::remove_const&lt; <a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a> &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#ae4212fa32ba3a9a87a5a4fde69d4a2f0">non_const_value_type</a></td></tr>
<tr class="memdesc:ae4212fa32ba3a9a87a5a4fde69d4a2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type <code>T</code> with <code>const</code> removed from it (if the original type has <code>volatile</code>, then so will this type.  <a href="classyakl_1_1ArrayBase.html#ae4212fa32ba3a9a87a5a4fde69d4a2f0">More...</a><br /></td></tr>
<tr class="separator:ae4212fa32ba3a9a87a5a4fde69d4a2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c8aec2f010ccfe2a8db0c760b7bb71"><td class="memItemLeft" align="right" valign="top">typedef std::remove_cv&lt; T &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a></td></tr>
<tr class="memdesc:a99c8aec2f010ccfe2a8db0c760b7bb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type <code>T</code> without <code>const</code> and <code>volatile</code> modifiers.  <a href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">More...</a><br /></td></tr>
<tr class="separator:a99c8aec2f010ccfe2a8db0c760b7bb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dd11d776c327372882831924e08461"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a16dd11d776c327372882831924e08461">value_type</a></td></tr>
<tr class="memdesc:a16dd11d776c327372882831924e08461"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type <code>T</code> exactly as it was defined upon array object creation.  <a href="classyakl_1_1ArrayBase.html#a16dd11d776c327372882831924e08461">More...</a><br /></td></tr>
<tr class="separator:a16dd11d776c327372882831924e08461"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a04b6387ea5d7a49812a37a1398df9a33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a04b6387ea5d7a49812a37a1398df9a33">add_stream_dependencies</a> (std::vector&lt; <a class="el" href="structyakl_1_1Stream.html">Stream</a> &gt; streams)</td></tr>
<tr class="memdesc:a04b6387ea5d7a49812a37a1398df9a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a dependencies on the multiple streams at one time.  <a href="classyakl_1_1ArrayBase.html#a04b6387ea5d7a49812a37a1398df9a33">More...</a><br /></td></tr>
<tr class="separator:a04b6387ea5d7a49812a37a1398df9a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063c0eb1c0523ebd00abad99f5a9bf85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a063c0eb1c0523ebd00abad99f5a9bf85">add_stream_dependency</a> (<a class="el" href="structyakl_1_1Stream.html">Stream</a> stream)</td></tr>
<tr class="memdesc:a063c0eb1c0523ebd00abad99f5a9bf85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a dependency on the passed stream.  <a href="classyakl_1_1ArrayBase.html#a063c0eb1c0523ebd00abad99f5a9bf85">More...</a><br /></td></tr>
<tr class="separator:a063c0eb1c0523ebd00abad99f5a9bf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143863763b2e52aa5f9e9817ce9d5320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a143863763b2e52aa5f9e9817ce9d5320">data</a> () const</td></tr>
<tr class="memdesc:a143863763b2e52aa5f9e9817ce9d5320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw data pointer of this array object.  <a href="classyakl_1_1ArrayBase.html#a143863763b2e52aa5f9e9817ce9d5320">More...</a><br /></td></tr>
<tr class="separator:a143863763b2e52aa5f9e9817ce9d5320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a647ff5f5afc6abf9210e72171590c"><td class="memTemplParams" colspan="2">template&lt;class TLOC  = T, typename std::enable_if&lt; std::is_const&lt; TLOC &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a34a647ff5f5afc6abf9210e72171590c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a34a647ff5f5afc6abf9210e72171590c">deallocate</a> ()</td></tr>
<tr class="memdesc:a34a647ff5f5afc6abf9210e72171590c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If owned, decrement the reference counter; if ref counter reaches zero, deallocate memory; If non-owned, does nothing.  <a href="classyakl_1_1ArrayBase.html#a34a647ff5f5afc6abf9210e72171590c">More...</a><br /></td></tr>
<tr class="separator:a34a647ff5f5afc6abf9210e72171590c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a647ff5f5afc6abf9210e72171590c"><td class="memTemplParams" colspan="2">template&lt;class TLOC  = T, typename std::enable_if&lt; ! std::is_const&lt; TLOC &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a34a647ff5f5afc6abf9210e72171590c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a34a647ff5f5afc6abf9210e72171590c">deallocate</a> ()</td></tr>
<tr class="memdesc:a34a647ff5f5afc6abf9210e72171590c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If owned, decrement the reference counter; if ref counter reaches zero, deallocate memory; If non-owned, does nothing.  <a href="classyakl_1_1ArrayBase.html#a34a647ff5f5afc6abf9210e72171590c">More...</a><br /></td></tr>
<tr class="separator:a34a647ff5f5afc6abf9210e72171590c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3168cca3017d7c20a25d2efec4492c05"><td class="memTemplParams" colspan="2">template&lt;int theirRank, int theirStyle&gt; </td></tr>
<tr class="memitem:a3168cca3017d7c20a25d2efec4492c05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a3168cca3017d7c20a25d2efec4492c05">deep_copy_to</a> (<a class="el" href="classyakl_1_1Array.html">Array</a>&lt; typename std::remove_cv&lt; T &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>, theirRank, <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce">memDevice</a>, theirStyle &gt; const &amp;lhs, <a class="el" href="structyakl_1_1Stream.html">Stream</a> stream=<a class="el" href="structyakl_1_1Stream.html">Stream</a>()) const</td></tr>
<tr class="memdesc:a3168cca3017d7c20a25d2efec4492c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">[ASYNCHRONOUS] [DEEP_COPY] Copy this array's contents to a <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> array.  <a href="classyakl_1_1ArrayBase.html#a3168cca3017d7c20a25d2efec4492c05">More...</a><br /></td></tr>
<tr class="separator:a3168cca3017d7c20a25d2efec4492c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fbcec907225403b20366ee57d7a63a"><td class="memTemplParams" colspan="2">template&lt;int theirRank, int theirStyle&gt; </td></tr>
<tr class="memitem:a55fbcec907225403b20366ee57d7a63a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a55fbcec907225403b20366ee57d7a63a">deep_copy_to</a> (<a class="el" href="classyakl_1_1Array.html">Array</a>&lt; typename std::remove_cv&lt; T &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>, theirRank, <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98">memHost</a>, theirStyle &gt; const &amp;lhs, <a class="el" href="structyakl_1_1Stream.html">Stream</a> stream=<a class="el" href="structyakl_1_1Stream.html">Stream</a>()) const</td></tr>
<tr class="memdesc:a55fbcec907225403b20366ee57d7a63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">[ASYNCHRONOUS] [DEEP_COPY] Copy this array's contents to a <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> array.  <a href="classyakl_1_1ArrayBase.html#a55fbcec907225403b20366ee57d7a63a">More...</a><br /></td></tr>
<tr class="separator:a55fbcec907225403b20366ee57d7a63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30952cae3c858f3cc186f9b2b75436e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a30952cae3c858f3cc186f9b2b75436e5">get_data</a> () const</td></tr>
<tr class="memdesc:a30952cae3c858f3cc186f9b2b75436e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw data pointer of this array object.  <a href="classyakl_1_1ArrayBase.html#a30952cae3c858f3cc186f9b2b75436e5">More...</a><br /></td></tr>
<tr class="separator:a30952cae3c858f3cc186f9b2b75436e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9c53c39898d244feb979ab56bbb91f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a4c9c53c39898d244feb979ab56bbb91f">get_elem_count</a> () const</td></tr>
<tr class="memdesc:a4c9c53c39898d244feb979ab56bbb91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements in this array object.  <a href="classyakl_1_1ArrayBase.html#a4c9c53c39898d244feb979ab56bbb91f">More...</a><br /></td></tr>
<tr class="separator:a4c9c53c39898d244feb979ab56bbb91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8764f2655febc99a9fb051e22a71d990"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a8764f2655febc99a9fb051e22a71d990">get_memory_space</a> () const</td></tr>
<tr class="memdesc:a8764f2655febc99a9fb051e22a71d990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this array object's string label if the <code>YAKL_DEBUG</code> CPP macro is defined. Otherwise, returns an empty string.  <a href="classyakl_1_1ArrayBase.html#a8764f2655febc99a9fb051e22a71d990">More...</a><br /></td></tr>
<tr class="separator:a8764f2655febc99a9fb051e22a71d990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5069cb724512bc32277dee3454dae0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#ae5069cb724512bc32277dee3454dae0c">get_rank</a> () const</td></tr>
<tr class="memdesc:ae5069cb724512bc32277dee3454dae0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of dimensions in this array object.  <a href="classyakl_1_1ArrayBase.html#ae5069cb724512bc32277dee3454dae0c">More...</a><br /></td></tr>
<tr class="separator:ae5069cb724512bc32277dee3454dae0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3373ceea89cf75ee78b2293bcafec919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a3373ceea89cf75ee78b2293bcafec919">get_totElems</a> () const</td></tr>
<tr class="memdesc:a3373ceea89cf75ee78b2293bcafec919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements in this array object.  <a href="classyakl_1_1ArrayBase.html#a3373ceea89cf75ee78b2293bcafec919">More...</a><br /></td></tr>
<tr class="separator:a3373ceea89cf75ee78b2293bcafec919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c013a8fd5591b535efc58ddd9f9e34a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a2c013a8fd5591b535efc58ddd9f9e34a">initialized</a> () const</td></tr>
<tr class="memdesc:a2c013a8fd5591b535efc58ddd9f9e34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this array object has is in an initialized / allocated state.  <a href="classyakl_1_1ArrayBase.html#a2c013a8fd5591b535efc58ddd9f9e34a">More...</a><br /></td></tr>
<tr class="separator:a2c013a8fd5591b535efc58ddd9f9e34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e355c36b4752b538379580a463b3155"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a8e355c36b4752b538379580a463b3155">label</a> () const</td></tr>
<tr class="separator:a8e355c36b4752b538379580a463b3155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f54c3467ec5c047273b7d722c06a58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a30f54c3467ec5c047273b7d722c06a58">size</a> () const</td></tr>
<tr class="memdesc:a30f54c3467ec5c047273b7d722c06a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements in this array object.  <a href="classyakl_1_1ArrayBase.html#a30f54c3467ec5c047273b7d722c06a58">More...</a><br /></td></tr>
<tr class="separator:a30f54c3467ec5c047273b7d722c06a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7f82d7a960950a9f3586c763c2c0f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a8d7f82d7a960950a9f3586c763c2c0f1">span_is_contiguous</a> () const</td></tr>
<tr class="memdesc:a8d7f82d7a960950a9f3586c763c2c0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always true. <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects are always contiguous in memory with no padding.  <a href="classyakl_1_1ArrayBase.html#a8d7f82d7a960950a9f3586c763c2c0f1">More...</a><br /></td></tr>
<tr class="separator:a8d7f82d7a960950a9f3586c763c2c0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b0d114b4b42a1719f7f7123cc84526"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a29b0d114b4b42a1719f7f7123cc84526">totElems</a> () const</td></tr>
<tr class="memdesc:a29b0d114b4b42a1719f7f7123cc84526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements in this array object.  <a href="classyakl_1_1ArrayBase.html#a29b0d114b4b42a1719f7f7123cc84526">More...</a><br /></td></tr>
<tr class="separator:a29b0d114b4b42a1719f7f7123cc84526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c1fe00357c035543b73300839f9d75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#ad9c1fe00357c035543b73300839f9d75">use_count</a> () const</td></tr>
<tr class="memdesc:ad9c1fe00357c035543b73300839f9d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many array objects share this pointer if owned; or <code>0</code> if unowned.  <a href="classyakl_1_1ArrayBase.html#ad9c1fe00357c035543b73300839f9d75">More...</a><br /></td></tr>
<tr class="separator:ad9c1fe00357c035543b73300839f9d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a0de8c0886a240a193dcde1160e90a3a2"><td class="memItemLeft" align="right" valign="top">StreamListDummy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#a0de8c0886a240a193dcde1160e90a3a2">stream_dependencies</a></td></tr>
<tr class="separator:a0de8c0886a240a193dcde1160e90a3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad375fc288164027affc33c473daa7981"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html#ad375fc288164027affc33c473daa7981">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, rank, myMem, myStyle &gt; const &amp;v)</td></tr>
<tr class="memdesc:ad375fc288164027affc33c473daa7981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to <code>std::cout &lt;&lt; this_array_object;</code>. This works even for <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> array objects.  <a href="classyakl_1_1ArrayBase.html#ad375fc288164027affc33c473daa7981">More...</a><br /></td></tr>
<tr class="separator:ad375fc288164027affc33c473daa7981"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, int rank, int myMem, int myStyle&gt;<br />
class yakl::ArrayBase&lt; T, rank, myMem, myStyle &gt;</h3>

<p>This class implements functionality common to both <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d" title="Template parameter for yakl::Array that specifies it should follow C-style behavior.">yakl::styleC</a> and <a class="el" href="namespaceyakl.html#a48029004bb42b7cc63974ca0433af63a" title="Template parameter for yakl::Array that specifies it should follow Fortran-style behavior.">yakl::styleFortran</a> <code><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a></code> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Type of the array. For <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> array objects, this can generally be any type. For <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> array objects, this needs to be a type without a constructor, preferrably an arithmetic type. </td></tr>
    <tr><td class="paramname">rank</td><td>The number of dimensions for this array object. </td></tr>
    <tr><td class="paramname">myMem</td><td>The memory space for this array object: Either <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> or <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> </td></tr>
    <tr><td class="paramname">myStyle</td><td>The behavior of this array object: Either <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d" title="Template parameter for yakl::Array that specifies it should follow C-style behavior.">yakl::styleC</a> or <a class="el" href="namespaceyakl.html#a48029004bb42b7cc63974ca0433af63a" title="Template parameter for yakl::Array that specifies it should follow Fortran-style behavior.">yakl::styleFortran</a> </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab93d72c9e827137a972b928af87a9e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93d72c9e827137a972b928af87a9e3f">&#9670;&nbsp;</a></span>const_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::add_const&lt;<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>&gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a> <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#ab93d72c9e827137a972b928af87a9e3f">const_value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type <code>T</code> with <code>const</code> added to it (if the original type has <code>volatile</code>, then so will this type. </p>

</div>
</div>
<a id="ae4212fa32ba3a9a87a5a4fde69d4a2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4212fa32ba3a9a87a5a4fde69d4a2f0">&#9670;&nbsp;</a></span>non_const_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::remove_const&lt;<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>&gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a> <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#ae4212fa32ba3a9a87a5a4fde69d4a2f0">non_const_value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type <code>T</code> with <code>const</code> removed from it (if the original type has <code>volatile</code>, then so will this type. </p>

</div>
</div>
<a id="a99c8aec2f010ccfe2a8db0c760b7bb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c8aec2f010ccfe2a8db0c760b7bb71">&#9670;&nbsp;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::remove_cv&lt;T&gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a> <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type <code>T</code> without <code>const</code> and <code>volatile</code> modifiers. </p>

</div>
</div>
<a id="a16dd11d776c327372882831924e08461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16dd11d776c327372882831924e08461">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a16dd11d776c327372882831924e08461">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type <code>T</code> exactly as it was defined upon array object creation. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a04b6387ea5d7a49812a37a1398df9a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b6387ea5d7a49812a37a1398df9a33">&#9670;&nbsp;</a></span>add_stream_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::add_stream_dependencies </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structyakl_1_1Stream.html">Stream</a> &gt;&#160;</td>
          <td class="paramname"><em>streams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare a dependencies on the multiple streams at one time. </p>
<p>Upon deallocation, an event is placed in each stream this array depends on. The data pointer is not released from the pool until all dependent events complete. This avoids potential pointer aliasing of Arrays potentially being used simultaneous in different parallel streams. The pool allocator is non-blocking, so erroneous aliasing can occur if the user uses multiple streams, deallocates and allocates during runtime, and does not use this function. </p>

</div>
</div>
<a id="a063c0eb1c0523ebd00abad99f5a9bf85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063c0eb1c0523ebd00abad99f5a9bf85">&#9670;&nbsp;</a></span>add_stream_dependency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::add_stream_dependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structyakl_1_1Stream.html">Stream</a>&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare a dependency on the passed stream. </p>
<p>Upon deallocation, an event is placed in each stream this array depends on. The data pointer is not released from the pool until all dependent events complete. This avoids potential pointer aliasing of Arrays potentially being used simultaneous in different parallel streams. The pool allocator is non-blocking, so erroneous aliasing can occur if the user uses multiple streams, deallocates and allocates during runtime, and does not use this function. </p>

</div>
</div>
<a id="a143863763b2e52aa5f9e9817ce9d5320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143863763b2e52aa5f9e9817ce9d5320">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T* <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the raw data pointer of this array object. </p>

</div>
</div>
<a id="a34a647ff5f5afc6abf9210e72171590c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a647ff5f5afc6abf9210e72171590c">&#9670;&nbsp;</a></span>deallocate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<div class="memtemplate">
template&lt;class TLOC  = T, typename std::enable_if&lt; std::is_const&lt; TLOC &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If owned, decrement the reference counter; if ref counter reaches zero, deallocate memory; If non-owned, does nothing. </p>
<p>If the reference counter reaches zero, meaning no other array objects are sharing this data pointer, the deallocate the data. This routine has the same effect as assigning this array object to an empty array object. This is safe to call even if this array object is not yet allocated. </p>

</div>
</div>
<a id="a34a647ff5f5afc6abf9210e72171590c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a647ff5f5afc6abf9210e72171590c">&#9670;&nbsp;</a></span>deallocate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<div class="memtemplate">
template&lt;class TLOC  = T, typename std::enable_if&lt; ! std::is_const&lt; TLOC &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If owned, decrement the reference counter; if ref counter reaches zero, deallocate memory; If non-owned, does nothing. </p>
<p>If the reference counter reaches zero, meaning no other array objects are sharing this data pointer, the deallocate the data. This routine has the same effect as assigning this array object to an empty array object. This is safe to call even if this array object is not yet allocated. </p>

</div>
</div>
<a id="a3168cca3017d7c20a25d2efec4492c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3168cca3017d7c20a25d2efec4492c05">&#9670;&nbsp;</a></span>deep_copy_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<div class="memtemplate">
template&lt;int theirRank, int theirStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::deep_copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; typename std::remove_cv&lt; T &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>, theirRank, <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce">memDevice</a>, theirStyle &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyakl_1_1Stream.html">Stream</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="structyakl_1_1Stream.html">Stream</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[ASYNCHRONOUS] [DEEP_COPY] Copy this array's contents to a <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> array. </p>
<p>Arrays must have the same type and total number of elements. No checking of rank, style, or dimensionality is performed. Both arrays must be allocated. <code>this</code> array may be in <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> or <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> space. </p>

</div>
</div>
<a id="a55fbcec907225403b20366ee57d7a63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fbcec907225403b20366ee57d7a63a">&#9670;&nbsp;</a></span>deep_copy_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<div class="memtemplate">
template&lt;int theirRank, int theirStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::deep_copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; typename std::remove_cv&lt; T &gt;::<a class="el" href="classyakl_1_1ArrayBase.html#a99c8aec2f010ccfe2a8db0c760b7bb71">type</a>, theirRank, <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98">memHost</a>, theirStyle &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyakl_1_1Stream.html">Stream</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="structyakl_1_1Stream.html">Stream</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[ASYNCHRONOUS] [DEEP_COPY] Copy this array's contents to a <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> array. </p>
<p>Arrays must have the same type and total number of elements. No checking of rank, style, or dimensionality is performed. Both arrays must be allocated. <code>this</code> array may be in <a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98" title="Specifies a device memory address space for a yakl::Array object.">yakl::memHost</a> or <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> space. </p>

</div>
</div>
<a id="a30952cae3c858f3cc186f9b2b75436e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30952cae3c858f3cc186f9b2b75436e5">&#9670;&nbsp;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> T* <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::get_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the raw data pointer of this array object. </p>

</div>
</div>
<a id="a4c9c53c39898d244feb979ab56bbb91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9c53c39898d244feb979ab56bbb91f">&#9670;&nbsp;</a></span>get_elem_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::get_elem_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of elements in this array object. </p>

</div>
</div>
<a id="a8764f2655febc99a9fb051e22a71d990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8764f2655febc99a9fb051e22a71d990">&#9670;&nbsp;</a></span>get_memory_space()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> int <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::get_memory_space </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this array object's string label if the <code>YAKL_DEBUG</code> CPP macro is defined. Otherwise, returns an empty string. </p>

</div>
</div>
<a id="ae5069cb724512bc32277dee3454dae0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5069cb724512bc32277dee3454dae0c">&#9670;&nbsp;</a></span>get_rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> int <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::get_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of dimensions in this array object. </p>

</div>
</div>
<a id="a3373ceea89cf75ee78b2293bcafec919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3373ceea89cf75ee78b2293bcafec919">&#9670;&nbsp;</a></span>get_totElems()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::get_totElems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of elements in this array object. </p>

</div>
</div>
<a id="a2c013a8fd5591b535efc58ddd9f9e34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c013a8fd5591b535efc58ddd9f9e34a">&#9670;&nbsp;</a></span>initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> bool <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this array object has is in an initialized / allocated state. </p>

</div>
</div>
<a id="a8e355c36b4752b538379580a463b3155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e355c36b4752b538379580a463b3155">&#9670;&nbsp;</a></span>label()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30f54c3467ec5c047273b7d722c06a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f54c3467ec5c047273b7d722c06a58">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of elements in this array object. </p>

</div>
</div>
<a id="a8d7f82d7a960950a9f3586c763c2c0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7f82d7a960950a9f3586c763c2c0f1">&#9670;&nbsp;</a></span>span_is_contiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> bool <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::span_is_contiguous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Always true. <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects are always contiguous in memory with no padding. </p>

</div>
</div>
<a id="a29b0d114b4b42a1719f7f7123cc84526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b0d114b4b42a1719f7f7123cc84526">&#9670;&nbsp;</a></span>totElems()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::totElems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of elements in this array object. </p>

</div>
</div>
<a id="ad9c1fe00357c035543b73300839f9d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c1fe00357c035543b73300839f9d75">&#9670;&nbsp;</a></span>use_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns how many array objects share this pointer if owned; or <code>0</code> if unowned. </p>
<p>Returns the use count for this array object's data pointer. I.e., this is how many <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects currently share this data pointer. If this returns a value of <code>0</code>, that means that this array object is <b>not</b> being reference counted, meaning it performed no allocation upon creation, will perform no deallocation upon destruction, and has no control over whether the memory pointed to by the data pointer stays allocated or not. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad375fc288164027affc33c473daa7981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad375fc288164027affc33c473daa7981">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, rank, myMem, myStyle &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the user to <code>std::cout &lt;&lt; this_array_object;</code>. This works even for <a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce" title="Specifies a device memory address space for a yakl::Array object.">yakl::memDevice</a> array objects. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0de8c0886a240a193dcde1160e90a3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de8c0886a240a193dcde1160e90a3a2">&#9670;&nbsp;</a></span>stream_dependencies</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">StreamListDummy <a class="el" href="classyakl_1_1ArrayBase.html">yakl::ArrayBase</a>&lt; T, rank, myMem, myStyle &gt;::stream_dependencies</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>YAKL/src/<a class="el" href="YAKL__ArrayBase_8h_source.html">YAKL_ArrayBase.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
