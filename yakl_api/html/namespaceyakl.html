<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YAKL: yakl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YAKL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">yakl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceyakl_1_1c"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl_1_1c.html">c</a></td></tr>
<tr class="memdesc:namespaceyakl_1_1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains <code><a class="el" href="classyakl_1_1c_1_1Bounds.html" title="Describes a set of C-style tightly-nested loops. ">Bounds</a></code> class, and <code><a class="el" href="namespaceyakl_1_1c.html#a81973df01907f317999d46b3d030a26f" title="[ASYNCHRONOUS] Launch the passed functor in parallel. ">parallel_for()</a></code> routines using C-style indexing and ordering. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceyakl_1_1componentwise"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl_1_1componentwise.html">componentwise</a></td></tr>
<tr class="memdesc:namespaceyakl_1_1componentwise"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains routines that perform element-wise / component-wise operations on <code><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a></code>, <code>SArray</code>, and <code><a class="el" href="classyakl_1_1FSArray.html" title="Fortran-style array on the stack similar in nature to, e.g., float arr[ny][nx]; ">FSArray</a></code> objects. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceyakl_1_1fortran"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl_1_1fortran.html">fortran</a></td></tr>
<tr class="memdesc:namespaceyakl_1_1fortran"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains <code><a class="el" href="classyakl_1_1fortran_1_1Bounds.html" title="Describes a set of Fortran-style tightly-nested loops. ">Bounds</a></code> class, and <code><a class="el" href="namespaceyakl_1_1fortran.html#a2a63e3b0057ff99c787ac655a287a53a" title="[ASYNCHRONOUS] Launch the passed functor in parallel. ">parallel_for()</a></code> routines using Fortran-style indexing and ordering. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceyakl_1_1intrinsics"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl_1_1intrinsics.html">intrinsics</a></td></tr>
<tr class="memdesc:namespaceyakl_1_1intrinsics"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intrinsics namespace contains a limited Fortran-like intrinsics library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceyakl_1_1simd"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl_1_1simd.html">simd</a></td></tr>
<tr class="memdesc:namespaceyakl_1_1simd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds YAKL's <a class="el" href="classyakl_1_1simd_1_1Pack.html" title="The Pack class performs encourages vectorization by performing operations Packs of known size...">Pack</a> class and operators to encourage SIMD vectorization. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This declares the <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> class. Please see the <a class="el" href="namespaceyakl.html#ade189cb0cee1c42b0753541817ea81cd" title="Template parameter for yakl::Array that specifies it should follow C-style behavior. ">yakl::styleC</a> and <a class="el" href="namespaceyakl.html#a86246e080d4fb462bf03deb2fdb2a467" title="Template parameter for yakl::Array that specifies it should follow Fortran-style behavior. ">yakl::styleFortran</a> template specializations for more detailed information about this class.  <a href="classyakl_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html">Array&lt; T, rank, myMem, styleC &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements the yakl:<a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> class with <a class="el" href="namespaceyakl.html#ade189cb0cee1c42b0753541817ea81cd" title="Template parameter for yakl::Array that specifies it should follow C-style behavior. ">yakl::styleC</a> behavior.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleFortran_01_4.html">Array&lt; T, rank, myMem, styleFortran &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements the yakl:<a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> class with <a class="el" href="namespaceyakl.html#a86246e080d4fb462bf03deb2fdb2a467" title="Template parameter for yakl::Array that specifies it should follow Fortran-style behavior. ">yakl::styleFortran</a> behavior.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleFortran_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html">ArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements functionality common to both <a class="el" href="namespaceyakl.html#ade189cb0cee1c42b0753541817ea81cd" title="Template parameter for yakl::Array that specifies it should follow C-style behavior. ">yakl::styleC</a> and <a class="el" href="namespaceyakl.html#a86246e080d4fb462bf03deb2fdb2a467" title="Template parameter for yakl::Array that specifies it should follow Fortran-style behavior. ">yakl::styleFortran</a> <code><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a></code> objects.  <a href="classyakl_1_1ArrayBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyakl_1_1Bnd.html">Bnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a single bound for creating Fortran-style <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects.  <a href="structyakl_1_1Bnd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Bnds.html">Bnds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds Fortran-style dimensions for using in creating <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects.  <a href="classyakl_1_1Bnds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1CSArray.html">CSArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-style array on the stack similar in nature to, e.g., <code>float arr[ny][nx];</code>  <a href="classyakl_1_1CSArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Dims.html">Dims</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds C-style dimensions for using in <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects.  <a href="classyakl_1_1Dims.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyakl_1_1Event.html">Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the functionality of an event within a stream. The event is not created until the <code><a class="el" href="structyakl_1_1Event.html#abae2d4b090d6a6873b98c2a73c203fd8" title="Create the event. ">Event::create()</a></code> function is called.  <a href="structyakl_1_1Event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1FSArray.html">FSArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fortran-style array on the stack similar in nature to, e.g., <code>float arr[ny][nx];</code>  <a href="classyakl_1_1FSArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html">Gator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">YAKL Pool allocator class.  <a href="classyakl_1_1Gator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1InitConfig.html">InitConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object of this class can optionally be passed to <a class="el" href="namespaceyakl.html#aafe78b03b672a31b597b0b1e4cd97af7" title="Initialize the YAKL runtime. ">yakl::init()</a> to configure the initialization. <b>IMPORTANT</b>: Creating an <a class="el" href="classyakl_1_1InitConfig.html" title="An object of this class can optionally be passed to yakl::init() to configure the initialization...">InitConfig</a> object pings environment variables, making it quite expensive to create. Please do not create a lot of these.  <a href="classyakl_1_1InitConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyakl_1_1InnerHandlerEmpty.html">InnerHandlerEmpty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is necessary for coordination of two-level parallelism.  <a href="structyakl_1_1InnerHandlerEmpty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class informs YAKL <code>parallel_for</code> and <code>parallel_outer</code> routines how to launch kernels.  <a href="structyakl_1_1LaunchConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Random.html">Random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cryptographic pseudo-random number generator with a very small internal state.  <a href="classyakl_1_1Random.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1RealFFT1D.html">RealFFT1D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute batched real-to-complex forward and inverse FFTs on <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects using vendor libraries.  <a href="classyakl_1_1RealFFT1D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1SB.html">SB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This specifies a set of bounds for a dimension when declaring a <a class="el" href="classyakl_1_1FSArray.html" title="Fortran-style array on the stack similar in nature to, e.g., float arr[ny][nx]; ">yakl::FSArray</a>.  <a href="classyakl_1_1SB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ScalarLiveOut.html">ScalarLiveOut</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to handle scalars that exist before kernels, are written to by kernels, and read after the kernel terminates.  <a href="classyakl_1_1ScalarLiveOut.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1SimpleNetCDF.html">SimpleNetCDF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple way to write <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects to NetCDF files.  <a href="classyakl_1_1SimpleNetCDF.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1SimplePNetCDF.html">SimplePNetCDF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple way to write <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects to NetCDF files in parallel.  <a href="classyakl_1_1SimplePNetCDF.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyakl_1_1Stream.html">Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the functionality of a stream for parallel kernel execution. If the <code><a class="el" href="structyakl_1_1Stream.html#a162f95e332c4b578800426f6e8b6480a" title="Create the stream. ">Stream::create()</a></code> method is not called on this object, then it is the default stream.  <a href="structyakl_1_1Stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyakl_1_1StreamList.html">StreamList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a list of <a class="el" href="structyakl_1_1Stream.html" title="Implements the functionality of a stream for parallel kernel execution. If the Stream::create() metho...">Stream</a> objects. Needs to store a pointer to avoid construction on the device since <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> objects need to store a list of streams on which they depend.  <a href="structyakl_1_1StreamList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a82d096ec8a882129a4c2b84f0f636d60"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a82d096ec8a882129a4c2b84f0f636d60">DefaultLaunchConfig</a> = <a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a>&lt;&gt;</td></tr>
<tr class="memdesc:a82d096ec8a882129a4c2b84f0f636d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">This launch configuration sets vector length to the device default and <code>B4B</code> to <code>false</code>.  <a href="#a82d096ec8a882129a4c2b84f0f636d60">More...</a><br /></td></tr>
<tr class="separator:a82d096ec8a882129a4c2b84f0f636d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b33cfecadff879247cf80a54e825acd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a9b33cfecadff879247cf80a54e825acd">DefaultLaunchConfigB4b</a> = <a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a>&lt; <a class="el" href="YAKL__LaunchConfig_8h.html#a9d0e22704e1de301961bf131053aed15">YAKL_DEFAULT_VECTOR_LEN</a>, true &gt;</td></tr>
<tr class="memdesc:a9b33cfecadff879247cf80a54e825acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">launch configuration sets B4B == true with the default <code>VecLen</code>.  <a href="#a9b33cfecadff879247cf80a54e825acd">More...</a><br /></td></tr>
<tr class="separator:a9b33cfecadff879247cf80a54e825acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172abcdd2d33fa36e969d80e6907173c"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a></td></tr>
<tr class="separator:a172abcdd2d33fa36e969d80e6907173c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ef5b6a07452eabddb6533b3091cef1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structyakl_1_1InnerHandlerEmpty.html">yakl::InnerHandlerEmpty</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a60ef5b6a07452eabddb6533b3091cef1">InnerHandler</a></td></tr>
<tr class="memdesc:a60ef5b6a07452eabddb6533b3091cef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is necessary for coordination of two-level parallelism.  <a href="#a60ef5b6a07452eabddb6533b3091cef1">More...</a><br /></td></tr>
<tr class="separator:a60ef5b6a07452eabddb6533b3091cef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fff077cfae8547c78e7c76bdd45a465"><td class="memTemplParams" colspan="2">template&lt;int VecLen = YAKL_DEFAULT_VECTOR_LEN&gt; </td></tr>
<tr class="memitem:a0fff077cfae8547c78e7c76bdd45a465"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a0fff077cfae8547c78e7c76bdd45a465">LaunchConfigB4b</a> = <a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a>&lt; VecLen, true &gt;</td></tr>
<tr class="memdesc:a0fff077cfae8547c78e7c76bdd45a465"><td class="mdescLeft">&#160;</td><td class="mdescRight">launch configuration sets B4B == true with a user-specified <code>VecLen</code>.  <a href="#a0fff077cfae8547c78e7c76bdd45a465">More...</a><br /></td></tr>
<tr class="separator:a0fff077cfae8547c78e7c76bdd45a465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabbe6df1f315d5e2c1874cf1be0acf2"><td class="memTemplParams" colspan="2">template&lt;class T , int rank, unsigned D0, unsigned D1 = 1, unsigned D2 = 1, unsigned D3 = 1&gt; </td></tr>
<tr class="memitem:adabbe6df1f315d5e2c1874cf1be0acf2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a> = <a class="el" href="classyakl_1_1CSArray.html">CSArray</a>&lt; T, rank, D0, D1, D2, D3 &gt;</td></tr>
<tr class="memdesc:adabbe6df1f315d5e2c1874cf1be0acf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most often, codes use the type define <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray. ">yakl::SArray</a> rather than <a class="el" href="classyakl_1_1CSArray.html" title="C-style array on the stack similar in nature to, e.g., float arr[ny][nx]; ">yakl::CSArray</a>.  <a href="#adabbe6df1f315d5e2c1874cf1be0acf2">More...</a><br /></td></tr>
<tr class="separator:adabbe6df1f315d5e2c1874cf1be0acf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a744db414fb0ff8dbc17bcd08e05474da"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a744db414fb0ff8dbc17bcd08e05474da">alloc_device</a> (size_t bytes, char const *label)</td></tr>
<tr class="memdesc:a744db414fb0ff8dbc17bcd08e05474da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate on the device using YAKL's device allocator.  <a href="#a744db414fb0ff8dbc17bcd08e05474da">More...</a><br /></td></tr>
<tr class="separator:a744db414fb0ff8dbc17bcd08e05474da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cda355f1f737b5b613b6463232f3e69"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9cda355f1f737b5b613b6463232f3e69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a9cda355f1f737b5b613b6463232f3e69">atomicAdd</a> (T &amp;update, T value)</td></tr>
<tr class="memdesc:a9cda355f1f737b5b613b6463232f3e69"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>[NON_B4B] yakl::atomicAdd(update,value)</code> atomically performs <code>update += value)</code>  <a href="#a9cda355f1f737b5b613b6463232f3e69">More...</a><br /></td></tr>
<tr class="separator:a9cda355f1f737b5b613b6463232f3e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cb894576efe9797212d7befde66c74"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a41cb894576efe9797212d7befde66c74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a41cb894576efe9797212d7befde66c74">atomicMax</a> (T &amp;update, T value)</td></tr>
<tr class="memdesc:a41cb894576efe9797212d7befde66c74"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>yakl::atomicMax(update,value)</code> atomically performs <code>update = max(update,value)</code>  <a href="#a41cb894576efe9797212d7befde66c74">More...</a><br /></td></tr>
<tr class="separator:a41cb894576efe9797212d7befde66c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f63fe7be70100d62b0e572967abea7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a00f63fe7be70100d62b0e572967abea7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a00f63fe7be70100d62b0e572967abea7">atomicMin</a> (T &amp;update, T value)</td></tr>
<tr class="memdesc:a00f63fe7be70100d62b0e572967abea7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>yakl::atomicMin(update,value)</code> atomically performs <code>update = min(update,value)</code>  <a href="#a00f63fe7be70100d62b0e572967abea7">More...</a><br /></td></tr>
<tr class="separator:a00f63fe7be70100d62b0e572967abea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e01c087965b875ff55d3c7b2b4f4b00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a7e01c087965b875ff55d3c7b2b4f4b00">check_last_error</a> ()</td></tr>
<tr class="memdesc:a7e01c087965b875ff55d3c7b2b4f4b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if an error has occurred on the device.  <a href="#a7e01c087965b875ff55d3c7b2b4f4b00">More...</a><br /></td></tr>
<tr class="separator:a7e01c087965b875ff55d3c7b2b4f4b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e84c30ee165a8fa826468d357c959df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structyakl_1_1Stream.html">Stream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a2e84c30ee165a8fa826468d357c959df">create_stream</a> ()</td></tr>
<tr class="memdesc:a2e84c30ee165a8fa826468d357c959df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a <a class="el" href="structyakl_1_1Stream.html" title="Implements the functionality of a stream for parallel kernel execution. If the Stream::create() metho...">Stream</a> object. It is guaranteed to not be the default stream.  <a href="#a2e84c30ee165a8fa826468d357c959df">More...</a><br /></td></tr>
<tr class="separator:a2e84c30ee165a8fa826468d357c959df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5debd8fe5fff4f37c06e55648d138e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a5debd8fe5fff4f37c06e55648d138e0c">fence</a> ()</td></tr>
<tr class="memdesc:a5debd8fe5fff4f37c06e55648d138e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the host code until all device code has completed.  <a href="#a5debd8fe5fff4f37c06e55648d138e0c">More...</a><br /></td></tr>
<tr class="separator:a5debd8fe5fff4f37c06e55648d138e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823fefa19bd87dca7a0c66094130d6db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a823fefa19bd87dca7a0c66094130d6db">fence_inner</a> (<a class="el" href="namespaceyakl.html#a60ef5b6a07452eabddb6533b3091cef1">InnerHandler</a> &amp;handler)</td></tr>
<tr class="memdesc:a823fefa19bd87dca7a0c66094130d6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block inner threads until all inner threads have completed.  <a href="#a823fefa19bd87dca7a0c66094130d6db">More...</a><br /></td></tr>
<tr class="separator:a823fefa19bd87dca7a0c66094130d6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42370df4914644cfd129ff6037c5c9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ab42370df4914644cfd129ff6037c5c9f">finalize</a> ()</td></tr>
<tr class="memdesc:ab42370df4914644cfd129ff6037c5c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the YAKL runtime.  <a href="#ab42370df4914644cfd129ff6037c5c9f">More...</a><br /></td></tr>
<tr class="separator:ab42370df4914644cfd129ff6037c5c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afa807b3b1f4e331ece7954c94134fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a8afa807b3b1f4e331ece7954c94134fc">free_device</a> (void *ptr, char const *label)</td></tr>
<tr class="memdesc:a8afa807b3b1f4e331ece7954c94134fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free on the device using YAKL's device deallocator.  <a href="#a8afa807b3b1f4e331ece7954c94134fc">More...</a><br /></td></tr>
<tr class="separator:a8afa807b3b1f4e331ece7954c94134fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe78b03b672a31b597b0b1e4cd97af7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aafe78b03b672a31b597b0b1e4cd97af7">init</a> (<a class="el" href="classyakl_1_1InitConfig.html">InitConfig</a> config=<a class="el" href="classyakl_1_1InitConfig.html">InitConfig</a>())</td></tr>
<tr class="memdesc:aafe78b03b672a31b597b0b1e4cd97af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the YAKL runtime.  <a href="#aafe78b03b672a31b597b0b1e4cd97af7">More...</a><br /></td></tr>
<tr class="separator:aafe78b03b672a31b597b0b1e4cd97af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110195fb8259c05f75506e71aa5a792c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a110195fb8259c05f75506e71aa5a792c">isInitialized</a> ()</td></tr>
<tr class="memdesc:a110195fb8259c05f75506e71aa5a792c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the YAKL runtime has been initialized. I.e., <a class="el" href="namespaceyakl.html#aafe78b03b672a31b597b0b1e4cd97af7" title="Initialize the YAKL runtime. ">yakl::init()</a> has been called without a corresponding call to <a class="el" href="namespaceyakl.html#ab42370df4914644cfd129ff6037c5c9f" title="Finalize the YAKL runtime. ">yakl::finalize()</a>.  <a href="#a110195fb8259c05f75506e71aa5a792c">More...</a><br /></td></tr>
<tr class="separator:a110195fb8259c05f75506e71aa5a792c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026f32705165108c6df7a07c502159d3"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a026f32705165108c6df7a07c502159d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a026f32705165108c6df7a07c502159d3">memcpy_device_to_device</a> (T1 *dst, T2 *src, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> elems, <a class="el" href="structyakl_1_1Stream.html">Stream</a> stream=<a class="el" href="structyakl_1_1Stream.html">Stream</a>())</td></tr>
<tr class="memdesc:a026f32705165108c6df7a07c502159d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> on the device  <a href="#a026f32705165108c6df7a07c502159d3">More...</a><br /></td></tr>
<tr class="separator:a026f32705165108c6df7a07c502159d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19e1e161899936f71ec3f025a5f8c9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ab19e1e161899936f71ec3f025a5f8c9b">memcpy_device_to_device_void</a> (void *dst, void *src, size_t bytes, <a class="el" href="structyakl_1_1Stream.html">Stream</a> stream=<a class="el" href="structyakl_1_1Stream.html">Stream</a>())</td></tr>
<tr class="memdesc:ab19e1e161899936f71ec3f025a5f8c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">[USE AT YOUR OWN RISK]: memcpy the specified number of <b>bytes</b> on the device  <a href="#ab19e1e161899936f71ec3f025a5f8c9b">More...</a><br /></td></tr>
<tr class="separator:ab19e1e161899936f71ec3f025a5f8c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a975062053c2a7335efd7203471e232"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a2a975062053c2a7335efd7203471e232"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a2a975062053c2a7335efd7203471e232">memcpy_device_to_host</a> (T1 *dst, T2 *src, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> elems, <a class="el" href="structyakl_1_1Stream.html">Stream</a> stream=<a class="el" href="structyakl_1_1Stream.html">Stream</a>())</td></tr>
<tr class="memdesc:a2a975062053c2a7335efd7203471e232"><td class="mdescLeft">&#160;</td><td class="mdescRight">[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> from device to host  <a href="#a2a975062053c2a7335efd7203471e232">More...</a><br /></td></tr>
<tr class="separator:a2a975062053c2a7335efd7203471e232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7231acaa29ce8f8419a1ef69a36dd679"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a7231acaa29ce8f8419a1ef69a36dd679"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a7231acaa29ce8f8419a1ef69a36dd679">memcpy_host_to_device</a> (T1 *dst, T2 *src, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> elems, <a class="el" href="structyakl_1_1Stream.html">Stream</a> stream=<a class="el" href="structyakl_1_1Stream.html">Stream</a>())</td></tr>
<tr class="memdesc:a7231acaa29ce8f8419a1ef69a36dd679"><td class="mdescLeft">&#160;</td><td class="mdescRight">[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> from host to device  <a href="#a7231acaa29ce8f8419a1ef69a36dd679">More...</a><br /></td></tr>
<tr class="separator:a7231acaa29ce8f8419a1ef69a36dd679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3ccf876c613d1091413c21151aeeca"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a7e3ccf876c613d1091413c21151aeeca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a7e3ccf876c613d1091413c21151aeeca">memcpy_host_to_host</a> (T1 *dst, T2 *src, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> elems)</td></tr>
<tr class="memdesc:a7e3ccf876c613d1091413c21151aeeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> on the host  <a href="#a7e3ccf876c613d1091413c21151aeeca">More...</a><br /></td></tr>
<tr class="separator:a7e3ccf876c613d1091413c21151aeeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd2574081a93f391e588cab890f232f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a6dd2574081a93f391e588cab890f232f">memcpy_host_to_host_void</a> (void *dst, void *src, size_t bytes)</td></tr>
<tr class="memdesc:a6dd2574081a93f391e588cab890f232f"><td class="mdescLeft">&#160;</td><td class="mdescRight">[USE AT YOUR OWN RISK]: memcpy the specified number of <b>bytes</b> on the host  <a href="#a6dd2574081a93f391e588cab890f232f">More...</a><br /></td></tr>
<tr class="separator:a6dd2574081a93f391e588cab890f232f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0636ffa1809f47534bd4f705bae0d857"><td class="memTemplParams" colspan="2">template&lt;unsigned int n, class real &gt; </td></tr>
<tr class="memitem:a0636ffa1809f47534bd4f705bae0d857"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a0636ffa1809f47534bd4f705bae0d857">pentadiagonal</a> (<a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;a, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;b, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;c, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;d, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;e, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;f, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;u)</td></tr>
<tr class="memdesc:a0636ffa1809f47534bd4f705bae0d857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a <b>small</b> non-periodic pentadiagonal solve. Click for more details.  <a href="#a0636ffa1809f47534bd4f705bae0d857">More...</a><br /></td></tr>
<tr class="separator:a0636ffa1809f47534bd4f705bae0d857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98637dc95c0af6d4860349ada34e262"><td class="memTemplParams" colspan="2">template&lt;unsigned int n, class real &gt; </td></tr>
<tr class="memitem:ad98637dc95c0af6d4860349ada34e262"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ad98637dc95c0af6d4860349ada34e262">pentadiagonal_periodic</a> (<a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;a, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;b, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;c, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;d, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;e, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;f, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;x)</td></tr>
<tr class="memdesc:ad98637dc95c0af6d4860349ada34e262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a <b>small</b> periodic pentadiagonal solve. Click for more details.  <a href="#ad98637dc95c0af6d4860349ada34e262">More...</a><br /></td></tr>
<tr class="separator:ad98637dc95c0af6d4860349ada34e262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78754cc7984e3fde7592cf9a50faf53d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structyakl_1_1Event.html">Event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a78754cc7984e3fde7592cf9a50faf53d">record_event</a> (<a class="el" href="structyakl_1_1Stream.html">Stream</a> stream=<a class="el" href="structyakl_1_1Stream.html">Stream</a>())</td></tr>
<tr class="memdesc:a78754cc7984e3fde7592cf9a50faf53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create, record, and return an event using the given stream.  <a href="#a78754cc7984e3fde7592cf9a50faf53d">More...</a><br /></td></tr>
<tr class="separator:a78754cc7984e3fde7592cf9a50faf53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca055f3e17da1b57c8966dfb9537b1ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aca055f3e17da1b57c8966dfb9537b1ab">set_device_allocator</a> (std::function&lt; void *(size_t)&gt; func)</td></tr>
<tr class="memdesc:aca055f3e17da1b57c8966dfb9537b1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's device allocator with the passed function (No Label).  <a href="#aca055f3e17da1b57c8966dfb9537b1ab">More...</a><br /></td></tr>
<tr class="separator:aca055f3e17da1b57c8966dfb9537b1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0af7565eb0e0d219ba91dff20b9e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a3c0af7565eb0e0d219ba91dff20b9e90">set_device_allocator</a> (std::function&lt; void *(size_t, char const *)&gt; func)</td></tr>
<tr class="memdesc:a3c0af7565eb0e0d219ba91dff20b9e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's device allocator with the passed function (WITH Label).  <a href="#a3c0af7565eb0e0d219ba91dff20b9e90">More...</a><br /></td></tr>
<tr class="separator:a3c0af7565eb0e0d219ba91dff20b9e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56c3c1ec9df98cd97e7cbae04e3c8de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#af56c3c1ec9df98cd97e7cbae04e3c8de">set_device_deallocator</a> (std::function&lt; void(void *)&gt; func)</td></tr>
<tr class="memdesc:af56c3c1ec9df98cd97e7cbae04e3c8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's device deallocator with the passed function (No Label).  <a href="#af56c3c1ec9df98cd97e7cbae04e3c8de">More...</a><br /></td></tr>
<tr class="separator:af56c3c1ec9df98cd97e7cbae04e3c8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebe9f97f4b39d1e4e9a1284435984d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a0ebe9f97f4b39d1e4e9a1284435984d6">set_device_deallocator</a> (std::function&lt; void(void *, char const *)&gt; func)</td></tr>
<tr class="memdesc:a0ebe9f97f4b39d1e4e9a1284435984d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's device deallocator with the passed function (WITH Label).  <a href="#a0ebe9f97f4b39d1e4e9a1284435984d6">More...</a><br /></td></tr>
<tr class="separator:a0ebe9f97f4b39d1e4e9a1284435984d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3d7bb59cc9da9d19c0668034e7a68c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aec3d7bb59cc9da9d19c0668034e7a68c">set_timer_finalize</a> (std::function&lt; void()&gt; func)</td></tr>
<tr class="memdesc:aec3d7bb59cc9da9d19c0668034e7a68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's default timer finalization routine.  <a href="#aec3d7bb59cc9da9d19c0668034e7a68c">More...</a><br /></td></tr>
<tr class="separator:aec3d7bb59cc9da9d19c0668034e7a68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6b5768d519254c3cbcd84eca12d20b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aca6b5768d519254c3cbcd84eca12d20b">set_timer_init</a> (std::function&lt; void()&gt; func)</td></tr>
<tr class="memdesc:aca6b5768d519254c3cbcd84eca12d20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's default timer initialization routine.  <a href="#aca6b5768d519254c3cbcd84eca12d20b">More...</a><br /></td></tr>
<tr class="separator:aca6b5768d519254c3cbcd84eca12d20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc021bc87deafec03ab9c12f20a3ce0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#afc021bc87deafec03ab9c12f20a3ce0d">set_timer_start</a> (std::function&lt; void(char const *)&gt; func)</td></tr>
<tr class="memdesc:afc021bc87deafec03ab9c12f20a3ce0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's default routine to start an individual timer.  <a href="#afc021bc87deafec03ab9c12f20a3ce0d">More...</a><br /></td></tr>
<tr class="separator:afc021bc87deafec03ab9c12f20a3ce0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b1265406af3613ea8f2f0265200ce0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a12b1265406af3613ea8f2f0265200ce0">set_timer_stop</a> (std::function&lt; void(char const *)&gt; func)</td></tr>
<tr class="memdesc:a12b1265406af3613ea8f2f0265200ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's default routine to stop an individual timer.  <a href="#a12b1265406af3613ea8f2f0265200ce0">More...</a><br /></td></tr>
<tr class="separator:a12b1265406af3613ea8f2f0265200ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf58795a80dd0c09827a1a0a4ab6c2f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0">set_yakl_allocators_to_default</a> ()</td></tr>
<tr class="memdesc:abf58795a80dd0c09827a1a0a4ab6c2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all YAKL allocators to their defaults.  <a href="#abf58795a80dd0c09827a1a0a4ab6c2f0">More...</a><br /></td></tr>
<tr class="separator:abf58795a80dd0c09827a1a0a4ab6c2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757af9a71189e007f6afa0c8df1380cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a757af9a71189e007f6afa0c8df1380cf">timer_finalize</a> ()</td></tr>
<tr class="memdesc:a757af9a71189e007f6afa0c8df1380cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the YAKL timers.  <a href="#a757af9a71189e007f6afa0c8df1380cf">More...</a><br /></td></tr>
<tr class="separator:a757af9a71189e007f6afa0c8df1380cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548f5a6d111b18c6541bc82f3913345d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a548f5a6d111b18c6541bc82f3913345d">timer_init</a> ()</td></tr>
<tr class="memdesc:a548f5a6d111b18c6541bc82f3913345d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the YAKL timers.  <a href="#a548f5a6d111b18c6541bc82f3913345d">More...</a><br /></td></tr>
<tr class="separator:a548f5a6d111b18c6541bc82f3913345d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22876aa3d7b5d93e2cd9df0110a1f236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a22876aa3d7b5d93e2cd9df0110a1f236">timer_start</a> (char const *lab)</td></tr>
<tr class="memdesc:a22876aa3d7b5d93e2cd9df0110a1f236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a timer with the given string label. NOTE: Timers must be perfectly nested.  <a href="#a22876aa3d7b5d93e2cd9df0110a1f236">More...</a><br /></td></tr>
<tr class="separator:a22876aa3d7b5d93e2cd9df0110a1f236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a80175a29130a523e3d44585d046da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ae2a80175a29130a523e3d44585d046da">timer_stop</a> (char const *lab)</td></tr>
<tr class="memdesc:ae2a80175a29130a523e3d44585d046da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop a timer with the given string label. NOTE: Timers must be perfectly nested.  <a href="#ae2a80175a29130a523e3d44585d046da">More...</a><br /></td></tr>
<tr class="separator:ae2a80175a29130a523e3d44585d046da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139d110c621a453be18494b259d018ac"><td class="memTemplParams" colspan="2">template&lt;class real , unsigned int n&gt; </td></tr>
<tr class="memitem:a139d110c621a453be18494b259d018ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a139d110c621a453be18494b259d018ac">tridiagonal</a> (<a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;a, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;b, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;c, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;d)</td></tr>
<tr class="memdesc:a139d110c621a453be18494b259d018ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a <b>small</b> non-periodic tridiagional system.  <a href="#a139d110c621a453be18494b259d018ac">More...</a><br /></td></tr>
<tr class="separator:a139d110c621a453be18494b259d018ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74370b1a2867b7880d46785974edf739"><td class="memTemplParams" colspan="2">template&lt;class real , unsigned int n&gt; </td></tr>
<tr class="memitem:a74370b1a2867b7880d46785974edf739"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a74370b1a2867b7880d46785974edf739">tridiagonal_periodic</a> (<a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;a, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;b, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;c, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;d)</td></tr>
<tr class="memdesc:a74370b1a2867b7880d46785974edf739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a <b>small</b> periodic tridiagional solve. Click for more details.  <a href="#a74370b1a2867b7880d46785974edf739">More...</a><br /></td></tr>
<tr class="separator:a74370b1a2867b7880d46785974edf739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad595f0e5644733d5a1099347da7ce097"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ad595f0e5644733d5a1099347da7ce097">use_pool</a> ()</td></tr>
<tr class="memdesc:ad595f0e5644733d5a1099347da7ce097"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, then the pool allocator is being used for all device allocations.  <a href="#ad595f0e5644733d5a1099347da7ce097">More...</a><br /></td></tr>
<tr class="separator:ad595f0e5644733d5a1099347da7ce097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3763ece1d485b7596603c70a3199806f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a3763ece1d485b7596603c70a3199806f">yakl_mainproc</a> ()</td></tr>
<tr class="memdesc:a3763ece1d485b7596603c70a3199806f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, this is the main MPI process (task number == 0)  <a href="#a3763ece1d485b7596603c70a3199806f">More...</a><br /></td></tr>
<tr class="separator:a3763ece1d485b7596603c70a3199806f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dec4d21029959d4e9714098f1d22ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a26dec4d21029959d4e9714098f1d22ff">yakl_throw</a> (const char *msg)</td></tr>
<tr class="memdesc:a26dec4d21029959d4e9714098f1d22ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an error message. Works from the host or device.  <a href="#a26dec4d21029959d4e9714098f1d22ff">More...</a><br /></td></tr>
<tr class="separator:a26dec4d21029959d4e9714098f1d22ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a882566191a670e2f0126d900d57b5096"><td class="memItemLeft" align="right" valign="top">int constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a882566191a670e2f0126d900d57b5096">COLON</a> = std::numeric_limits&lt;int&gt;::min()</td></tr>
<tr class="memdesc:a882566191a670e2f0126d900d57b5096"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is just a convenience syntax for slicing <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects to make it clear in the user level code which dimensions are being sliced.  <a href="#a882566191a670e2f0126d900d57b5096">More...</a><br /></td></tr>
<tr class="separator:a882566191a670e2f0126d900d57b5096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab91278a820c2cc4b9134ff6a3ca49aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aab91278a820c2cc4b9134ff6a3ca49aa">INDEX_MAX</a> = std::numeric_limits&lt;<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&gt;::max()</td></tr>
<tr class="separator:aab91278a820c2cc4b9134ff6a3ca49aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfc7ca766420600e601da4ebf569715"><td class="memItemLeft" align="right" valign="top">int constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a2cfc7ca766420600e601da4ebf569715">memDefault</a> = <a class="el" href="namespaceyakl.html#aae8a8c910fec7cef7db68c9658c16405">memHost</a></td></tr>
<tr class="memdesc:a2cfc7ca766420600e601da4ebf569715"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user does not specify a memory space template parameter to <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a>, host is the default.  <a href="#a2cfc7ca766420600e601da4ebf569715">More...</a><br /></td></tr>
<tr class="separator:a2cfc7ca766420600e601da4ebf569715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c32aec58c61e7f870081477ceee883"><td class="memItemLeft" align="right" valign="top">int constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ac3c32aec58c61e7f870081477ceee883">memDevice</a> = 1</td></tr>
<tr class="memdesc:ac3c32aec58c61e7f870081477ceee883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a device memory address space for a <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> object.  <a href="#ac3c32aec58c61e7f870081477ceee883">More...</a><br /></td></tr>
<tr class="separator:ac3c32aec58c61e7f870081477ceee883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8a8c910fec7cef7db68c9658c16405"><td class="memItemLeft" align="right" valign="top">int constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aae8a8c910fec7cef7db68c9658c16405">memHost</a> = 2</td></tr>
<tr class="memdesc:aae8a8c910fec7cef7db68c9658c16405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a device memory address space for a <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> object.  <a href="#aae8a8c910fec7cef7db68c9658c16405">More...</a><br /></td></tr>
<tr class="separator:aae8a8c910fec7cef7db68c9658c16405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47db94fbc72aecf8652ed4110ac261b3"><td class="memItemLeft" align="right" valign="top">int constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a47db94fbc72aecf8652ed4110ac261b3">NETCDF_MODE_NEW</a> = NC_NOCLOBBER</td></tr>
<tr class="memdesc:a47db94fbc72aecf8652ed4110ac261b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells NetCDF the created file should not overwite a file of the same name.  <a href="#a47db94fbc72aecf8652ed4110ac261b3">More...</a><br /></td></tr>
<tr class="separator:a47db94fbc72aecf8652ed4110ac261b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50118344a55af6d8dfc3986babe217a"><td class="memItemLeft" align="right" valign="top">int constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ab50118344a55af6d8dfc3986babe217a">NETCDF_MODE_READ</a> = NC_NOWRITE</td></tr>
<tr class="memdesc:ab50118344a55af6d8dfc3986babe217a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells NetCDF the opened file should be opened for reading only.  <a href="#ab50118344a55af6d8dfc3986babe217a">More...</a><br /></td></tr>
<tr class="separator:ab50118344a55af6d8dfc3986babe217a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ae9f6d18b22a7370559830030426b6"><td class="memItemLeft" align="right" valign="top">int constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a50ae9f6d18b22a7370559830030426b6">NETCDF_MODE_REPLACE</a> = NC_CLOBBER</td></tr>
<tr class="memdesc:a50ae9f6d18b22a7370559830030426b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells NetCDF the created file should overwite a file of the same name.  <a href="#a50ae9f6d18b22a7370559830030426b6">More...</a><br /></td></tr>
<tr class="separator:a50ae9f6d18b22a7370559830030426b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dcebee867f90cf0075182b17a2696f"><td class="memItemLeft" align="right" valign="top">int constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#af0dcebee867f90cf0075182b17a2696f">NETCDF_MODE_WRITE</a> = NC_WRITE</td></tr>
<tr class="memdesc:af0dcebee867f90cf0075182b17a2696f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells NetCDF the opened file should be opened for reading and writing.  <a href="#af0dcebee867f90cf0075182b17a2696f">More...</a><br /></td></tr>
<tr class="separator:af0dcebee867f90cf0075182b17a2696f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d71a95af6da178ea2f606ae037edc0f"><td class="memItemLeft" align="right" valign="top">bool constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a2d71a95af6da178ea2f606ae037edc0f">streams_enabled</a> = false</td></tr>
<tr class="memdesc:a2d71a95af6da178ea2f606ae037edc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the CPP Macro YAKL_ENABLE_STREAMS is defined, then this bool is set to <code>true</code>  <a href="#a2d71a95af6da178ea2f606ae037edc0f">More...</a><br /></td></tr>
<tr class="separator:a2d71a95af6da178ea2f606ae037edc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade189cb0cee1c42b0753541817ea81cd"><td class="memItemLeft" align="right" valign="top">int constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ade189cb0cee1c42b0753541817ea81cd">styleC</a> = 1</td></tr>
<tr class="memdesc:ade189cb0cee1c42b0753541817ea81cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template parameter for <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> that specifies it should follow C-style behavior.  <a href="#ade189cb0cee1c42b0753541817ea81cd">More...</a><br /></td></tr>
<tr class="separator:ade189cb0cee1c42b0753541817ea81cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcb8b84f068cd42bfee6340d3e5536e"><td class="memItemLeft" align="right" valign="top">int constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aebcb8b84f068cd42bfee6340d3e5536e">styleDefault</a> = <a class="el" href="namespaceyakl.html#ade189cb0cee1c42b0753541817ea81cd">styleC</a></td></tr>
<tr class="memdesc:aebcb8b84f068cd42bfee6340d3e5536e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default style is C-style for <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects.  <a href="#aebcb8b84f068cd42bfee6340d3e5536e">More...</a><br /></td></tr>
<tr class="separator:aebcb8b84f068cd42bfee6340d3e5536e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86246e080d4fb462bf03deb2fdb2a467"><td class="memItemLeft" align="right" valign="top">int constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a86246e080d4fb462bf03deb2fdb2a467">styleFortran</a> = 2</td></tr>
<tr class="memdesc:a86246e080d4fb462bf03deb2fdb2a467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template parameter for <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> that specifies it should follow Fortran-style behavior.  <a href="#a86246e080d4fb462bf03deb2fdb2a467">More...</a><br /></td></tr>
<tr class="separator:a86246e080d4fb462bf03deb2fdb2a467"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a82d096ec8a882129a4c2b84f0f636d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d096ec8a882129a4c2b84f0f636d60">&#9670;&nbsp;</a></span>DefaultLaunchConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyakl.html#a82d096ec8a882129a4c2b84f0f636d60">yakl::DefaultLaunchConfig</a> = typedef <a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This launch configuration sets vector length to the device default and <code>B4B</code> to <code>false</code>. </p>

</div>
</div>
<a id="a9b33cfecadff879247cf80a54e825acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b33cfecadff879247cf80a54e825acd">&#9670;&nbsp;</a></span>DefaultLaunchConfigB4b</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyakl.html#a9b33cfecadff879247cf80a54e825acd">yakl::DefaultLaunchConfigB4b</a> = typedef <a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a>&lt;<a class="el" href="YAKL__LaunchConfig_8h.html#a9d0e22704e1de301961bf131053aed15">YAKL_DEFAULT_VECTOR_LEN</a>,true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>launch configuration sets B4B == true with the default <code>VecLen</code>. </p>

</div>
</div>
<a id="a172abcdd2d33fa36e969d80e6907173c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172abcdd2d33fa36e969d80e6907173c">&#9670;&nbsp;</a></span>index_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">yakl::index_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60ef5b6a07452eabddb6533b3091cef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ef5b6a07452eabddb6533b3091cef1">&#9670;&nbsp;</a></span>InnerHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structyakl_1_1InnerHandlerEmpty.html">yakl::InnerHandlerEmpty</a>  <a class="el" href="namespaceyakl.html#a60ef5b6a07452eabddb6533b3091cef1">yakl::InnerHandler</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This class is necessary for coordination of two-level parallelism. </p>
<p>A <a class="el" href="namespaceyakl.html#a60ef5b6a07452eabddb6533b3091cef1" title="This class is necessary for coordination of two-level parallelism. ">yakl::InnerHandler</a> object must be accepted as a parameter in the functor passed to <code>parallel_outer</code>, and it must be passed as a parameter to <code>parallel_inner</code>, <code>fence_inner</code>, and <code>single_inner</code>. An object of this class should never need to be explicitly created by the user. </p>

</div>
</div>
<a id="a0fff077cfae8547c78e7c76bdd45a465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fff077cfae8547c78e7c76bdd45a465">&#9670;&nbsp;</a></span>LaunchConfigB4b</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int VecLen = YAKL_DEFAULT_VECTOR_LEN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyakl.html#a0fff077cfae8547c78e7c76bdd45a465">yakl::LaunchConfigB4b</a> = typedef <a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a>&lt;VecLen,true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>launch configuration sets B4B == true with a user-specified <code>VecLen</code>. </p>

</div>
</div>
<a id="adabbe6df1f315d5e2c1874cf1be0acf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabbe6df1f315d5e2c1874cf1be0acf2">&#9670;&nbsp;</a></span>SArray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, unsigned D0, unsigned D1 = 1, unsigned D2 = 1, unsigned D3 = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">yakl::SArray</a> = typedef <a class="el" href="classyakl_1_1CSArray.html">CSArray</a>&lt;T,rank,D0,D1,D2,D3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most often, codes use the type define <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray. ">yakl::SArray</a> rather than <a class="el" href="classyakl_1_1CSArray.html" title="C-style array on the stack similar in nature to, e.g., float arr[ny][nx]; ">yakl::CSArray</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a744db414fb0ff8dbc17bcd08e05474da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744db414fb0ff8dbc17bcd08e05474da">&#9670;&nbsp;</a></span>alloc_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* yakl::alloc_device </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate on the device using YAKL's device allocator. </p>

</div>
</div>
<a id="a9cda355f1f737b5b613b6463232f3e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cda355f1f737b5b613b6463232f3e69">&#9670;&nbsp;</a></span>atomicAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::atomicAdd </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>[NON_B4B] yakl::atomicAdd(update,value)</code> atomically performs <code>update += value)</code> </p>
<p>Atomic instructions exist when multiple parallel threads are attempting to read-write to the same memory location at the same time. Min, max, and add will read a memory location perform a local operation, and then write a new value to that location. Atomic instructions ensure that the memory location has not changed between reading the memory location and writing a new value to that location.</p>
<p>Atomic min, max, and add are typically needed when you are writing to an array with fewer entries or dimensions than the number of threads in the <a class="el" href="namespaceyakl_1_1c.html#a81973df01907f317999d46b3d030a26f" title="[ASYNCHRONOUS] Launch the passed functor in parallel. ">parallel_for()</a> kernel launch. E.g.: </p><div class="fragment"><div class="line"><a class="code" href="namespaceyakl_1_1c.html#a81973df01907f317999d46b3d030a26f">parallel_for</a>( Bounds&lt;3&gt;(nz,ny,nx) , <a class="code" href="YAKL__defines_8h.html#af085ba3fa0c920e495675e86a53f7bbb">YAKL_LAMBDA</a> (<span class="keywordtype">int</span> k, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> i) {</div><div class="line">  <a class="code" href="namespaceyakl.html#a9cda355f1f737b5b613b6463232f3e69">yakl::atomicAdd</a>( average_column(k) , data(k,j,i) / (ny*nx) );</div><div class="line">});</div></div><!-- fragment --><p><b>IMPORTANT</b>: <a class="el" href="namespaceyakl.html#a9cda355f1f737b5b613b6463232f3e69" title="[NON_B4B] yakl::atomicAdd(update,value) atomically performs update += value) ">yakl::atomicAdd()</a> is not bitwise deterministic for floating point (FP) numbers, meaning there is no guarantee what order threads will perform FP addition. Since FP addition is not commutative, you cannot guarantee bitwise reproducible results from one run to the next. To alleviate this, please use pass <a class="el" href="namespaceyakl.html#a9b33cfecadff879247cf80a54e825acd" title="launch configuration sets B4B == true with the default VecLen. ">yakl::DefaultLaunchConfigB4b</a> to the <a class="el" href="namespaceyakl_1_1c.html#a81973df01907f317999d46b3d030a26f" title="[ASYNCHRONOUS] Launch the passed functor in parallel. ">parallel_for()</a> launcher, and when you want to force bitwise reproducibility define the CPP macro <code>YAKL_B4B</code>. <a class="el" href="namespaceyakl.html#a00f63fe7be70100d62b0e572967abea7" title="yakl::atomicMin(update,value) atomically performs update = min(update,value) ">yakl::atomicMin()</a> and <a class="el" href="namespaceyakl.html#a41cb894576efe9797212d7befde66c74" title="yakl::atomicMax(update,value) atomically performs update = max(update,value) ">yakl::atomicMax()</a> are both bitwise reproducible, so do not worry about those. This is only for <a class="el" href="namespaceyakl.html#a9cda355f1f737b5b613b6463232f3e69" title="[NON_B4B] yakl::atomicAdd(update,value) atomically performs update += value) ">yakl::atomicAdd()</a>. </p>

</div>
</div>
<a id="a41cb894576efe9797212d7befde66c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cb894576efe9797212d7befde66c74">&#9670;&nbsp;</a></span>atomicMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::atomicMax </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>yakl::atomicMax(update,value)</code> atomically performs <code>update = max(update,value)</code> </p>
<p>Atomic instructions exist when multiple parallel threads are attempting to read-write to the same memory location at the same time. Min, max, and add will read a memory location perform a local operation, and then write a new value to that location. Atomic instructions ensure that the memory location has not changed between reading the memory location and writing a new value to that location.</p>
<p>Atomic min, max, and add are typically needed when you are writing to an array with fewer entries or dimensions than the number of threads in the <a class="el" href="namespaceyakl_1_1c.html#a81973df01907f317999d46b3d030a26f" title="[ASYNCHRONOUS] Launch the passed functor in parallel. ">parallel_for()</a> kernel launch. E.g.: </p><div class="fragment"><div class="line"><a class="code" href="namespaceyakl_1_1c.html#a81973df01907f317999d46b3d030a26f">parallel_for</a>( Bounds&lt;3&gt;(nz,ny,nx) , <a class="code" href="YAKL__defines_8h.html#af085ba3fa0c920e495675e86a53f7bbb">YAKL_LAMBDA</a> (<span class="keywordtype">int</span> k, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> i) {</div><div class="line">  <a class="code" href="namespaceyakl.html#a9cda355f1f737b5b613b6463232f3e69">yakl::atomicAdd</a>( average_column(k) , data(k,j,i) / (ny*nx) );</div><div class="line">});</div></div><!-- fragment --><p><b>IMPORTANT</b>: <a class="el" href="namespaceyakl.html#a9cda355f1f737b5b613b6463232f3e69" title="[NON_B4B] yakl::atomicAdd(update,value) atomically performs update += value) ">yakl::atomicAdd()</a> is not bitwise deterministic for floating point (FP) numbers, meaning there is no guarantee what order threads will perform FP addition. Since FP addition is not commutative, you cannot guarantee bitwise reproducible results from one run to the next. To alleviate this, please use pass <a class="el" href="namespaceyakl.html#a9b33cfecadff879247cf80a54e825acd" title="launch configuration sets B4B == true with the default VecLen. ">yakl::DefaultLaunchConfigB4b</a> to the <a class="el" href="namespaceyakl_1_1c.html#a81973df01907f317999d46b3d030a26f" title="[ASYNCHRONOUS] Launch the passed functor in parallel. ">parallel_for()</a> launcher, and when you want to force bitwise reproducibility define the CPP macro <code>YAKL_B4B</code>. <a class="el" href="namespaceyakl.html#a00f63fe7be70100d62b0e572967abea7" title="yakl::atomicMin(update,value) atomically performs update = min(update,value) ">yakl::atomicMin()</a> and <a class="el" href="namespaceyakl.html#a41cb894576efe9797212d7befde66c74" title="yakl::atomicMax(update,value) atomically performs update = max(update,value) ">yakl::atomicMax()</a> are both bitwise reproducible, so do not worry about those. This is only for <a class="el" href="namespaceyakl.html#a9cda355f1f737b5b613b6463232f3e69" title="[NON_B4B] yakl::atomicAdd(update,value) atomically performs update += value) ">yakl::atomicAdd()</a>. </p>

</div>
</div>
<a id="a00f63fe7be70100d62b0e572967abea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f63fe7be70100d62b0e572967abea7">&#9670;&nbsp;</a></span>atomicMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::atomicMin </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>yakl::atomicMin(update,value)</code> atomically performs <code>update = min(update,value)</code> </p>
<p>Atomic instructions exist when multiple parallel threads are attempting to read-write to the same memory location at the same time. Min, max, and add will read a memory location perform a local operation, and then write a new value to that location. Atomic instructions ensure that the memory location has not changed between reading the memory location and writing a new value to that location.</p>
<p>Atomic min, max, and add are typically needed when you are writing to an array with fewer entries or dimensions than the number of threads in the <a class="el" href="namespaceyakl_1_1c.html#a81973df01907f317999d46b3d030a26f" title="[ASYNCHRONOUS] Launch the passed functor in parallel. ">parallel_for()</a> kernel launch. E.g.: </p><div class="fragment"><div class="line"><a class="code" href="namespaceyakl_1_1c.html#a81973df01907f317999d46b3d030a26f">parallel_for</a>( Bounds&lt;3&gt;(nz,ny,nx) , <a class="code" href="YAKL__defines_8h.html#af085ba3fa0c920e495675e86a53f7bbb">YAKL_LAMBDA</a> (<span class="keywordtype">int</span> k, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> i) {</div><div class="line">  <a class="code" href="namespaceyakl.html#a9cda355f1f737b5b613b6463232f3e69">yakl::atomicAdd</a>( average_column(k) , data(k,j,i) / (ny*nx) );</div><div class="line">});</div></div><!-- fragment --><p><b>IMPORTANT</b>: <a class="el" href="namespaceyakl.html#a9cda355f1f737b5b613b6463232f3e69" title="[NON_B4B] yakl::atomicAdd(update,value) atomically performs update += value) ">yakl::atomicAdd()</a> is not bitwise deterministic for floating point (FP) numbers, meaning there is no guarantee what order threads will perform FP addition. Since FP addition is not commutative, you cannot guarantee bitwise reproducible results from one run to the next. To alleviate this, please use pass <a class="el" href="namespaceyakl.html#a9b33cfecadff879247cf80a54e825acd" title="launch configuration sets B4B == true with the default VecLen. ">yakl::DefaultLaunchConfigB4b</a> to the <a class="el" href="namespaceyakl_1_1c.html#a81973df01907f317999d46b3d030a26f" title="[ASYNCHRONOUS] Launch the passed functor in parallel. ">parallel_for()</a> launcher, and when you want to force bitwise reproducibility define the CPP macro <code>YAKL_B4B</code>. <a class="el" href="namespaceyakl.html#a00f63fe7be70100d62b0e572967abea7" title="yakl::atomicMin(update,value) atomically performs update = min(update,value) ">yakl::atomicMin()</a> and <a class="el" href="namespaceyakl.html#a41cb894576efe9797212d7befde66c74" title="yakl::atomicMax(update,value) atomically performs update = max(update,value) ">yakl::atomicMax()</a> are both bitwise reproducible, so do not worry about those. This is only for <a class="el" href="namespaceyakl.html#a9cda355f1f737b5b613b6463232f3e69" title="[NON_B4B] yakl::atomicAdd(update,value) atomically performs update += value) ">yakl::atomicAdd()</a>. </p>

</div>
</div>
<a id="a7e01c087965b875ff55d3c7b2b4f4b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e01c087965b875ff55d3c7b2b4f4b00">&#9670;&nbsp;</a></span>check_last_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::check_last_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if an error has occurred on the device. </p>
<p>This is a no-op unless the <code>YAKL_DEBUG</code> CPP macro is defined </p>

</div>
</div>
<a id="a2e84c30ee165a8fa826468d357c959df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e84c30ee165a8fa826468d357c959df">&#9670;&nbsp;</a></span>create_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structyakl_1_1Stream.html">Stream</a> yakl::create_stream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and return a <a class="el" href="structyakl_1_1Stream.html" title="Implements the functionality of a stream for parallel kernel execution. If the Stream::create() metho...">Stream</a> object. It is guaranteed to not be the default stream. </p>

</div>
</div>
<a id="a5debd8fe5fff4f37c06e55648d138e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5debd8fe5fff4f37c06e55648d138e0c">&#9670;&nbsp;</a></span>fence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::fence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block the host code until all device code has completed. </p>

</div>
</div>
<a id="a823fefa19bd87dca7a0c66094130d6db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823fefa19bd87dca7a0c66094130d6db">&#9670;&nbsp;</a></span>fence_inner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::fence_inner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a60ef5b6a07452eabddb6533b3091cef1">InnerHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block inner threads until all inner threads have completed. </p>
<p>To be called inside yakl::parallel_outer <em>only</em>. Block the inner-level parallelism until all inner threads have reached this point. In CUDA and HIP, this is __syncthreads(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The <a class="el" href="namespaceyakl.html#a60ef5b6a07452eabddb6533b3091cef1" title="This class is necessary for coordination of two-level parallelism. ">yakl::InnerHandler</a> object create by yakl::parallel_outer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab42370df4914644cfd129ff6037c5c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42370df4914644cfd129ff6037c5c9f">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalize the YAKL runtime. </p>
<p>Best practice is to call <a class="el" href="namespaceyakl.html#a110195fb8259c05f75506e71aa5a792c" title="Determine if the YAKL runtime has been initialized. I.e., yakl::init() has been called without a corr...">yakl::isInitialized()</a> to ensure the YAKL runtime is initialized before calling this routine. That said, this routine <em>does</em> check to ensure the runtime is initialized for you. THREAD SAFE! </p>

</div>
</div>
<a id="a8afa807b3b1f4e331ece7954c94134fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afa807b3b1f4e331ece7954c94134fc">&#9670;&nbsp;</a></span>free_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::free_device </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free on the device using YAKL's device deallocator. </p>

</div>
</div>
<a id="aafe78b03b672a31b597b0b1e4cd97af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe78b03b672a31b597b0b1e4cd97af7">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1InitConfig.html">InitConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="classyakl_1_1InitConfig.html">InitConfig</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the YAKL runtime. </p>
<ol type="1">
<li>Determin if the pool allocator is to be used &amp; pool allocator parameters.</li>
<li>Initialize the pool if used.</li>
<li>Set the YAKL allocators and deallocators to default.</li>
<li>Initialize YAKL's timer calls to defaults.</li>
<li>Inspect the optional <a class="el" href="classyakl_1_1InitConfig.html" title="An object of this class can optionally be passed to yakl::init() to configure the initialization...">yakl::InitConfig</a> parameter to override default allocator, deallocator, and timer calls if requested.</li>
<li>Inform the user with device information. THREAD SAFE! <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>This <a class="el" href="classyakl_1_1InitConfig.html" title="An object of this class can optionally be passed to yakl::init() to configure the initialization...">yakl::InitConfig</a> object allows the user to override YAKL's default allocator, deallocator and timer calls from the start of the runtime. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>

</div>
</div>
<a id="a110195fb8259c05f75506e71aa5a792c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110195fb8259c05f75506e71aa5a792c">&#9670;&nbsp;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yakl::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the YAKL runtime has been initialized. I.e., <a class="el" href="namespaceyakl.html#aafe78b03b672a31b597b0b1e4cd97af7" title="Initialize the YAKL runtime. ">yakl::init()</a> has been called without a corresponding call to <a class="el" href="namespaceyakl.html#ab42370df4914644cfd129ff6037c5c9f" title="Finalize the YAKL runtime. ">yakl::finalize()</a>. </p>

</div>
</div>
<a id="a026f32705165108c6df7a07c502159d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026f32705165108c6df7a07c502159d3">&#9670;&nbsp;</a></span>memcpy_device_to_device()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::memcpy_device_to_device </td>
          <td>(</td>
          <td class="paramtype">T1 *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyakl_1_1Stream.html">Stream</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="structyakl_1_1Stream.html">Stream</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> on the device </p>

</div>
</div>
<a id="ab19e1e161899936f71ec3f025a5f8c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19e1e161899936f71ec3f025a5f8c9b">&#9670;&nbsp;</a></span>memcpy_device_to_device_void()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::memcpy_device_to_device_void </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyakl_1_1Stream.html">Stream</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="structyakl_1_1Stream.html">Stream</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[USE AT YOUR OWN RISK]: memcpy the specified number of <b>bytes</b> on the device </p>

</div>
</div>
<a id="a2a975062053c2a7335efd7203471e232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a975062053c2a7335efd7203471e232">&#9670;&nbsp;</a></span>memcpy_device_to_host()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::memcpy_device_to_host </td>
          <td>(</td>
          <td class="paramtype">T1 *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyakl_1_1Stream.html">Stream</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="structyakl_1_1Stream.html">Stream</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> from device to host </p>

</div>
</div>
<a id="a7231acaa29ce8f8419a1ef69a36dd679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7231acaa29ce8f8419a1ef69a36dd679">&#9670;&nbsp;</a></span>memcpy_host_to_device()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::memcpy_host_to_device </td>
          <td>(</td>
          <td class="paramtype">T1 *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyakl_1_1Stream.html">Stream</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="structyakl_1_1Stream.html">Stream</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> from host to device </p>

</div>
</div>
<a id="a7e3ccf876c613d1091413c21151aeeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3ccf876c613d1091413c21151aeeca">&#9670;&nbsp;</a></span>memcpy_host_to_host()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::memcpy_host_to_host </td>
          <td>(</td>
          <td class="paramtype">T1 *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> on the host </p>

</div>
</div>
<a id="a6dd2574081a93f391e588cab890f232f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd2574081a93f391e588cab890f232f">&#9670;&nbsp;</a></span>memcpy_host_to_host_void()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::memcpy_host_to_host_void </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[USE AT YOUR OWN RISK]: memcpy the specified number of <b>bytes</b> on the host </p>

</div>
</div>
<a id="a0636ffa1809f47534bd4f705bae0d857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0636ffa1809f47534bd4f705bae0d857">&#9670;&nbsp;</a></span>pentadiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int n, class real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::pentadiagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a <b>small</b> non-periodic pentadiagonal solve. Click for more details. </p>
<p>This is to be performed on a <code>SArray</code> / <code><a class="el" href="classyakl_1_1CSArray.html" title="C-style array on the stack similar in nature to, e.g., float arr[ny][nx]; ">CSArray</a></code> object allocated on the stack</p>
<p>Solves for a vector u of length n in the pentadiagonal linear system </p><div class="fragment"><div class="line">a_i u_(i-2) + b_i u_(i-1) + c_i u_i + d_i u_(i+1) + e_i u_(i+2) = f_i</div></div><!-- fragment --><p> input are the a, b, c, d, e, and f and they are not modified </p>

</div>
</div>
<a id="ad98637dc95c0af6d4860349ada34e262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98637dc95c0af6d4860349ada34e262">&#9670;&nbsp;</a></span>pentadiagonal_periodic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int n, class real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::pentadiagonal_periodic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a <b>small</b> periodic pentadiagonal solve. Click for more details. </p>
<p>This is to be performed on a <code>SArray</code> / <code><a class="el" href="classyakl_1_1CSArray.html" title="C-style array on the stack similar in nature to, e.g., float arr[ny][nx]; ">CSArray</a></code> object allocated on the stack</p>
<p>Solves for a vector u of length n in the pentadiagonal linear system </p><div class="fragment"><div class="line">a_i u_(i-2) + b_i u_(i-1) + c_i u_i + d_i u_(i+1) + e_i u_(i+2) = f_i</div></div><!-- fragment --><p> input are the a, b, c, d, e, and f and they are not modified </p>

</div>
</div>
<a id="a78754cc7984e3fde7592cf9a50faf53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78754cc7984e3fde7592cf9a50faf53d">&#9670;&nbsp;</a></span>record_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structyakl_1_1Event.html">Event</a> yakl::record_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structyakl_1_1Stream.html">Stream</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="structyakl_1_1Stream.html">Stream</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create, record, and return an event using the given stream. </p>

</div>
</div>
<a id="aca055f3e17da1b57c8966dfb9537b1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca055f3e17da1b57c8966dfb9537b1ab">&#9670;&nbsp;</a></span>set_device_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_device_allocator </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void *(size_t)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's device allocator with the passed function (No Label). </p>
<p>After overriding one of YAKL's allocators or deallocators, the passed function will be used until the user overrides it again or calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. ">yakl::set_yakl_allocators_to_default()</a>. There are overriding functions that accept labels for bookkeeping and debugging, and there are functions that do not use labels. </p>

</div>
</div>
<a id="a3c0af7565eb0e0d219ba91dff20b9e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0af7565eb0e0d219ba91dff20b9e90">&#9670;&nbsp;</a></span>set_device_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_device_allocator </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void *(size_t, char const *)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's device allocator with the passed function (WITH Label). </p>
<p>After overriding one of YAKL's allocators or deallocators, the passed function will be used until the user overrides it again or calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. ">yakl::set_yakl_allocators_to_default()</a>. There are overriding functions that accept labels for bookkeeping and debugging, and there are functions that do not use labels. </p>

</div>
</div>
<a id="af56c3c1ec9df98cd97e7cbae04e3c8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56c3c1ec9df98cd97e7cbae04e3c8de">&#9670;&nbsp;</a></span>set_device_deallocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_device_deallocator </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void *)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's device deallocator with the passed function (No Label). </p>
<p>After overriding one of YAKL's allocators or deallocators, the passed function will be used until the user overrides it again or calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. ">yakl::set_yakl_allocators_to_default()</a>. There are overriding functions that accept labels for bookkeeping and debugging, and there are functions that do not use labels. </p>

</div>
</div>
<a id="a0ebe9f97f4b39d1e4e9a1284435984d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebe9f97f4b39d1e4e9a1284435984d6">&#9670;&nbsp;</a></span>set_device_deallocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_device_deallocator </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void *, char const *)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's device deallocator with the passed function (WITH Label). </p>
<p>After overriding one of YAKL's allocators or deallocators, the passed function will be used until the user overrides it again or calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. ">yakl::set_yakl_allocators_to_default()</a>. There are overriding functions that accept labels for bookkeeping and debugging, and there are functions that do not use labels. </p>

</div>
</div>
<a id="aec3d7bb59cc9da9d19c0668034e7a68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3d7bb59cc9da9d19c0668034e7a68c">&#9670;&nbsp;</a></span>set_timer_finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_timer_finalize </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's default timer finalization routine. </p>

</div>
</div>
<a id="aca6b5768d519254c3cbcd84eca12d20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6b5768d519254c3cbcd84eca12d20b">&#9670;&nbsp;</a></span>set_timer_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_timer_init </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's default timer initialization routine. </p>

</div>
</div>
<a id="afc021bc87deafec03ab9c12f20a3ce0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc021bc87deafec03ab9c12f20a3ce0d">&#9670;&nbsp;</a></span>set_timer_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_timer_start </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(char const *)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's default routine to start an individual timer. </p>

</div>
</div>
<a id="a12b1265406af3613ea8f2f0265200ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b1265406af3613ea8f2f0265200ce0">&#9670;&nbsp;</a></span>set_timer_stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_timer_stop </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(char const *)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's default routine to stop an individual timer. </p>

</div>
</div>
<a id="abf58795a80dd0c09827a1a0a4ab6c2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf58795a80dd0c09827a1a0a4ab6c2f0">&#9670;&nbsp;</a></span>set_yakl_allocators_to_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_yakl_allocators_to_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return all YAKL allocators to their defaults. </p>
<p>If the user has not overridden YAKL's default allocators, then this has no effect. </p>

</div>
</div>
<a id="a757af9a71189e007f6afa0c8df1380cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757af9a71189e007f6afa0c8df1380cf">&#9670;&nbsp;</a></span>timer_finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::timer_finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalize the YAKL timers. </p>

</div>
</div>
<a id="a548f5a6d111b18c6541bc82f3913345d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548f5a6d111b18c6541bc82f3913345d">&#9670;&nbsp;</a></span>timer_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::timer_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the YAKL timers. </p>

</div>
</div>
<a id="a22876aa3d7b5d93e2cd9df0110a1f236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22876aa3d7b5d93e2cd9df0110a1f236">&#9670;&nbsp;</a></span>timer_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::timer_start </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>lab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a timer with the given string label. NOTE: Timers must be perfectly nested. </p>

</div>
</div>
<a id="ae2a80175a29130a523e3d44585d046da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a80175a29130a523e3d44585d046da">&#9670;&nbsp;</a></span>timer_stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::timer_stop </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>lab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop a timer with the given string label. NOTE: Timers must be perfectly nested. </p>

</div>
</div>
<a id="a139d110c621a453be18494b259d018ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139d110c621a453be18494b259d018ac">&#9670;&nbsp;</a></span>tridiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real , unsigned int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::tridiagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a <b>small</b> non-periodic tridiagional system. </p>
<p>This is to be performed on a <code>SArray</code> / <code><a class="el" href="classyakl_1_1CSArray.html" title="C-style array on the stack similar in nature to, e.g., float arr[ny][nx]; ">CSArray</a></code> object allocated on the stack</p>
<p>Solves a tridiagonal system with no boundary conditions of the form: </p><div class="fragment"><div class="line">[b(0)   c(0)  0    0      0      0    ] [x(0)  ] = [d(0)  ]</div><div class="line">[a(1)   b(1) c(1)  0      0      0    ] [x(1)  ] = [d(1)  ]</div><div class="line">[ 0     a(2) b(2) c(2)    0      0    ] [x(2)  ] = [d(2)  ]</div><div class="line">[ 0      0   ..  ..  ..   0      0    ] [ .    ] = [ .    ]</div><div class="line">[ 0      0      ..  ..  ..       0    ] [ .    ] = [ .    ]</div><div class="line">[ 0      0    0   a(n-2) b(n-2) c(n-2)] [x(n-2)] = [d(n-2)]</div><div class="line">[ 0      0    0    0     a(n-1) b(n-1)] [x(n-1)] = [d(n-1)]</div></div><!-- fragment --><p> This routine stores the result in <code>d()</code>, and as the signature indicates, it overwrites <code>b</code>, <code>c</code>, <code>d</code>.</p>
<p>This uses the Thomas algorithm. </p>

</div>
</div>
<a id="a74370b1a2867b7880d46785974edf739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74370b1a2867b7880d46785974edf739">&#9670;&nbsp;</a></span>tridiagonal_periodic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real , unsigned int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::tridiagonal_periodic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a <b>small</b> periodic tridiagional solve. Click for more details. </p>
<p>This is to be performed on a <code>SArray</code> / <code><a class="el" href="classyakl_1_1CSArray.html" title="C-style array on the stack similar in nature to, e.g., float arr[ny][nx]; ">CSArray</a></code> object allocated on the stack</p>
<p>Solves a tridiagonal system with periodic boundary conditions of the form: </p><div class="fragment"><div class="line">[b(0)   c(0)  0    0      0     a(0)  ] [x(0)  ] = [d(0)  ]</div><div class="line">[a(1)   b(1) c(1)  0      0      0    ] [x(1)  ] = [d(1)  ]</div><div class="line">[ 0     a(2) b(2) c(2)    0      0    ] [x(2)  ] = [d(2)  ]</div><div class="line">[ 0      0   ..  ..  ..   0      0    ] [ .    ] = [ .    ]</div><div class="line">[ 0      0      ..  ..  ..       0    ] [ .    ] = [ .    ]</div><div class="line">[ 0      0    0   a(n-2) b(n-2) c(n-2)] [x(n-2)] = [d(n-2)]</div><div class="line">[c(n-1)  0    0    0     a(n-1) b(n-1)] [x(n-1)] = [d(n-1)]</div></div><!-- fragment --><p> This routine stores the result in <code>d()</code>, and as the signature indicates, it overwrites <code>b</code>, <code>c</code>, <code>d</code></p>
<p>This uses the Thomas algorithm with the Sherman-Morrison formula. The Sherman-Morrison Formula is as follows:</p>
<p>Separate the tridiagonal + periodic matrix, <code>A</code>, into <code>(B + u*v^T)</code>, where <code>B</code> is strictly tridiagonal, and <code>u*v^T</code> accounts for the non-tridiagonal periodic BCs: </p><div class="fragment"><div class="line">u = [-b(0) , 0 , ... , 0 , c(n-1)    ]^T</div><div class="line">v = [1     , 0 , ... , 0 , -a(0)/b(0)]^T</div></div><!-- fragment --><p> Now we're solveing the system <code>(B + u*v^T)*x = d</code>, which is identical to <code>A*x=d</code>.</p>
<p>To get the solution, we solve two systems: </p><div class="fragment"><div class="line">(1) B*y=d</div><div class="line">(2) B*q=u</div></div><!-- fragment --><p> In this code, q is labeled as "tmp". Then, the answer is given by: </p><div class="fragment"><div class="line">x = y - ( (v^T*y) / (1 + v^T*q) ) * q</div></div><!-- fragment --><p> Unfortunately, periodic boundary conditions roughly double the amount of work in the tridiagonal solve </p>

</div>
</div>
<a id="ad595f0e5644733d5a1099347da7ce097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad595f0e5644733d5a1099347da7ce097">&#9670;&nbsp;</a></span>use_pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yakl::use_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, then the pool allocator is being used for all device allocations. </p>

</div>
</div>
<a id="a3763ece1d485b7596603c70a3199806f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3763ece1d485b7596603c70a3199806f">&#9670;&nbsp;</a></span>yakl_mainproc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yakl::yakl_mainproc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, this is the main MPI process (task number == 0) </p>
<p>If the CPP macro <code>HAVE_MPI</code> is defined, this tests the MPI rank ID. Otherwise, it always returns <code>true</code>. </p>

</div>
</div>
<a id="a26dec4d21029959d4e9714098f1d22ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26dec4d21029959d4e9714098f1d22ff">&#9670;&nbsp;</a></span>yakl_throw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::yakl_throw </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throw an error message. Works from the host or device. </p>
<p>On the host, this throws an exception. On the device, it prints and then forces the program to halt. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a882566191a670e2f0126d900d57b5096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882566191a670e2f0126d900d57b5096">&#9670;&nbsp;</a></span>COLON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int constexpr yakl::COLON = std::numeric_limits&lt;int&gt;::min()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is just a convenience syntax for slicing <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects to make it clear in the user level code which dimensions are being sliced. </p>

</div>
</div>
<a id="aab91278a820c2cc4b9134ff6a3ca49aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab91278a820c2cc4b9134ff6a3ca49aa">&#9670;&nbsp;</a></span>INDEX_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> constexpr yakl::INDEX_MAX = std::numeric_limits&lt;<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cfc7ca766420600e601da4ebf569715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfc7ca766420600e601da4ebf569715">&#9670;&nbsp;</a></span>memDefault</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int constexpr yakl::memDefault = <a class="el" href="namespaceyakl.html#aae8a8c910fec7cef7db68c9658c16405">memHost</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the user does not specify a memory space template parameter to <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a>, host is the default. </p>

</div>
</div>
<a id="ac3c32aec58c61e7f870081477ceee883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c32aec58c61e7f870081477ceee883">&#9670;&nbsp;</a></span>memDevice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int constexpr yakl::memDevice = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a device memory address space for a <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> object. </p>

</div>
</div>
<a id="aae8a8c910fec7cef7db68c9658c16405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8a8c910fec7cef7db68c9658c16405">&#9670;&nbsp;</a></span>memHost</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int constexpr yakl::memHost = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a device memory address space for a <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> object. </p>

</div>
</div>
<a id="a47db94fbc72aecf8652ed4110ac261b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47db94fbc72aecf8652ed4110ac261b3">&#9670;&nbsp;</a></span>NETCDF_MODE_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int constexpr yakl::NETCDF_MODE_NEW = NC_NOCLOBBER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells NetCDF the created file should not overwite a file of the same name. </p>

</div>
</div>
<a id="ab50118344a55af6d8dfc3986babe217a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50118344a55af6d8dfc3986babe217a">&#9670;&nbsp;</a></span>NETCDF_MODE_READ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int constexpr yakl::NETCDF_MODE_READ = NC_NOWRITE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells NetCDF the opened file should be opened for reading only. </p>

</div>
</div>
<a id="a50ae9f6d18b22a7370559830030426b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ae9f6d18b22a7370559830030426b6">&#9670;&nbsp;</a></span>NETCDF_MODE_REPLACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int constexpr yakl::NETCDF_MODE_REPLACE = NC_CLOBBER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells NetCDF the created file should overwite a file of the same name. </p>

</div>
</div>
<a id="af0dcebee867f90cf0075182b17a2696f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0dcebee867f90cf0075182b17a2696f">&#9670;&nbsp;</a></span>NETCDF_MODE_WRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int constexpr yakl::NETCDF_MODE_WRITE = NC_WRITE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells NetCDF the opened file should be opened for reading and writing. </p>

</div>
</div>
<a id="a2d71a95af6da178ea2f606ae037edc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d71a95af6da178ea2f606ae037edc0f">&#9670;&nbsp;</a></span>streams_enabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool constexpr yakl::streams_enabled = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the CPP Macro YAKL_ENABLE_STREAMS is defined, then this bool is set to <code>true</code> </p>

</div>
</div>
<a id="ade189cb0cee1c42b0753541817ea81cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade189cb0cee1c42b0753541817ea81cd">&#9670;&nbsp;</a></span>styleC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int constexpr yakl::styleC = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template parameter for <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> that specifies it should follow C-style behavior. </p>

</div>
</div>
<a id="aebcb8b84f068cd42bfee6340d3e5536e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcb8b84f068cd42bfee6340d3e5536e">&#9670;&nbsp;</a></span>styleDefault</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int constexpr yakl::styleDefault = <a class="el" href="namespaceyakl.html#ade189cb0cee1c42b0753541817ea81cd">styleC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default style is C-style for <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects. </p>

</div>
</div>
<a id="a86246e080d4fb462bf03deb2fdb2a467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86246e080d4fb462bf03deb2fdb2a467">&#9670;&nbsp;</a></span>styleFortran</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int constexpr yakl::styleFortran = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template parameter for <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> that specifies it should follow Fortran-style behavior. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
