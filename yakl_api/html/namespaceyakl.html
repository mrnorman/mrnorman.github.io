<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YAKL: yakl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YAKL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">yakl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceyakl_1_1c"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl_1_1c.html">c</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceyakl_1_1componentwise"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl_1_1componentwise.html">componentwise</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceyakl_1_1fortran"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl_1_1fortran.html">fortran</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceyakl_1_1intrinsics"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl_1_1intrinsics.html">intrinsics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This declares the <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> class. Please see the <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d" title="Template parameter for yakl::Array that specifies it should follow C-style behavior.">yakl::styleC</a> and <a class="el" href="namespaceyakl.html#a48029004bb42b7cc63974ca0433af63a" title="Template parameter for yakl::Array that specifies it should follow Fortran-style behavior.">yakl::styleFortran</a> template specializations for more detailed information about this class.  <a href="classyakl_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html">Array&lt; T, rank, myMem, styleC &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements the yakl:<a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> class with <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d" title="Template parameter for yakl::Array that specifies it should follow C-style behavior.">yakl::styleC</a> behavior, meaning all lower bounds for dimensions are zero, and index ordering is row-major, meaning the right-most index varies the fastest. IMPORTANT: Please see the <a class="el" href="classyakl_1_1ArrayBase.html" title="This class implements functionality common to both yakl::styleC and yakl::styleFortran Array objects....">yakl::ArrayBase</a> class because this class includes all of its functionality. click for more information.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleC_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleFortran_01_4.html">Array&lt; T, rank, myMem, styleFortran &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements the yakl:<a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a> class with <a class="el" href="namespaceyakl.html#a48029004bb42b7cc63974ca0433af63a" title="Template parameter for yakl::Array that specifies it should follow Fortran-style behavior.">yakl::styleFortran</a> behavior, meaning all lower bounds default to one but can be set to artibrary values, and index ordering is column-major, meaning the left-most index varies the fastest. IMPORTANT: Please see the <a class="el" href="classyakl_1_1ArrayBase.html" title="This class implements functionality common to both yakl::styleC and yakl::styleFortran Array objects....">yakl::ArrayBase</a> class because this class includes all of its functionality. click for more information.  <a href="classyakl_1_1Array_3_01T_00_01rank_00_01myMem_00_01styleFortran_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ArrayBase.html">ArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements functionality common to both <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d" title="Template parameter for yakl::Array that specifies it should follow C-style behavior.">yakl::styleC</a> and <a class="el" href="namespaceyakl.html#a48029004bb42b7cc63974ca0433af63a" title="Template parameter for yakl::Array that specifies it should follow Fortran-style behavior.">yakl::styleFortran</a> <code><a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">Array</a></code> objects. All <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects will have the functionality in this class. Click for more information.  <a href="classyakl_1_1ArrayBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyakl_1_1Bnd.html">Bnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a single bound for creating Fortran-style <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects. You can create and object of this class with a single integer, in which case the lower bound default to one, or you can use a pair of values, e.g., <code>{lower,upper}</code>, which will assign these as lower and upper bounds.  <a href="structyakl_1_1Bnd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Bnds.html">Bnds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds Fortran-style dimensions for using in creating <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects. You can pass an initializer list <code>{...}</code> or std::vector as a parameter to this type, and it can be converted to a <a class="el" href="classyakl_1_1Bnds.html" title="This class holds Fortran-style dimensions for using in creating yakl::Array objects....">yakl::Bnds</a> object. Each <code><a class="el" href="structyakl_1_1Bnd.html" title="Describes a single bound for creating Fortran-style yakl::Array objects. You can create and object of...">Bnd</a></code> element you pass can be an integer upper bound value (lower bound defaults to one) or a pair (<code>{lower,upper}</code>), since Fortran-style allows arbitrary lower bounds.  <a href="classyakl_1_1Bnds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1CSArray.html">CSArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This creates a C-style "Stack Array" (<a class="el" href="classyakl_1_1CSArray.html" title="This creates a C-style &quot;Stack Array&quot; (CSArray) class, which is typedefined to yakl::SArray....">CSArray</a>) class, which is typedefined to <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a>. It should be thought of as very similar to a C-style multi-dimensional array, <code>float arr[n1][n2][n3];</code>. That array as an <code>SArray</code> object would be created as <code><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a>&lt;float,3,n1,n2,n3&gt; arr;</code>, and it would be indexed as <code>arr(i1,i2,i3);</code>. For bounds checking, define the CPP macro <code>YAKL_DEBUG</code>. Dimensions sizes must be known at compile time, and data is placed on the stack of whatever context it is declared. When declared in a device <code>parallel_for</code> kernel, it is a thread-private array, meaning every thread has a separate copy of the array.  <a href="classyakl_1_1CSArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Dims.html">Dims</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds C-style dimensions for using in <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects. You can pass an initializer list <code>{...}</code> or std::vector as a parameter to this type, and it can be converted to a <a class="el" href="classyakl_1_1Dims.html" title="This class holds C-style dimensions for using in yakl::Array objects. You can pass an initializer lis...">yakl::Dims</a> object.  <a href="classyakl_1_1Dims.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1FSArray.html">FSArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This creates a Fortran-style "Stack Array" (<a class="el" href="classyakl_1_1FSArray.html" title="This creates a Fortran-style &quot;Stack Array&quot; (FSArray) class. It should be thought of as similar in nat...">FSArray</a>) class. It should be thought of as similar in nature to a C-style multi-dimensional array, <code>float arr[n1][n2][n3];</code>, except that it uses column-majore index ordering (left-most index varies the fastest), and it has lower bounds that default to <code>1</code> but can also be arbitrary. An example of declaring a yakl:<a class="el" href="classyakl_1_1FSArray.html" title="This creates a Fortran-style &quot;Stack Array&quot; (FSArray) class. It should be thought of as similar in nat...">FSArray</a> object is <code><a class="el" href="classyakl_1_1FSArray.html" title="This creates a Fortran-style &quot;Stack Array&quot; (FSArray) class. It should be thought of as similar in nat...">yakl::FSArray</a>&lt;float,3,<a class="el" href="classyakl_1_1SB.html" title="This specifyies a set of bounds for a dimension when declaring a yakl::FSArray. It takes either one o...">SB</a>&lt;n1&gt;,<a class="el" href="classyakl_1_1SB.html" title="This specifyies a set of bounds for a dimension when declaring a yakl::FSArray. It takes either one o...">SB</a>&lt;0,n2+1&gt;,<a class="el" href="classyakl_1_1SB.html" title="This specifyies a set of bounds for a dimension when declaring a yakl::FSArray. It takes either one o...">SB</a>&lt;n3&gt;&gt; arr;</code> The syntax is a bit ugly, but it's necessary to allow lower bounds other than <code>1</code>. The array declared just now will have lower bounds of 1, 0, and 1, respectively, and upper bounds of n1, n2+1, n3, respectively. For bounds checking, define the CPP macro <code>YAKL_DEBUG</code>. Dimensions sizes must be known at compile time, and data is placed on the stack of whatever context it is declared. When declared in a device <code>parallel_for</code> kernel, it is a thread-private array, meaning every thread has a separate copy of the array.  <a href="classyakl_1_1FSArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Gator.html">Gator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1InitConfig.html">InitConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>InnerHandlerEmpty</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is necessary for coordination of two-level parallelism. A <a class="el" href="namespaceyakl.html#a84fb5d8e747b5e4eff60360ad77fc402" title="This class is necessary for coordination of two-level parallelism. A yakl::InnerHandler object must b...">yakl::InnerHandler</a> object must be accepted as a parameter in the functor passed to <code>parallel_outer</code>, and it must be passed as a parameter to <code>parallel_inner</code>, <code>fence_inner</code>, and <code>single_inner</code>. An object of this class should never need to be explicitly created by the user. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class informs YAKL <code>parallel_for</code> and <code>parallel_outer</code> routines how to launch kernels. It contains two optional template parameters: (1) <code>VL</code>: When passed to <code>parallel_for</code>, this defines the inner looping size on the device (e.g. "block size" for CUDA and HIP. When passed to <code>parallel_outer</code>, this defines the maximum inner looping size on the device. (2) <code>B4B</code>: If this is set to <code>true</code>, then this tells <code>parallel_for</code> and <code>parallel_outer</code> to run the kernel serially (only when the <code>-DYAKL_B4B</code> CPP macro is defined) to enable bitwise determinism when desired for kernels with <a class="el" href="namespaceyakl.html#a9cda355f1f737b5b613b6463232f3e69" title="Atomically perform update += value.">yakl::atomicAdd</a> in them.  <a href="structyakl_1_1LaunchConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>LinearAllocator</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Pack.html">Pack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyakl_1_1PackIterConfig.html">PackIterConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object must be passed to <a class="el" href="namespaceyakl.html#a27535cdea6b17bbbdc6ccfe17808abb5" title="Perform a loop over the vector length size specified by the config parameter. If the config parameter...">yakl::iterate_over_pack</a> to inform that routine what the simd vector length is as well as whether to apply a SIMD pragma to the loop or not.  <a href="structyakl_1_1PackIterConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ParallelReduction.html">ParallelReduction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ParallelReduction_3_01T_00_01memDevice_00_01RED_01_4.html">ParallelReduction&lt; T, memDevice, RED &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ParallelReduction_3_01T_00_01memHost_00_01RED_01_4.html">ParallelReduction&lt; T, memHost, RED &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Random.html">Random</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1RealFFT1D.html">RealFFT1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1SB.html">SB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This specifyies a set of bounds for a dimension when declaring a <a class="el" href="classyakl_1_1FSArray.html" title="This creates a Fortran-style &quot;Stack Array&quot; (FSArray) class. It should be thought of as similar in nat...">yakl::FSArray</a>. It takes either one or two template parameter. Specifying one template parameter gives an upper bound and assumes a lower bound of <code>1</code>. E.g., <code><a class="el" href="classyakl_1_1SB.html" title="This specifyies a set of bounds for a dimension when declaring a yakl::FSArray. It takes either one o...">yakl::SB</a>&lt;nx&gt;</code> means a lower bound of <code>1</code> and an upper bound of <code>nx</code>. Specifying two template parameters gives a lower and an upper bound. E.g., <code><a class="el" href="classyakl_1_1SB.html" title="This specifyies a set of bounds for a dimension when declaring a yakl::FSArray. It takes either one o...">yakl::SB</a>&lt;0,nx+1&gt;</code> means a lower bound of <code>0</code> and an upper bound of <code>nx+1</code>.  <a href="classyakl_1_1SB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1ScalarLiveOut.html">ScalarLiveOut</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1SimpleNetCDF.html">SimpleNetCDF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1SimplePNetCDF.html">SimplePNetCDF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyakl_1_1Toney.html">Toney</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a172abcdd2d33fa36e969d80e6907173c"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a></td></tr>
<tr class="separator:a172abcdd2d33fa36e969d80e6907173c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabbe6df1f315d5e2c1874cf1be0acf2"><td class="memTemplParams" colspan="2">template&lt;class T , int rank, unsigned D0, unsigned D1 = 1, unsigned D2 = 1, unsigned D3 = 1&gt; </td></tr>
<tr class="memitem:adabbe6df1f315d5e2c1874cf1be0acf2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a> = <a class="el" href="classyakl_1_1CSArray.html">CSArray</a>&lt; T, rank, D0, D1, D2, D3 &gt;</td></tr>
<tr class="memdesc:adabbe6df1f315d5e2c1874cf1be0acf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most often, codes use the type define <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a> rather than <a class="el" href="classyakl_1_1CSArray.html" title="This creates a C-style &quot;Stack Array&quot; (CSArray) class, which is typedefined to yakl::SArray....">yakl::CSArray</a>.  <a href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">More...</a><br /></td></tr>
<tr class="separator:adabbe6df1f315d5e2c1874cf1be0acf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d096ec8a882129a4c2b84f0f636d60"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a82d096ec8a882129a4c2b84f0f636d60">DefaultLaunchConfig</a> = <a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a>&lt;&gt;</td></tr>
<tr class="memdesc:a82d096ec8a882129a4c2b84f0f636d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">This launch configuration sets vector length to the device default and <code>B4B</code> to <code>false</code>.  <a href="namespaceyakl.html#a82d096ec8a882129a4c2b84f0f636d60">More...</a><br /></td></tr>
<tr class="separator:a82d096ec8a882129a4c2b84f0f636d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fff077cfae8547c78e7c76bdd45a465"><td class="memTemplParams" colspan="2">template&lt;int VecLen = YAKL_DEFAULT_VECTOR_LEN&gt; </td></tr>
<tr class="memitem:a0fff077cfae8547c78e7c76bdd45a465"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a0fff077cfae8547c78e7c76bdd45a465">LaunchConfigB4b</a> = <a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a>&lt; VecLen, true &gt;</td></tr>
<tr class="memdesc:a0fff077cfae8547c78e7c76bdd45a465"><td class="mdescLeft">&#160;</td><td class="mdescRight">launch configuration sets B4B == true with a user-specified <code>VecLen</code>.  <a href="namespaceyakl.html#a0fff077cfae8547c78e7c76bdd45a465">More...</a><br /></td></tr>
<tr class="separator:a0fff077cfae8547c78e7c76bdd45a465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b33cfecadff879247cf80a54e825acd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a9b33cfecadff879247cf80a54e825acd">DefaultLaunchConfigB4b</a> = <a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a>&lt; <a class="el" href="YAKL__LaunchConfig_8h.html#a9d0e22704e1de301961bf131053aed15">YAKL_DEFAULT_VECTOR_LEN</a>, true &gt;</td></tr>
<tr class="memdesc:a9b33cfecadff879247cf80a54e825acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">launch configuration sets B4B == true with the default <code>VecLen</code>.  <a href="namespaceyakl.html#a9b33cfecadff879247cf80a54e825acd">More...</a><br /></td></tr>
<tr class="separator:a9b33cfecadff879247cf80a54e825acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fb5d8e747b5e4eff60360ad77fc402"><td class="memItemLeft" align="right" valign="top">typedef struct yakl::InnerHandlerEmpty&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a84fb5d8e747b5e4eff60360ad77fc402">InnerHandler</a></td></tr>
<tr class="memdesc:a84fb5d8e747b5e4eff60360ad77fc402"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is necessary for coordination of two-level parallelism. A <a class="el" href="namespaceyakl.html#a84fb5d8e747b5e4eff60360ad77fc402" title="This class is necessary for coordination of two-level parallelism. A yakl::InnerHandler object must b...">yakl::InnerHandler</a> object must be accepted as a parameter in the functor passed to <code>parallel_outer</code>, and it must be passed as a parameter to <code>parallel_inner</code>, <code>fence_inner</code>, and <code>single_inner</code>. An object of this class should never need to be explicitly created by the user.  <a href="namespaceyakl.html#a84fb5d8e747b5e4eff60360ad77fc402">More...</a><br /></td></tr>
<tr class="separator:a84fb5d8e747b5e4eff60360ad77fc402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2cdeccf05329f3fcc2ab27d8cf0399"><td class="memTemplParams" colspan="2">template&lt;class T , int memSpace&gt; </td></tr>
<tr class="memitem:aae2cdeccf05329f3fcc2ab27d8cf0399"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aae2cdeccf05329f3fcc2ab27d8cf0399">ParallelMin</a> = <a class="el" href="classyakl_1_1ParallelReduction.html">ParallelReduction</a>&lt; T, memSpace, YAKL_REDUCTION_MIN &gt;</td></tr>
<tr class="separator:aae2cdeccf05329f3fcc2ab27d8cf0399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963e440ba3b79d2250aea69749f844fd"><td class="memTemplParams" colspan="2">template&lt;class T , int memSpace&gt; </td></tr>
<tr class="memitem:a963e440ba3b79d2250aea69749f844fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a963e440ba3b79d2250aea69749f844fd">ParallelMax</a> = <a class="el" href="classyakl_1_1ParallelReduction.html">ParallelReduction</a>&lt; T, memSpace, YAKL_REDUCTION_MAX &gt;</td></tr>
<tr class="separator:a963e440ba3b79d2250aea69749f844fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0eae445a17795ed61a17745902a7bf"><td class="memTemplParams" colspan="2">template&lt;class T , int memSpace&gt; </td></tr>
<tr class="memitem:a6a0eae445a17795ed61a17745902a7bf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a6a0eae445a17795ed61a17745902a7bf">ParallelSum</a> = <a class="el" href="classyakl_1_1ParallelReduction.html">ParallelReduction</a>&lt; T, memSpace, YAKL_REDUCTION_SUM &gt;</td></tr>
<tr class="separator:a6a0eae445a17795ed61a17745902a7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbeb29ba06bb6b58bb0a5672575fd3a"><td class="memTemplParams" colspan="2">template&lt;class T , int memSpace&gt; </td></tr>
<tr class="memitem:a6bbeb29ba06bb6b58bb0a5672575fd3a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a6bbeb29ba06bb6b58bb0a5672575fd3a">ParallelProd</a> = <a class="el" href="classyakl_1_1ParallelReduction.html">ParallelReduction</a>&lt; T, memSpace, YAKL_REDUCTION_PROD &gt;</td></tr>
<tr class="separator:a6bbeb29ba06bb6b58bb0a5672575fd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad595f0e5644733d5a1099347da7ce097"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ad595f0e5644733d5a1099347da7ce097">use_pool</a> ()</td></tr>
<tr class="memdesc:ad595f0e5644733d5a1099347da7ce097"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, then the pool allocator is being used for all device allocations.  <a href="namespaceyakl.html#ad595f0e5644733d5a1099347da7ce097">More...</a><br /></td></tr>
<tr class="separator:ad595f0e5644733d5a1099347da7ce097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf58795a80dd0c09827a1a0a4ab6c2f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0">set_yakl_allocators_to_default</a> ()</td></tr>
<tr class="memdesc:abf58795a80dd0c09827a1a0a4ab6c2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all YAKL allocators to their defaults. If the user has not overridden YAKL's default allocators, then this has no effect.  <a href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0">More...</a><br /></td></tr>
<tr class="separator:abf58795a80dd0c09827a1a0a4ab6c2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa47d0678c8772a89e8f37bba484814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#acfa47d0678c8772a89e8f37bba484814">set_host_allocator</a> (std::function&lt; void *(size_t)&gt; func)</td></tr>
<tr class="memdesc:acfa47d0678c8772a89e8f37bba484814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's host allocator with the passed function (No Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;.  <a href="namespaceyakl.html#acfa47d0678c8772a89e8f37bba484814">More...</a><br /></td></tr>
<tr class="separator:acfa47d0678c8772a89e8f37bba484814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca055f3e17da1b57c8966dfb9537b1ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aca055f3e17da1b57c8966dfb9537b1ab">set_device_allocator</a> (std::function&lt; void *(size_t)&gt; func)</td></tr>
<tr class="memdesc:aca055f3e17da1b57c8966dfb9537b1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's device allocator with the passed function (No Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;.  <a href="namespaceyakl.html#aca055f3e17da1b57c8966dfb9537b1ab">More...</a><br /></td></tr>
<tr class="separator:aca055f3e17da1b57c8966dfb9537b1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b2f2f9068a7f1d81422b0920e7995"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a4d5b2f2f9068a7f1d81422b0920e7995">set_host_deallocator</a> (std::function&lt; void(void *)&gt; func)</td></tr>
<tr class="memdesc:a4d5b2f2f9068a7f1d81422b0920e7995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's host deallocator with the passed function (No Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;.  <a href="namespaceyakl.html#a4d5b2f2f9068a7f1d81422b0920e7995">More...</a><br /></td></tr>
<tr class="separator:a4d5b2f2f9068a7f1d81422b0920e7995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56c3c1ec9df98cd97e7cbae04e3c8de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#af56c3c1ec9df98cd97e7cbae04e3c8de">set_device_deallocator</a> (std::function&lt; void(void *)&gt; func)</td></tr>
<tr class="memdesc:af56c3c1ec9df98cd97e7cbae04e3c8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's device deallocator with the passed function (No Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;.  <a href="namespaceyakl.html#af56c3c1ec9df98cd97e7cbae04e3c8de">More...</a><br /></td></tr>
<tr class="separator:af56c3c1ec9df98cd97e7cbae04e3c8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457a1f8b0af529710be9fd890682dfcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a457a1f8b0af529710be9fd890682dfcd">set_host_allocator</a> (std::function&lt; void *(size_t, char const *)&gt; func)</td></tr>
<tr class="memdesc:a457a1f8b0af529710be9fd890682dfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's host allocator with the passed function (WITH Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;.  <a href="namespaceyakl.html#a457a1f8b0af529710be9fd890682dfcd">More...</a><br /></td></tr>
<tr class="separator:a457a1f8b0af529710be9fd890682dfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0af7565eb0e0d219ba91dff20b9e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a3c0af7565eb0e0d219ba91dff20b9e90">set_device_allocator</a> (std::function&lt; void *(size_t, char const *)&gt; func)</td></tr>
<tr class="memdesc:a3c0af7565eb0e0d219ba91dff20b9e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's device allocator with the passed function (WITH Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;.  <a href="namespaceyakl.html#a3c0af7565eb0e0d219ba91dff20b9e90">More...</a><br /></td></tr>
<tr class="separator:a3c0af7565eb0e0d219ba91dff20b9e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0e98e23e4b273339d90de69b1659ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a3b0e98e23e4b273339d90de69b1659ca">set_host_deallocator</a> (std::function&lt; void(void *, char const *)&gt; func)</td></tr>
<tr class="memdesc:a3b0e98e23e4b273339d90de69b1659ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's host deallocator with the passed function (WITH Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;.  <a href="namespaceyakl.html#a3b0e98e23e4b273339d90de69b1659ca">More...</a><br /></td></tr>
<tr class="separator:a3b0e98e23e4b273339d90de69b1659ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebe9f97f4b39d1e4e9a1284435984d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a0ebe9f97f4b39d1e4e9a1284435984d6">set_device_deallocator</a> (std::function&lt; void(void *, char const *)&gt; func)</td></tr>
<tr class="memdesc:a0ebe9f97f4b39d1e4e9a1284435984d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's device deallocator with the passed function (WITH Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;.  <a href="namespaceyakl.html#a0ebe9f97f4b39d1e4e9a1284435984d6">More...</a><br /></td></tr>
<tr class="separator:a0ebe9f97f4b39d1e4e9a1284435984d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f63fe7be70100d62b0e572967abea7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a00f63fe7be70100d62b0e572967abea7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a00f63fe7be70100d62b0e572967abea7">atomicMin</a> (T &amp;update, T value)</td></tr>
<tr class="memdesc:a00f63fe7be70100d62b0e572967abea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically perform update = min(update,value)  <a href="namespaceyakl.html#a00f63fe7be70100d62b0e572967abea7">More...</a><br /></td></tr>
<tr class="separator:a00f63fe7be70100d62b0e572967abea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cb894576efe9797212d7befde66c74"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a41cb894576efe9797212d7befde66c74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a41cb894576efe9797212d7befde66c74">atomicMax</a> (T &amp;update, T value)</td></tr>
<tr class="memdesc:a41cb894576efe9797212d7befde66c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically perform update = max(update,value)  <a href="namespaceyakl.html#a41cb894576efe9797212d7befde66c74">More...</a><br /></td></tr>
<tr class="separator:a41cb894576efe9797212d7befde66c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cda355f1f737b5b613b6463232f3e69"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9cda355f1f737b5b613b6463232f3e69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a9cda355f1f737b5b613b6463232f3e69">atomicAdd</a> (T &amp;update, T value)</td></tr>
<tr class="memdesc:a9cda355f1f737b5b613b6463232f3e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically perform update += value.  <a href="namespaceyakl.html#a9cda355f1f737b5b613b6463232f3e69">More...</a><br /></td></tr>
<tr class="separator:a9cda355f1f737b5b613b6463232f3e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dec4d21029959d4e9714098f1d22ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a26dec4d21029959d4e9714098f1d22ff">yakl_throw</a> (const char *msg)</td></tr>
<tr class="memdesc:a26dec4d21029959d4e9714098f1d22ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an error message. On the host, this throws an exception. On the device, it prints and then forces the program to halt.  <a href="namespaceyakl.html#a26dec4d21029959d4e9714098f1d22ff">More...</a><br /></td></tr>
<tr class="separator:a26dec4d21029959d4e9714098f1d22ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e01c087965b875ff55d3c7b2b4f4b00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a7e01c087965b875ff55d3c7b2b4f4b00">check_last_error</a> ()</td></tr>
<tr class="memdesc:a7e01c087965b875ff55d3c7b2b4f4b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if an error has occurred on the device.  <a href="namespaceyakl.html#a7e01c087965b875ff55d3c7b2b4f4b00">More...</a><br /></td></tr>
<tr class="separator:a7e01c087965b875ff55d3c7b2b4f4b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3763ece1d485b7596603c70a3199806f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a3763ece1d485b7596603c70a3199806f">yakl_mainproc</a> ()</td></tr>
<tr class="memdesc:a3763ece1d485b7596603c70a3199806f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, this is the main MPI process (task number == 0)  <a href="namespaceyakl.html#a3763ece1d485b7596603c70a3199806f">More...</a><br /></td></tr>
<tr class="separator:a3763ece1d485b7596603c70a3199806f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5debd8fe5fff4f37c06e55648d138e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a5debd8fe5fff4f37c06e55648d138e0c">fence</a> ()</td></tr>
<tr class="memdesc:a5debd8fe5fff4f37c06e55648d138e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the host code until all device code has completed.  <a href="namespaceyakl.html#a5debd8fe5fff4f37c06e55648d138e0c">More...</a><br /></td></tr>
<tr class="separator:a5debd8fe5fff4f37c06e55648d138e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823fefa19bd87dca7a0c66094130d6db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a823fefa19bd87dca7a0c66094130d6db">fence_inner</a> (<a class="el" href="namespaceyakl.html#a84fb5d8e747b5e4eff60360ad77fc402">InnerHandler</a> &amp;handler)</td></tr>
<tr class="memdesc:a823fefa19bd87dca7a0c66094130d6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be called inside yakl::parallel_outer <em>only</em>. Block the inner-level parallelism until all inner threads have reached this point. In CUDA and HIP, this is __syncthreads(). Click for more info.  <a href="namespaceyakl.html#a823fefa19bd87dca7a0c66094130d6db">More...</a><br /></td></tr>
<tr class="separator:a823fefa19bd87dca7a0c66094130d6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42370df4914644cfd129ff6037c5c9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ab42370df4914644cfd129ff6037c5c9f">finalize</a> ()</td></tr>
<tr class="memdesc:ab42370df4914644cfd129ff6037c5c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the YAKL runtime. Best practice is to call <a class="el" href="namespaceyakl.html#a110195fb8259c05f75506e71aa5a792c" title="Determine if the YAKL runtime has been initialized. I.e., yakl::init() has been called without a corr...">yakl::isInitialized()</a> to ensure the YAKL runtime is initialized before calling this routine. That said, this routine <em>does</em> check to ensure the runtime is initialized for you. THREAD SAFE!  <a href="namespaceyakl.html#ab42370df4914644cfd129ff6037c5c9f">More...</a><br /></td></tr>
<tr class="separator:ab42370df4914644cfd129ff6037c5c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110195fb8259c05f75506e71aa5a792c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a110195fb8259c05f75506e71aa5a792c">isInitialized</a> ()</td></tr>
<tr class="memdesc:a110195fb8259c05f75506e71aa5a792c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the YAKL runtime has been initialized. I.e., <a class="el" href="namespaceyakl.html#aafe78b03b672a31b597b0b1e4cd97af7" title="Initialize the YAKL runtime. (1) Determin if the pool allocator is to be used &amp; pool allocator parame...">yakl::init()</a> has been called without a corresponding call to <a class="el" href="namespaceyakl.html#ab42370df4914644cfd129ff6037c5c9f" title="Finalize the YAKL runtime. Best practice is to call yakl::isInitialized() to ensure the YAKL runtime ...">yakl::finalize()</a>.  <a href="namespaceyakl.html#a110195fb8259c05f75506e71aa5a792c">More...</a><br /></td></tr>
<tr class="separator:a110195fb8259c05f75506e71aa5a792c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe78b03b672a31b597b0b1e4cd97af7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aafe78b03b672a31b597b0b1e4cd97af7">init</a> (<a class="el" href="classyakl_1_1InitConfig.html">InitConfig</a> config=<a class="el" href="classyakl_1_1InitConfig.html">InitConfig</a>())</td></tr>
<tr class="memdesc:aafe78b03b672a31b597b0b1e4cd97af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the YAKL runtime. (1) Determin if the pool allocator is to be used &amp; pool allocator parameters. (2) Initialize the pool if used. (3) Set the YAKL allocators and deallocators to default. (4) Initialize YAKL's timer calls to defaults. (5) Inspect the optional <a class="el" href="classyakl_1_1InitConfig.html">yakl::InitConfig</a> parameter to override default allocator, deallocator, and timer calls if requested. (6) Allocate YAKL's functor buffer for appropriate backends. (6) Inform the user with device information. THREAD SAFE!  <a href="namespaceyakl.html#aafe78b03b672a31b597b0b1e4cd97af7">More...</a><br /></td></tr>
<tr class="separator:aafe78b03b672a31b597b0b1e4cd97af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3ccf876c613d1091413c21151aeeca"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a7e3ccf876c613d1091413c21151aeeca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a7e3ccf876c613d1091413c21151aeeca">memcpy_host_to_host</a> (T1 *dst, T2 *src, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> elems)</td></tr>
<tr class="memdesc:a7e3ccf876c613d1091413c21151aeeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> on the host  <a href="namespaceyakl.html#a7e3ccf876c613d1091413c21151aeeca">More...</a><br /></td></tr>
<tr class="separator:a7e3ccf876c613d1091413c21151aeeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd2574081a93f391e588cab890f232f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a6dd2574081a93f391e588cab890f232f">memcpy_host_to_host_void</a> (void *dst, void *src, size_t bytes)</td></tr>
<tr class="memdesc:a6dd2574081a93f391e588cab890f232f"><td class="mdescLeft">&#160;</td><td class="mdescRight">[USE AT YOUR OWN RISK]: memcpy the specified number of <b>bytes</b> on the host  <a href="namespaceyakl.html#a6dd2574081a93f391e588cab890f232f">More...</a><br /></td></tr>
<tr class="separator:a6dd2574081a93f391e588cab890f232f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c164d629474f143bb61e540e59f34c7"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a7c164d629474f143bb61e540e59f34c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a7c164d629474f143bb61e540e59f34c7">memcpy_device_to_host</a> (T1 *dst, T2 *src, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> elems)</td></tr>
<tr class="memdesc:a7c164d629474f143bb61e540e59f34c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> from device to host  <a href="namespaceyakl.html#a7c164d629474f143bb61e540e59f34c7">More...</a><br /></td></tr>
<tr class="separator:a7c164d629474f143bb61e540e59f34c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae986e2511210cf25cfee6701d65003c4"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ae986e2511210cf25cfee6701d65003c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ae986e2511210cf25cfee6701d65003c4">memcpy_host_to_device</a> (T1 *dst, T2 *src, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> elems)</td></tr>
<tr class="memdesc:ae986e2511210cf25cfee6701d65003c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> from host to device  <a href="namespaceyakl.html#ae986e2511210cf25cfee6701d65003c4">More...</a><br /></td></tr>
<tr class="separator:ae986e2511210cf25cfee6701d65003c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cd629fc27eb6cd1e237c1172e5c291"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa3cd629fc27eb6cd1e237c1172e5c291"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aa3cd629fc27eb6cd1e237c1172e5c291">memcpy_device_to_device</a> (T1 *dst, T2 *src, <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> elems)</td></tr>
<tr class="memdesc:aa3cd629fc27eb6cd1e237c1172e5c291"><td class="mdescLeft">&#160;</td><td class="mdescRight">[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> on the device  <a href="namespaceyakl.html#aa3cd629fc27eb6cd1e237c1172e5c291">More...</a><br /></td></tr>
<tr class="separator:aa3cd629fc27eb6cd1e237c1172e5c291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67a0305587b9e57dc519098a1e82eac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#af67a0305587b9e57dc519098a1e82eac">memcpy_device_to_device_void</a> (void *dst, void *src, size_t bytes)</td></tr>
<tr class="memdesc:af67a0305587b9e57dc519098a1e82eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">[USE AT YOUR OWN RISK]: memcpy the specified number of <b>bytes</b> on the device  <a href="namespaceyakl.html#af67a0305587b9e57dc519098a1e82eac">More...</a><br /></td></tr>
<tr class="separator:af67a0305587b9e57dc519098a1e82eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ed1845d91a0b667e4700963215a2f9"><td class="memTemplParams" colspan="2">template&lt;class T , int rank, int myMem, int myStyle, class I &gt; </td></tr>
<tr class="memitem:a64ed1845d91a0b667e4700963215a2f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a64ed1845d91a0b667e4700963215a2f9">memset</a> (<a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, rank, myMem, myStyle &gt; &amp;arr, I val)</td></tr>
<tr class="memdesc:a64ed1845d91a0b667e4700963215a2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">[Deprecated for user use]: Please use operator= instead. Set a <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> object to the given value. Valid for host or device arrays.  <a href="namespaceyakl.html#a64ed1845d91a0b667e4700963215a2f9">More...</a><br /></td></tr>
<tr class="separator:a64ed1845d91a0b667e4700963215a2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07a6bcba1f58d2ad541b1541290bfa6"><td class="memTemplParams" colspan="2">template&lt;class T , int rank, class B0 , class B1 , class B2 , class B3 , class I &gt; </td></tr>
<tr class="memitem:af07a6bcba1f58d2ad541b1541290bfa6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#af07a6bcba1f58d2ad541b1541290bfa6">memset</a> (<a class="el" href="classyakl_1_1FSArray.html">FSArray</a>&lt; T, rank, B0, B1, B2, B3 &gt; &amp;arr, I val)</td></tr>
<tr class="memdesc:af07a6bcba1f58d2ad541b1541290bfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">[Deprecated for user use]: Please use operator= instead. Set a <a class="el" href="classyakl_1_1FSArray.html" title="This creates a Fortran-style &quot;Stack Array&quot; (FSArray) class. It should be thought of as similar in nat...">yakl::FSArray</a> object to the given value. Valid in a host or device context.  <a href="namespaceyakl.html#af07a6bcba1f58d2ad541b1541290bfa6">More...</a><br /></td></tr>
<tr class="separator:af07a6bcba1f58d2ad541b1541290bfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780d1db197827e123582a1e8a29b1848"><td class="memTemplParams" colspan="2">template&lt;class T , int rank, unsigned D0, unsigned D1, unsigned D2, unsigned D3, class I &gt; </td></tr>
<tr class="memitem:a780d1db197827e123582a1e8a29b1848"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a780d1db197827e123582a1e8a29b1848">memset</a> (<a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; T, rank, D0, D1, D2, D3 &gt; &amp;arr, I val)</td></tr>
<tr class="memdesc:a780d1db197827e123582a1e8a29b1848"><td class="mdescLeft">&#160;</td><td class="mdescRight">[Deprecated for user use]: Please use operator= instead. Set a <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a> object to the given value. Valid in a host or device context.  <a href="namespaceyakl.html#a780d1db197827e123582a1e8a29b1848">More...</a><br /></td></tr>
<tr class="separator:a780d1db197827e123582a1e8a29b1848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27535cdea6b17bbbdc6ccfe17808abb5"><td class="memTemplParams" colspan="2">template&lt;class F , unsigned int N, bool SIMD = false&gt; </td></tr>
<tr class="memitem:a27535cdea6b17bbbdc6ccfe17808abb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a27535cdea6b17bbbdc6ccfe17808abb5">iterate_over_pack</a> (F const &amp;f, <a class="el" href="structyakl_1_1PackIterConfig.html">PackIterConfig</a>&lt; N, SIMD &gt; config)</td></tr>
<tr class="memdesc:a27535cdea6b17bbbdc6ccfe17808abb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a loop over the vector length size specified by the config parameter. If the config parameter also specifies that the SIMD template parameter is true, then apply SIMD pragmas. IMPORTANT: For the functor passed to this routine, please use [&amp;] syntax, <em>not</em> YAKL_LAMBDA.  <a href="namespaceyakl.html#a27535cdea6b17bbbdc6ccfe17808abb5">More...</a><br /></td></tr>
<tr class="separator:a27535cdea6b17bbbdc6ccfe17808abb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11b06b59b7775329b01bea078bd1999"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </td></tr>
<tr class="memitem:ac11b06b59b7775329b01bea078bd1999"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ac11b06b59b7775329b01bea078bd1999">operator+</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; lhs, TLOC val)</td></tr>
<tr class="separator:ac11b06b59b7775329b01bea078bd1999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3791e8eabfc1d99f38d62a6f4ba60604"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </td></tr>
<tr class="memitem:a3791e8eabfc1d99f38d62a6f4ba60604"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a3791e8eabfc1d99f38d62a6f4ba60604">operator+</a> (TLOC val, <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="separator:a3791e8eabfc1d99f38d62a6f4ba60604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4392180bc260915d323e21d3f34c73b6"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </td></tr>
<tr class="memitem:a4392180bc260915d323e21d3f34c73b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a4392180bc260915d323e21d3f34c73b6">operator-</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; lhs, TLOC val)</td></tr>
<tr class="separator:a4392180bc260915d323e21d3f34c73b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26a9477ef49dd6fa2db5845b67e7e2d"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </td></tr>
<tr class="memitem:af26a9477ef49dd6fa2db5845b67e7e2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#af26a9477ef49dd6fa2db5845b67e7e2d">operator-</a> (TLOC val, <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="separator:af26a9477ef49dd6fa2db5845b67e7e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4a9a4a743921d734f3f1f024a15479"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </td></tr>
<tr class="memitem:a6b4a9a4a743921d734f3f1f024a15479"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a6b4a9a4a743921d734f3f1f024a15479">operator*</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; lhs, TLOC val)</td></tr>
<tr class="separator:a6b4a9a4a743921d734f3f1f024a15479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bfc97cd16c2230cafea34a964b072a"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </td></tr>
<tr class="memitem:ab1bfc97cd16c2230cafea34a964b072a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ab1bfc97cd16c2230cafea34a964b072a">operator*</a> (TLOC val, <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="separator:ab1bfc97cd16c2230cafea34a964b072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9900fec8b6aaecdcd8e49add00c1e5"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </td></tr>
<tr class="memitem:a7b9900fec8b6aaecdcd8e49add00c1e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a7b9900fec8b6aaecdcd8e49add00c1e5">operator/</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; lhs, TLOC val)</td></tr>
<tr class="separator:a7b9900fec8b6aaecdcd8e49add00c1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf8f8889781043be3b92e3e3cfd73a6"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </td></tr>
<tr class="memitem:a3bf8f8889781043be3b92e3e3cfd73a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a3bf8f8889781043be3b92e3e3cfd73a6">operator/</a> (TLOC val, <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="separator:a3bf8f8889781043be3b92e3e3cfd73a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793d39d1cf02a94a6762cb17ba989060"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </td></tr>
<tr class="memitem:a793d39d1cf02a94a6762cb17ba989060"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a793d39d1cf02a94a6762cb17ba989060">pow</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; lhs, TLOC val)</td></tr>
<tr class="separator:a793d39d1cf02a94a6762cb17ba989060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2f9ecc45bafabc6f6595949c9d4fa6"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a0d2f9ecc45bafabc6f6595949c9d4fa6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a0d2f9ecc45bafabc6f6595949c9d4fa6">operator-</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:a0d2f9ecc45bafabc6f6595949c9d4fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860d4dcab9d5e50931418a9a1586bb06"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a860d4dcab9d5e50931418a9a1586bb06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a860d4dcab9d5e50931418a9a1586bb06">sqrt</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:a860d4dcab9d5e50931418a9a1586bb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367630d5bb3c6167f1fa68b55ed4f91b"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a367630d5bb3c6167f1fa68b55ed4f91b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a367630d5bb3c6167f1fa68b55ed4f91b">abs</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:a367630d5bb3c6167f1fa68b55ed4f91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec6ee9396425c8a4a8e8bd76501022f"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a4ec6ee9396425c8a4a8e8bd76501022f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a4ec6ee9396425c8a4a8e8bd76501022f">exp</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:a4ec6ee9396425c8a4a8e8bd76501022f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff56b080c243b62138c30f42b5cd6dbc"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:aff56b080c243b62138c30f42b5cd6dbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aff56b080c243b62138c30f42b5cd6dbc">log</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:aff56b080c243b62138c30f42b5cd6dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cf567e6117a9c263f450e68615f2cb"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:ae4cf567e6117a9c263f450e68615f2cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ae4cf567e6117a9c263f450e68615f2cb">log10</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:ae4cf567e6117a9c263f450e68615f2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2fc7b95daa795b453a32790b6e2f8c"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:aae2fc7b95daa795b453a32790b6e2f8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aae2fc7b95daa795b453a32790b6e2f8c">cos</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:aae2fc7b95daa795b453a32790b6e2f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4d194a56da2f17208a0b7d521ac7fe"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:aef4d194a56da2f17208a0b7d521ac7fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aef4d194a56da2f17208a0b7d521ac7fe">sin</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:aef4d194a56da2f17208a0b7d521ac7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a50fe47024438c63a8a6da14d130eb"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a52a50fe47024438c63a8a6da14d130eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a52a50fe47024438c63a8a6da14d130eb">tan</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:a52a50fe47024438c63a8a6da14d130eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfe6a6ff9d5b2f16b1195767ad2c1b2"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a8dfe6a6ff9d5b2f16b1195767ad2c1b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a8dfe6a6ff9d5b2f16b1195767ad2c1b2">acos</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:a8dfe6a6ff9d5b2f16b1195767ad2c1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3906e1b172670ec659b86a9913f1aef8"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a3906e1b172670ec659b86a9913f1aef8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a3906e1b172670ec659b86a9913f1aef8">asign</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:a3906e1b172670ec659b86a9913f1aef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3e703fbd4b6e4176c575a8ef81e58b"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a0a3e703fbd4b6e4176c575a8ef81e58b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a0a3e703fbd4b6e4176c575a8ef81e58b">atan</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:a0a3e703fbd4b6e4176c575a8ef81e58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac733b4d05317493f8fef7a3f8ddc775c"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:ac733b4d05317493f8fef7a3f8ddc775c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ac733b4d05317493f8fef7a3f8ddc775c">ceil</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:ac733b4d05317493f8fef7a3f8ddc775c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020ab23a6238cdc6317312346e96c88f"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a020ab23a6238cdc6317312346e96c88f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a020ab23a6238cdc6317312346e96c88f">floor</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:a020ab23a6238cdc6317312346e96c88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f38931b23ab5b1c107992b509b75b60"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a2f38931b23ab5b1c107992b509b75b60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a2f38931b23ab5b1c107992b509b75b60">round</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:a2f38931b23ab5b1c107992b509b75b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48557316c62486158406292e053ea2d5"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a48557316c62486158406292e053ea2d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a48557316c62486158406292e053ea2d5">operator+</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a, <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; b)</td></tr>
<tr class="separator:a48557316c62486158406292e053ea2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57013efb52cc2fa310cc7673ac1cc389"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a57013efb52cc2fa310cc7673ac1cc389"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a57013efb52cc2fa310cc7673ac1cc389">operator-</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a, <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; b)</td></tr>
<tr class="separator:a57013efb52cc2fa310cc7673ac1cc389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5c671aa3b3eb8886ea87472d53f563"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a2a5c671aa3b3eb8886ea87472d53f563"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a2a5c671aa3b3eb8886ea87472d53f563">operator*</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a, <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; b)</td></tr>
<tr class="separator:a2a5c671aa3b3eb8886ea87472d53f563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79276c7651f6e0d67da86d7e21ce865"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:ae79276c7651f6e0d67da86d7e21ce865"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ae79276c7651f6e0d67da86d7e21ce865">operator/</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a, <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; b)</td></tr>
<tr class="separator:ae79276c7651f6e0d67da86d7e21ce865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c11133710aa7fa34382d68bcaf9f96"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a65c11133710aa7fa34382d68bcaf9f96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a65c11133710aa7fa34382d68bcaf9f96">pow</a> (<a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; a, <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt; b)</td></tr>
<tr class="separator:a65c11133710aa7fa34382d68bcaf9f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548f5a6d111b18c6541bc82f3913345d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a548f5a6d111b18c6541bc82f3913345d">timer_init</a> ()</td></tr>
<tr class="memdesc:a548f5a6d111b18c6541bc82f3913345d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the YAKL timers.  <a href="namespaceyakl.html#a548f5a6d111b18c6541bc82f3913345d">More...</a><br /></td></tr>
<tr class="separator:a548f5a6d111b18c6541bc82f3913345d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757af9a71189e007f6afa0c8df1380cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a757af9a71189e007f6afa0c8df1380cf">timer_finalize</a> ()</td></tr>
<tr class="memdesc:a757af9a71189e007f6afa0c8df1380cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the YAKL timers.  <a href="namespaceyakl.html#a757af9a71189e007f6afa0c8df1380cf">More...</a><br /></td></tr>
<tr class="separator:a757af9a71189e007f6afa0c8df1380cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22876aa3d7b5d93e2cd9df0110a1f236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a22876aa3d7b5d93e2cd9df0110a1f236">timer_start</a> (char const *lab)</td></tr>
<tr class="memdesc:a22876aa3d7b5d93e2cd9df0110a1f236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a timer with the given string label. NOTE: Timers must be perfectly nested.  <a href="namespaceyakl.html#a22876aa3d7b5d93e2cd9df0110a1f236">More...</a><br /></td></tr>
<tr class="separator:a22876aa3d7b5d93e2cd9df0110a1f236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a80175a29130a523e3d44585d046da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ae2a80175a29130a523e3d44585d046da">timer_stop</a> (char const *lab)</td></tr>
<tr class="memdesc:ae2a80175a29130a523e3d44585d046da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop a timer with the given string label. NOTE: Timers must be perfectly nested.  <a href="namespaceyakl.html#ae2a80175a29130a523e3d44585d046da">More...</a><br /></td></tr>
<tr class="separator:ae2a80175a29130a523e3d44585d046da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6b5768d519254c3cbcd84eca12d20b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aca6b5768d519254c3cbcd84eca12d20b">set_timer_init</a> (std::function&lt; void()&gt; func)</td></tr>
<tr class="memdesc:aca6b5768d519254c3cbcd84eca12d20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's default timer initialization routine.  <a href="namespaceyakl.html#aca6b5768d519254c3cbcd84eca12d20b">More...</a><br /></td></tr>
<tr class="separator:aca6b5768d519254c3cbcd84eca12d20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3d7bb59cc9da9d19c0668034e7a68c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aec3d7bb59cc9da9d19c0668034e7a68c">set_timer_finalize</a> (std::function&lt; void()&gt; func)</td></tr>
<tr class="memdesc:aec3d7bb59cc9da9d19c0668034e7a68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's default timer finalization routine.  <a href="namespaceyakl.html#aec3d7bb59cc9da9d19c0668034e7a68c">More...</a><br /></td></tr>
<tr class="separator:aec3d7bb59cc9da9d19c0668034e7a68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc021bc87deafec03ab9c12f20a3ce0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#afc021bc87deafec03ab9c12f20a3ce0d">set_timer_start</a> (std::function&lt; void(char const *)&gt; func)</td></tr>
<tr class="memdesc:afc021bc87deafec03ab9c12f20a3ce0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's default routine to start an individual timer.  <a href="namespaceyakl.html#afc021bc87deafec03ab9c12f20a3ce0d">More...</a><br /></td></tr>
<tr class="separator:afc021bc87deafec03ab9c12f20a3ce0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b1265406af3613ea8f2f0265200ce0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a12b1265406af3613ea8f2f0265200ce0">set_timer_stop</a> (std::function&lt; void(char const *)&gt; func)</td></tr>
<tr class="memdesc:a12b1265406af3613ea8f2f0265200ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override YAKL's default routine to stop an individual timer.  <a href="namespaceyakl.html#a12b1265406af3613ea8f2f0265200ce0">More...</a><br /></td></tr>
<tr class="separator:a12b1265406af3613ea8f2f0265200ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0636ffa1809f47534bd4f705bae0d857"><td class="memTemplParams" colspan="2">template&lt;unsigned int n, class real &gt; </td></tr>
<tr class="memitem:a0636ffa1809f47534bd4f705bae0d857"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a0636ffa1809f47534bd4f705bae0d857">pentadiagonal</a> (<a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;a, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;b, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;c, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;d, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;e, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;f, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;u)</td></tr>
<tr class="memdesc:a0636ffa1809f47534bd4f705bae0d857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a non-periodic pentadiagonal solve. Click for more details.  <a href="namespaceyakl.html#a0636ffa1809f47534bd4f705bae0d857">More...</a><br /></td></tr>
<tr class="separator:a0636ffa1809f47534bd4f705bae0d857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98637dc95c0af6d4860349ada34e262"><td class="memTemplParams" colspan="2">template&lt;unsigned int n, class real &gt; </td></tr>
<tr class="memitem:ad98637dc95c0af6d4860349ada34e262"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ad98637dc95c0af6d4860349ada34e262">pentadiagonal_periodic</a> (<a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;a, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;b, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;c, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;d, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;e, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;f, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;x)</td></tr>
<tr class="memdesc:ad98637dc95c0af6d4860349ada34e262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a periodic pentadiagonal solve. Click for more details.  <a href="namespaceyakl.html#ad98637dc95c0af6d4860349ada34e262">More...</a><br /></td></tr>
<tr class="separator:ad98637dc95c0af6d4860349ada34e262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439699e15caa21efb6a8511e032c0da6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a439699e15caa21efb6a8511e032c0da6">pnetcdf_put_var</a> (int ncid, int varid, signed char const *data)</td></tr>
<tr class="separator:a439699e15caa21efb6a8511e032c0da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d041c58f4a00d2151c1da35c0b9063e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a8d041c58f4a00d2151c1da35c0b9063e">pnetcdf_put_var</a> (int ncid, int varid, unsigned char const *data)</td></tr>
<tr class="separator:a8d041c58f4a00d2151c1da35c0b9063e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9df89f4ad22d09c9d3892b460c4d18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ade9df89f4ad22d09c9d3892b460c4d18">pnetcdf_put_var</a> (int ncid, int varid, short const *data)</td></tr>
<tr class="separator:ade9df89f4ad22d09c9d3892b460c4d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bf258736c706ed1dbc792b98580328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a29bf258736c706ed1dbc792b98580328">pnetcdf_put_var</a> (int ncid, int varid, unsigned short const *data)</td></tr>
<tr class="separator:a29bf258736c706ed1dbc792b98580328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ae88ef34467155b010d4bc2e3e3eb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a36ae88ef34467155b010d4bc2e3e3eb6">pnetcdf_put_var</a> (int ncid, int varid, int const *data)</td></tr>
<tr class="separator:a36ae88ef34467155b010d4bc2e3e3eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e19108734e798e2b5eca0099e735d0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a7e19108734e798e2b5eca0099e735d0a">pnetcdf_put_var</a> (int ncid, int varid, unsigned int const *data)</td></tr>
<tr class="separator:a7e19108734e798e2b5eca0099e735d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3187a5f04c85b7c8a4fc68cb43b02c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a3187a5f04c85b7c8a4fc68cb43b02c97">pnetcdf_put_var</a> (int ncid, int varid, long long const *data)</td></tr>
<tr class="separator:a3187a5f04c85b7c8a4fc68cb43b02c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a148a84f5892ed1e1d865f2556a6a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a61a148a84f5892ed1e1d865f2556a6a4">pnetcdf_put_var</a> (int ncid, int varid, unsigned long long const *data)</td></tr>
<tr class="separator:a61a148a84f5892ed1e1d865f2556a6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e89675fcc85a453ecd503c0df12d2d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a8e89675fcc85a453ecd503c0df12d2d6">pnetcdf_put_var</a> (int ncid, int varid, float const *data)</td></tr>
<tr class="separator:a8e89675fcc85a453ecd503c0df12d2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbfd8923509e0e4eb09739045d1ff8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a4dbfd8923509e0e4eb09739045d1ff8f">pnetcdf_put_var</a> (int ncid, int varid, double const *data)</td></tr>
<tr class="separator:a4dbfd8923509e0e4eb09739045d1ff8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24de5b43d8f56915aeecb2c41b566d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a24de5b43d8f56915aeecb2c41b566d77">pnetcdf_put_var1</a> (int ncid, int varid, signed char const *data)</td></tr>
<tr class="separator:a24de5b43d8f56915aeecb2c41b566d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df9c0aaebc8786566ff7beb4a474cd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a5df9c0aaebc8786566ff7beb4a474cd6">pnetcdf_put_var1</a> (int ncid, int varid, unsigned char const *data)</td></tr>
<tr class="separator:a5df9c0aaebc8786566ff7beb4a474cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e07ee0438ae6e0d1e69162514d7ef6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a31e07ee0438ae6e0d1e69162514d7ef6">pnetcdf_put_var1</a> (int ncid, int varid, short const *data)</td></tr>
<tr class="separator:a31e07ee0438ae6e0d1e69162514d7ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada5333bb143b2367e137f799459add6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aada5333bb143b2367e137f799459add6">pnetcdf_put_var1</a> (int ncid, int varid, unsigned short const *data)</td></tr>
<tr class="separator:aada5333bb143b2367e137f799459add6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cf801a9f35aa4fbf26f0fd9976e6e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a96cf801a9f35aa4fbf26f0fd9976e6e8">pnetcdf_put_var1</a> (int ncid, int varid, int const *data)</td></tr>
<tr class="separator:a96cf801a9f35aa4fbf26f0fd9976e6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090001f3516744ee0d84f9570cda6f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a090001f3516744ee0d84f9570cda6f7d">pnetcdf_put_var1</a> (int ncid, int varid, unsigned int const *data)</td></tr>
<tr class="separator:a090001f3516744ee0d84f9570cda6f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc680f840a4a033714f2c9abb086f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a2bc680f840a4a033714f2c9abb086f03">pnetcdf_put_var1</a> (int ncid, int varid, long long const *data)</td></tr>
<tr class="separator:a2bc680f840a4a033714f2c9abb086f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e87da7579cb70e7696e52723e1336a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a90e87da7579cb70e7696e52723e1336a">pnetcdf_put_var1</a> (int ncid, int varid, unsigned long long const *data)</td></tr>
<tr class="separator:a90e87da7579cb70e7696e52723e1336a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28188af6587eadef58215dbc1cdf487c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a28188af6587eadef58215dbc1cdf487c">pnetcdf_put_var1</a> (int ncid, int varid, float const *data)</td></tr>
<tr class="separator:a28188af6587eadef58215dbc1cdf487c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02225acc7d9d5a8f6e7da84aaad97411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a02225acc7d9d5a8f6e7da84aaad97411">pnetcdf_put_var1</a> (int ncid, int varid, double const *data)</td></tr>
<tr class="separator:a02225acc7d9d5a8f6e7da84aaad97411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68ee0caee1fc11227e3a765310807b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ab68ee0caee1fc11227e3a765310807b0">pnetcdf_put_vara</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], signed char const *data)</td></tr>
<tr class="separator:ab68ee0caee1fc11227e3a765310807b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80dd0a51b0bc0b4929ca538e2e816d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aa80dd0a51b0bc0b4929ca538e2e816d0">pnetcdf_put_vara</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], unsigned char const *data)</td></tr>
<tr class="separator:aa80dd0a51b0bc0b4929ca538e2e816d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1687c96c618322d1a967f67c3774d929"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a1687c96c618322d1a967f67c3774d929">pnetcdf_put_vara</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], short const *data)</td></tr>
<tr class="separator:a1687c96c618322d1a967f67c3774d929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8e416b7c4629e56ce44edba72dd8f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#afc8e416b7c4629e56ce44edba72dd8f4">pnetcdf_put_vara</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], unsigned short const *data)</td></tr>
<tr class="separator:afc8e416b7c4629e56ce44edba72dd8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6066a9fdb48e52d756c220023351e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aed6066a9fdb48e52d756c220023351e7">pnetcdf_put_vara</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], int const *data)</td></tr>
<tr class="separator:aed6066a9fdb48e52d756c220023351e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d70331e0aafef59f4d90a0847c8342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ad5d70331e0aafef59f4d90a0847c8342">pnetcdf_put_vara</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], unsigned int const *data)</td></tr>
<tr class="separator:ad5d70331e0aafef59f4d90a0847c8342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce57cc834c9cae52e3b9d3df0bd7726"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a6ce57cc834c9cae52e3b9d3df0bd7726">pnetcdf_put_vara</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], long long const *data)</td></tr>
<tr class="separator:a6ce57cc834c9cae52e3b9d3df0bd7726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac328cdd6d0a189bd43f21a26069dba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a5ac328cdd6d0a189bd43f21a26069dba">pnetcdf_put_vara</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], unsigned long long const *data)</td></tr>
<tr class="separator:a5ac328cdd6d0a189bd43f21a26069dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e73dbcc821ba419cc5cec754ada36e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a3e73dbcc821ba419cc5cec754ada36e6">pnetcdf_put_vara</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], float const *data)</td></tr>
<tr class="separator:a3e73dbcc821ba419cc5cec754ada36e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4a2dcb8c98cb91e98194e92c34eea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ace4a2dcb8c98cb91e98194e92c34eea4">pnetcdf_put_vara</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], double const *data)</td></tr>
<tr class="separator:ace4a2dcb8c98cb91e98194e92c34eea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659649de5302b9aa2387e9cebf1d703f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a659649de5302b9aa2387e9cebf1d703f">pnetcdf_put_vara_all</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], signed char const *data)</td></tr>
<tr class="separator:a659649de5302b9aa2387e9cebf1d703f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ef0b43880c2326a1053502b268fbb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aa9ef0b43880c2326a1053502b268fbb0">pnetcdf_put_vara_all</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], unsigned char const *data)</td></tr>
<tr class="separator:aa9ef0b43880c2326a1053502b268fbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d44a94d51e1ef3fc0a48e28d1002cf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a7d44a94d51e1ef3fc0a48e28d1002cf4">pnetcdf_put_vara_all</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], short const *data)</td></tr>
<tr class="separator:a7d44a94d51e1ef3fc0a48e28d1002cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7cb6bd189f72b74efe4c9767d54283"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a9f7cb6bd189f72b74efe4c9767d54283">pnetcdf_put_vara_all</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], unsigned short const *data)</td></tr>
<tr class="separator:a9f7cb6bd189f72b74efe4c9767d54283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bc6b4ac486e13865da72ac4d67c666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a63bc6b4ac486e13865da72ac4d67c666">pnetcdf_put_vara_all</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], int const *data)</td></tr>
<tr class="separator:a63bc6b4ac486e13865da72ac4d67c666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f4bc030fcd2da9cc763ba15840dbd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#af7f4bc030fcd2da9cc763ba15840dbd1">pnetcdf_put_vara_all</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], unsigned int const *data)</td></tr>
<tr class="separator:af7f4bc030fcd2da9cc763ba15840dbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d23c13842a2e4d3cb017594befe961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#af4d23c13842a2e4d3cb017594befe961">pnetcdf_put_vara_all</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], long long const *data)</td></tr>
<tr class="separator:af4d23c13842a2e4d3cb017594befe961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6a74b956c15a77d8328b6a67f18891"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#add6a74b956c15a77d8328b6a67f18891">pnetcdf_put_vara_all</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], unsigned long long const *data)</td></tr>
<tr class="separator:add6a74b956c15a77d8328b6a67f18891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfa3f38e14887b22e75c956af9d47fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a4dfa3f38e14887b22e75c956af9d47fc">pnetcdf_put_vara_all</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], float const *data)</td></tr>
<tr class="separator:a4dfa3f38e14887b22e75c956af9d47fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd66cf70782fa951b961046ceb9c30f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#acdd66cf70782fa951b961046ceb9c30f">pnetcdf_put_vara_all</a> (int ncid, int varid, MPI_Offset const start[], MPI_Offset const count[], double const *data)</td></tr>
<tr class="separator:acdd66cf70782fa951b961046ceb9c30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9374fb79e2fd32acaf9d1f1a5e23775"><td class="memTemplParams" colspan="2">template&lt;class real , unsigned int n&gt; </td></tr>
<tr class="memitem:af9374fb79e2fd32acaf9d1f1a5e23775"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#af9374fb79e2fd32acaf9d1f1a5e23775">tridiagonal_periodic</a> (<a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;a, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;b, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;c, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;d)</td></tr>
<tr class="memdesc:af9374fb79e2fd32acaf9d1f1a5e23775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a periodic tridiagional solve. Click for more details.  <a href="namespaceyakl.html#af9374fb79e2fd32acaf9d1f1a5e23775">More...</a><br /></td></tr>
<tr class="separator:af9374fb79e2fd32acaf9d1f1a5e23775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cabe73b4f2ca1385233cb75541c687"><td class="memTemplParams" colspan="2">template&lt;class real , unsigned int n&gt; </td></tr>
<tr class="memitem:aa3cabe73b4f2ca1385233cb75541c687"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aa3cabe73b4f2ca1385233cb75541c687">tridiagonal</a> (<a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;a, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;b, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;c, <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;d)</td></tr>
<tr class="memdesc:aa3cabe73b4f2ca1385233cb75541c687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a non-periodic tridiagional system.  <a href="namespaceyakl.html#aa3cabe73b4f2ca1385233cb75541c687">More...</a><br /></td></tr>
<tr class="separator:aa3cabe73b4f2ca1385233cb75541c687"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a99a2f92ab5419408dd90d950aad1305c"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a99a2f92ab5419408dd90d950aad1305c">yakl_mtx</a></td></tr>
<tr class="separator:a99a2f92ab5419408dd90d950aad1305c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624d250b0cd8562b06641c92090efa8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyakl_1_1Gator.html">Gator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a624d250b0cd8562b06641c92090efa8d">pool</a></td></tr>
<tr class="separator:a624d250b0cd8562b06641c92090efa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe95c3cd90819e7b844991450403820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyakl_1_1Toney.html">Toney</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#acbe95c3cd90819e7b844991450403820">timer</a></td></tr>
<tr class="separator:acbe95c3cd90819e7b844991450403820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0437bce10dc5e3816ab24a75e3976a4f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a0437bce10dc5e3816ab24a75e3976a4f">INDEX_MAX</a> = std::numeric_limits&lt;<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&gt;::max()</td></tr>
<tr class="separator:a0437bce10dc5e3816ab24a75e3976a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a958dd81c018c1859580dcb453d31d"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a> = 1</td></tr>
<tr class="memdesc:a59a958dd81c018c1859580dcb453d31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template parameter for <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> that specifies it should follow C-style behavior.  <a href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">More...</a><br /></td></tr>
<tr class="separator:a59a958dd81c018c1859580dcb453d31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48029004bb42b7cc63974ca0433af63a"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a48029004bb42b7cc63974ca0433af63a">styleFortran</a> = 2</td></tr>
<tr class="memdesc:a48029004bb42b7cc63974ca0433af63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template parameter for <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> that specifies it should follow Fortran-style behavior.  <a href="namespaceyakl.html#a48029004bb42b7cc63974ca0433af63a">More...</a><br /></td></tr>
<tr class="separator:a48029004bb42b7cc63974ca0433af63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0792e33ef74bcb90e3ed4b847415543d"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a0792e33ef74bcb90e3ed4b847415543d">styleDefault</a> = <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a></td></tr>
<tr class="memdesc:a0792e33ef74bcb90e3ed4b847415543d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default style is C-style for <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects.  <a href="namespaceyakl.html#a0792e33ef74bcb90e3ed4b847415543d">More...</a><br /></td></tr>
<tr class="separator:a0792e33ef74bcb90e3ed4b847415543d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af6abbeffe50631799da258050ff853"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">COLON</a> = std::numeric_limits&lt;int&gt;::min()</td></tr>
<tr class="memdesc:a9af6abbeffe50631799da258050ff853"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is just a convenience syntax for slicing <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects to make it clear in the user level code which dimensions are being sliced.  <a href="namespaceyakl.html#a9af6abbeffe50631799da258050ff853">More...</a><br /></td></tr>
<tr class="separator:a9af6abbeffe50631799da258050ff853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0690b4d7056faf74747ce4eafd3a0ce"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ad0690b4d7056faf74747ce4eafd3a0ce">memDevice</a> = 1</td></tr>
<tr class="separator:ad0690b4d7056faf74747ce4eafd3a0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c782101ad6c48bd8c317f61e77abf98"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a8c782101ad6c48bd8c317f61e77abf98">memHost</a> = 2</td></tr>
<tr class="separator:a8c782101ad6c48bd8c317f61e77abf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12f0312227bfbba1756585d41a5d87f"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#aa12f0312227bfbba1756585d41a5d87f">NETCDF_MODE_READ</a> = NC_NOWRITE</td></tr>
<tr class="separator:aa12f0312227bfbba1756585d41a5d87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695e075dc48e0c511320c467d347fd5e"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a695e075dc48e0c511320c467d347fd5e">NETCDF_MODE_WRITE</a> = NC_WRITE</td></tr>
<tr class="separator:a695e075dc48e0c511320c467d347fd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad851f7ac4bf63a9e912514b4fab4cd"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#a4ad851f7ac4bf63a9e912514b4fab4cd">NETCDF_MODE_REPLACE</a> = NC_CLOBBER</td></tr>
<tr class="separator:a4ad851f7ac4bf63a9e912514b4fab4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a358faf3cb27d0a14a15b5c6b83022"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyakl.html#ab5a358faf3cb27d0a14a15b5c6b83022">NETCDF_MODE_NEW</a> = NC_NOCLOBBER</td></tr>
<tr class="separator:ab5a358faf3cb27d0a14a15b5c6b83022"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a82d096ec8a882129a4c2b84f0f636d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d096ec8a882129a4c2b84f0f636d60">&#9670;&nbsp;</a></span>DefaultLaunchConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyakl.html#a82d096ec8a882129a4c2b84f0f636d60">yakl::DefaultLaunchConfig</a> = typedef <a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This launch configuration sets vector length to the device default and <code>B4B</code> to <code>false</code>. </p>

</div>
</div>
<a id="a9b33cfecadff879247cf80a54e825acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b33cfecadff879247cf80a54e825acd">&#9670;&nbsp;</a></span>DefaultLaunchConfigB4b</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyakl.html#a9b33cfecadff879247cf80a54e825acd">yakl::DefaultLaunchConfigB4b</a> = typedef <a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a>&lt;<a class="el" href="YAKL__LaunchConfig_8h.html#a9d0e22704e1de301961bf131053aed15">YAKL_DEFAULT_VECTOR_LEN</a>,true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>launch configuration sets B4B == true with the default <code>VecLen</code>. </p>

</div>
</div>
<a id="a172abcdd2d33fa36e969d80e6907173c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172abcdd2d33fa36e969d80e6907173c">&#9670;&nbsp;</a></span>index_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">yakl::index_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84fb5d8e747b5e4eff60360ad77fc402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fb5d8e747b5e4eff60360ad77fc402">&#9670;&nbsp;</a></span>InnerHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct yakl::InnerHandlerEmpty <a class="el" href="namespaceyakl.html#a84fb5d8e747b5e4eff60360ad77fc402">yakl::InnerHandler</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This class is necessary for coordination of two-level parallelism. A <a class="el" href="namespaceyakl.html#a84fb5d8e747b5e4eff60360ad77fc402" title="This class is necessary for coordination of two-level parallelism. A yakl::InnerHandler object must b...">yakl::InnerHandler</a> object must be accepted as a parameter in the functor passed to <code>parallel_outer</code>, and it must be passed as a parameter to <code>parallel_inner</code>, <code>fence_inner</code>, and <code>single_inner</code>. An object of this class should never need to be explicitly created by the user. </p>

</div>
</div>
<a id="a0fff077cfae8547c78e7c76bdd45a465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fff077cfae8547c78e7c76bdd45a465">&#9670;&nbsp;</a></span>LaunchConfigB4b</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int VecLen = YAKL_DEFAULT_VECTOR_LEN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyakl.html#a0fff077cfae8547c78e7c76bdd45a465">yakl::LaunchConfigB4b</a> = typedef <a class="el" href="structyakl_1_1LaunchConfig.html">LaunchConfig</a>&lt;VecLen,true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>launch configuration sets B4B == true with a user-specified <code>VecLen</code>. </p>

</div>
</div>
<a id="a963e440ba3b79d2250aea69749f844fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963e440ba3b79d2250aea69749f844fd">&#9670;&nbsp;</a></span>ParallelMax</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int memSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyakl.html#a963e440ba3b79d2250aea69749f844fd">yakl::ParallelMax</a> = typedef <a class="el" href="classyakl_1_1ParallelReduction.html">ParallelReduction</a>&lt;T,memSpace,YAKL_REDUCTION_MAX &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae2cdeccf05329f3fcc2ab27d8cf0399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2cdeccf05329f3fcc2ab27d8cf0399">&#9670;&nbsp;</a></span>ParallelMin</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int memSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyakl.html#aae2cdeccf05329f3fcc2ab27d8cf0399">yakl::ParallelMin</a> = typedef <a class="el" href="classyakl_1_1ParallelReduction.html">ParallelReduction</a>&lt;T,memSpace,YAKL_REDUCTION_MIN &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bbeb29ba06bb6b58bb0a5672575fd3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbeb29ba06bb6b58bb0a5672575fd3a">&#9670;&nbsp;</a></span>ParallelProd</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int memSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyakl.html#a6bbeb29ba06bb6b58bb0a5672575fd3a">yakl::ParallelProd</a> = typedef <a class="el" href="classyakl_1_1ParallelReduction.html">ParallelReduction</a>&lt;T,memSpace,YAKL_REDUCTION_PROD&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a0eae445a17795ed61a17745902a7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0eae445a17795ed61a17745902a7bf">&#9670;&nbsp;</a></span>ParallelSum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int memSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyakl.html#a6a0eae445a17795ed61a17745902a7bf">yakl::ParallelSum</a> = typedef <a class="el" href="classyakl_1_1ParallelReduction.html">ParallelReduction</a>&lt;T,memSpace,YAKL_REDUCTION_SUM &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adabbe6df1f315d5e2c1874cf1be0acf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabbe6df1f315d5e2c1874cf1be0acf2">&#9670;&nbsp;</a></span>SArray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, unsigned D0, unsigned D1 = 1, unsigned D2 = 1, unsigned D3 = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">yakl::SArray</a> = typedef <a class="el" href="classyakl_1_1CSArray.html">CSArray</a>&lt;T,rank,D0,D1,D2,D3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most often, codes use the type define <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a> rather than <a class="el" href="classyakl_1_1CSArray.html" title="This creates a C-style &quot;Stack Array&quot; (CSArray) class, which is typedefined to yakl::SArray....">yakl::CSArray</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a367630d5bb3c6167f1fa68b55ed4f91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367630d5bb3c6167f1fa68b55ed4f91b">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dfe6a6ff9d5b2f16b1195767ad2c1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfe6a6ff9d5b2f16b1195767ad2c1b2">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::acos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3906e1b172670ec659b86a9913f1aef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3906e1b172670ec659b86a9913f1aef8">&#9670;&nbsp;</a></span>asign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::asign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a3e703fbd4b6e4176c575a8ef81e58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3e703fbd4b6e4176c575a8ef81e58b">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::atan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cda355f1f737b5b613b6463232f3e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cda355f1f737b5b613b6463232f3e69">&#9670;&nbsp;</a></span>atomicAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::atomicAdd </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically perform update += value. </p>

</div>
</div>
<a id="a41cb894576efe9797212d7befde66c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cb894576efe9797212d7befde66c74">&#9670;&nbsp;</a></span>atomicMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::atomicMax </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically perform update = max(update,value) </p>

</div>
</div>
<a id="a00f63fe7be70100d62b0e572967abea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f63fe7be70100d62b0e572967abea7">&#9670;&nbsp;</a></span>atomicMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::atomicMin </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically perform update = min(update,value) </p>

</div>
</div>
<a id="ac733b4d05317493f8fef7a3f8ddc775c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac733b4d05317493f8fef7a3f8ddc775c">&#9670;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::ceil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e01c087965b875ff55d3c7b2b4f4b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e01c087965b875ff55d3c7b2b4f4b00">&#9670;&nbsp;</a></span>check_last_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::check_last_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if an error has occurred on the device. </p>

</div>
</div>
<a id="aae2fc7b95daa795b453a32790b6e2f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2fc7b95daa795b453a32790b6e2f8c">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ec6ee9396425c8a4a8e8bd76501022f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec6ee9396425c8a4a8e8bd76501022f">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5debd8fe5fff4f37c06e55648d138e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5debd8fe5fff4f37c06e55648d138e0c">&#9670;&nbsp;</a></span>fence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::fence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block the host code until all device code has completed. </p>

</div>
</div>
<a id="a823fefa19bd87dca7a0c66094130d6db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823fefa19bd87dca7a0c66094130d6db">&#9670;&nbsp;</a></span>fence_inner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::fence_inner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a84fb5d8e747b5e4eff60360ad77fc402">InnerHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To be called inside yakl::parallel_outer <em>only</em>. Block the inner-level parallelism until all inner threads have reached this point. In CUDA and HIP, this is __syncthreads(). Click for more info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The <a class="el" href="namespaceyakl.html#a84fb5d8e747b5e4eff60360ad77fc402" title="This class is necessary for coordination of two-level parallelism. A yakl::InnerHandler object must b...">yakl::InnerHandler</a> object create by yakl::parallel_outer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab42370df4914644cfd129ff6037c5c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42370df4914644cfd129ff6037c5c9f">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalize the YAKL runtime. Best practice is to call <a class="el" href="namespaceyakl.html#a110195fb8259c05f75506e71aa5a792c" title="Determine if the YAKL runtime has been initialized. I.e., yakl::init() has been called without a corr...">yakl::isInitialized()</a> to ensure the YAKL runtime is initialized before calling this routine. That said, this routine <em>does</em> check to ensure the runtime is initialized for you. THREAD SAFE! </p>

</div>
</div>
<a id="a020ab23a6238cdc6317312346e96c88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020ab23a6238cdc6317312346e96c88f">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafe78b03b672a31b597b0b1e4cd97af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe78b03b672a31b597b0b1e4cd97af7">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1InitConfig.html">InitConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="classyakl_1_1InitConfig.html">InitConfig</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the YAKL runtime. (1) Determin if the pool allocator is to be used &amp; pool allocator parameters. (2) Initialize the pool if used. (3) Set the YAKL allocators and deallocators to default. (4) Initialize YAKL's timer calls to defaults. (5) Inspect the optional <a class="el" href="classyakl_1_1InitConfig.html">yakl::InitConfig</a> parameter to override default allocator, deallocator, and timer calls if requested. (6) Allocate YAKL's functor buffer for appropriate backends. (6) Inform the user with device information. THREAD SAFE! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>This <a class="el" href="classyakl_1_1InitConfig.html">yakl::InitConfig</a> object allows the user to override YAKL's default allocator, deallocator and timer calls from the start of the runtime. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a110195fb8259c05f75506e71aa5a792c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110195fb8259c05f75506e71aa5a792c">&#9670;&nbsp;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yakl::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the YAKL runtime has been initialized. I.e., <a class="el" href="namespaceyakl.html#aafe78b03b672a31b597b0b1e4cd97af7" title="Initialize the YAKL runtime. (1) Determin if the pool allocator is to be used &amp; pool allocator parame...">yakl::init()</a> has been called without a corresponding call to <a class="el" href="namespaceyakl.html#ab42370df4914644cfd129ff6037c5c9f" title="Finalize the YAKL runtime. Best practice is to call yakl::isInitialized() to ensure the YAKL runtime ...">yakl::finalize()</a>. </p>

</div>
</div>
<a id="a27535cdea6b17bbbdc6ccfe17808abb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27535cdea6b17bbbdc6ccfe17808abb5">&#9670;&nbsp;</a></span>iterate_over_pack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , unsigned int N, bool SIMD = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::iterate_over_pack </td>
          <td>(</td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyakl_1_1PackIterConfig.html">PackIterConfig</a>&lt; N, SIMD &gt;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a loop over the vector length size specified by the config parameter. If the config parameter also specifies that the SIMD template parameter is true, then apply SIMD pragmas. IMPORTANT: For the functor passed to this routine, please use [&amp;] syntax, <em>not</em> YAKL_LAMBDA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The functor object to execute inside the loop. </td></tr>
    <tr><td class="paramname">config</td><td><a class="el" href="structyakl_1_1PackIterConfig.html" title="This object must be passed to yakl::iterate_over_pack to inform that routine what the simd vector len...">yakl::PackIterConfig</a> object with two template parameters: (1) the vector length (number of elements to loop over; and (2) a bool SIMD parameter to tell this routine whether or not it should apply a SIMD pragma. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff56b080c243b62138c30f42b5cd6dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff56b080c243b62138c30f42b5cd6dbc">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4cf567e6117a9c263f450e68615f2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cf567e6117a9c263f450e68615f2cb">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::log10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3cd629fc27eb6cd1e237c1172e5c291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cd629fc27eb6cd1e237c1172e5c291">&#9670;&nbsp;</a></span>memcpy_device_to_device()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::memcpy_device_to_device </td>
          <td>(</td>
          <td class="paramtype">T1 *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> on the device </p>

</div>
</div>
<a id="af67a0305587b9e57dc519098a1e82eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67a0305587b9e57dc519098a1e82eac">&#9670;&nbsp;</a></span>memcpy_device_to_device_void()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::memcpy_device_to_device_void </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[USE AT YOUR OWN RISK]: memcpy the specified number of <b>bytes</b> on the device </p>

</div>
</div>
<a id="a7c164d629474f143bb61e540e59f34c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c164d629474f143bb61e540e59f34c7">&#9670;&nbsp;</a></span>memcpy_device_to_host()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::memcpy_device_to_host </td>
          <td>(</td>
          <td class="paramtype">T1 *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> from device to host </p>

</div>
</div>
<a id="ae986e2511210cf25cfee6701d65003c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae986e2511210cf25cfee6701d65003c4">&#9670;&nbsp;</a></span>memcpy_host_to_device()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::memcpy_host_to_device </td>
          <td>(</td>
          <td class="paramtype">T1 *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> from host to device </p>

</div>
</div>
<a id="a7e3ccf876c613d1091413c21151aeeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3ccf876c613d1091413c21151aeeca">&#9670;&nbsp;</a></span>memcpy_host_to_host()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , typename std::enable_if&lt; std::is_same&lt; typename std::remove_cv&lt; T1 &gt;::type, typename std::remove_cv&lt; T2 &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::memcpy_host_to_host </td>
          <td>(</td>
          <td class="paramtype">T1 *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[USE AT YOUR OWN RISK]: memcpy the specified number of <b>elements</b> on the host </p>

</div>
</div>
<a id="a6dd2574081a93f391e588cab890f232f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd2574081a93f391e588cab890f232f">&#9670;&nbsp;</a></span>memcpy_host_to_host_void()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::memcpy_host_to_host_void </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[USE AT YOUR OWN RISK]: memcpy the specified number of <b>bytes</b> on the host </p>

</div>
</div>
<a id="a64ed1845d91a0b667e4700963215a2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ed1845d91a0b667e4700963215a2f9">&#9670;&nbsp;</a></span>memset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, int myMem, int myStyle, class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yakl::memset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Array.html">Array</a>&lt; T, rank, myMem, myStyle &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[Deprecated for user use]: Please use operator= instead. Set a <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> object to the given value. Valid for host or device arrays. </p>

</div>
</div>
<a id="af07a6bcba1f58d2ad541b1541290bfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07a6bcba1f58d2ad541b1541290bfa6">&#9670;&nbsp;</a></span>memset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, class B0 , class B1 , class B2 , class B3 , class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::memset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1FSArray.html">FSArray</a>&lt; T, rank, B0, B1, B2, B3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[Deprecated for user use]: Please use operator= instead. Set a <a class="el" href="classyakl_1_1FSArray.html" title="This creates a Fortran-style &quot;Stack Array&quot; (FSArray) class. It should be thought of as similar in nat...">yakl::FSArray</a> object to the given value. Valid in a host or device context. </p>

</div>
</div>
<a id="a780d1db197827e123582a1e8a29b1848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780d1db197827e123582a1e8a29b1848">&#9670;&nbsp;</a></span>memset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int rank, unsigned D0, unsigned D1, unsigned D2, unsigned D3, class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::memset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; T, rank, D0, D1, D2, D3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[Deprecated for user use]: Please use operator= instead. Set a <a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2" title="Most often, codes use the type define yakl::SArray rather than yakl::CSArray.">yakl::SArray</a> object to the given value. Valid in a host or device context. </p>

</div>
</div>
<a id="a2a5c671aa3b3eb8886ea87472d53f563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5c671aa3b3eb8886ea87472d53f563">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b4a9a4a743921d734f3f1f024a15479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4a9a4a743921d734f3f1f024a15479">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TLOC&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1bfc97cd16c2230cafea34a964b072a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bfc97cd16c2230cafea34a964b072a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::operator* </td>
          <td>(</td>
          <td class="paramtype">TLOC&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48557316c62486158406292e053ea2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48557316c62486158406292e053ea2d5">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac11b06b59b7775329b01bea078bd1999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11b06b59b7775329b01bea078bd1999">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TLOC&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3791e8eabfc1d99f38d62a6f4ba60604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3791e8eabfc1d99f38d62a6f4ba60604">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::operator+ </td>
          <td>(</td>
          <td class="paramtype">TLOC&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d2f9ecc45bafabc6f6595949c9d4fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2f9ecc45bafabc6f6595949c9d4fa6">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57013efb52cc2fa310cc7673ac1cc389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57013efb52cc2fa310cc7673ac1cc389">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4392180bc260915d323e21d3f34c73b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4392180bc260915d323e21d3f34c73b6">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TLOC&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af26a9477ef49dd6fa2db5845b67e7e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26a9477ef49dd6fa2db5845b67e7e2d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::operator- </td>
          <td>(</td>
          <td class="paramtype">TLOC&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae79276c7651f6e0d67da86d7e21ce865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79276c7651f6e0d67da86d7e21ce865">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b9900fec8b6aaecdcd8e49add00c1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9900fec8b6aaecdcd8e49add00c1e5">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TLOC&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bf8f8889781043be3b92e3e3cfd73a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf8f8889781043be3b92e3e3cfd73a6">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::operator/ </td>
          <td>(</td>
          <td class="paramtype">TLOC&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0636ffa1809f47534bd4f705bae0d857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0636ffa1809f47534bd4f705bae0d857">&#9670;&nbsp;</a></span>pentadiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int n, class real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::pentadiagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a non-periodic pentadiagonal solve. Click for more details. </p>
<p>Solves for a vector u of length n in the pentadiagonal linear system </p><div class="fragment"><div class="line">a_i u_(i-2) + b_i u_(i-1) + c_i u_i + d_i u_(i+1) + e_i u_(i+2) = f_i</div>
</div><!-- fragment --><p>input are the a, b, c, d, e, and f and they are not modified </p>

</div>
</div>
<a id="ad98637dc95c0af6d4860349ada34e262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98637dc95c0af6d4860349ada34e262">&#9670;&nbsp;</a></span>pentadiagonal_periodic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int n, class real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::pentadiagonal_periodic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a periodic pentadiagonal solve. Click for more details. </p>
<p>Solves for a vector u of length n in the pentadiagonal linear system </p><div class="fragment"><div class="line">a_i u_(i-2) + b_i u_(i-1) + c_i u_i + d_i u_(i+1) + e_i u_(i+2) = f_i</div>
</div><!-- fragment --><p>input are the a, b, c, d, e, and f and they are not modified </p>

</div>
</div>
<a id="a4dbfd8923509e0e4eb09739045d1ff8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dbfd8923509e0e4eb09739045d1ff8f">&#9670;&nbsp;</a></span>pnetcdf_put_var() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e89675fcc85a453ecd503c0df12d2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e89675fcc85a453ecd503c0df12d2d6">&#9670;&nbsp;</a></span>pnetcdf_put_var() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a36ae88ef34467155b010d4bc2e3e3eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ae88ef34467155b010d4bc2e3e3eb6">&#9670;&nbsp;</a></span>pnetcdf_put_var() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3187a5f04c85b7c8a4fc68cb43b02c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3187a5f04c85b7c8a4fc68cb43b02c97">&#9670;&nbsp;</a></span>pnetcdf_put_var() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade9df89f4ad22d09c9d3892b460c4d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9df89f4ad22d09c9d3892b460c4d18">&#9670;&nbsp;</a></span>pnetcdf_put_var() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a439699e15caa21efb6a8511e032c0da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439699e15caa21efb6a8511e032c0da6">&#9670;&nbsp;</a></span>pnetcdf_put_var() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d041c58f4a00d2151c1da35c0b9063e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d041c58f4a00d2151c1da35c0b9063e">&#9670;&nbsp;</a></span>pnetcdf_put_var() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e19108734e798e2b5eca0099e735d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e19108734e798e2b5eca0099e735d0a">&#9670;&nbsp;</a></span>pnetcdf_put_var() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a61a148a84f5892ed1e1d865f2556a6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a148a84f5892ed1e1d865f2556a6a4">&#9670;&nbsp;</a></span>pnetcdf_put_var() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29bf258736c706ed1dbc792b98580328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29bf258736c706ed1dbc792b98580328">&#9670;&nbsp;</a></span>pnetcdf_put_var() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02225acc7d9d5a8f6e7da84aaad97411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02225acc7d9d5a8f6e7da84aaad97411">&#9670;&nbsp;</a></span>pnetcdf_put_var1() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28188af6587eadef58215dbc1cdf487c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28188af6587eadef58215dbc1cdf487c">&#9670;&nbsp;</a></span>pnetcdf_put_var1() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96cf801a9f35aa4fbf26f0fd9976e6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cf801a9f35aa4fbf26f0fd9976e6e8">&#9670;&nbsp;</a></span>pnetcdf_put_var1() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bc680f840a4a033714f2c9abb086f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc680f840a4a033714f2c9abb086f03">&#9670;&nbsp;</a></span>pnetcdf_put_var1() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31e07ee0438ae6e0d1e69162514d7ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e07ee0438ae6e0d1e69162514d7ef6">&#9670;&nbsp;</a></span>pnetcdf_put_var1() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24de5b43d8f56915aeecb2c41b566d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24de5b43d8f56915aeecb2c41b566d77">&#9670;&nbsp;</a></span>pnetcdf_put_var1() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5df9c0aaebc8786566ff7beb4a474cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df9c0aaebc8786566ff7beb4a474cd6">&#9670;&nbsp;</a></span>pnetcdf_put_var1() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a090001f3516744ee0d84f9570cda6f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090001f3516744ee0d84f9570cda6f7d">&#9670;&nbsp;</a></span>pnetcdf_put_var1() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90e87da7579cb70e7696e52723e1336a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e87da7579cb70e7696e52723e1336a">&#9670;&nbsp;</a></span>pnetcdf_put_var1() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aada5333bb143b2367e137f799459add6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada5333bb143b2367e137f799459add6">&#9670;&nbsp;</a></span>pnetcdf_put_var1() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_var1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace4a2dcb8c98cb91e98194e92c34eea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4a2dcb8c98cb91e98194e92c34eea4">&#9670;&nbsp;</a></span>pnetcdf_put_vara() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e73dbcc821ba419cc5cec754ada36e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e73dbcc821ba419cc5cec754ada36e6">&#9670;&nbsp;</a></span>pnetcdf_put_vara() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed6066a9fdb48e52d756c220023351e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6066a9fdb48e52d756c220023351e7">&#9670;&nbsp;</a></span>pnetcdf_put_vara() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ce57cc834c9cae52e3b9d3df0bd7726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce57cc834c9cae52e3b9d3df0bd7726">&#9670;&nbsp;</a></span>pnetcdf_put_vara() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1687c96c618322d1a967f67c3774d929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1687c96c618322d1a967f67c3774d929">&#9670;&nbsp;</a></span>pnetcdf_put_vara() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab68ee0caee1fc11227e3a765310807b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68ee0caee1fc11227e3a765310807b0">&#9670;&nbsp;</a></span>pnetcdf_put_vara() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa80dd0a51b0bc0b4929ca538e2e816d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80dd0a51b0bc0b4929ca538e2e816d0">&#9670;&nbsp;</a></span>pnetcdf_put_vara() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5d70331e0aafef59f4d90a0847c8342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d70331e0aafef59f4d90a0847c8342">&#9670;&nbsp;</a></span>pnetcdf_put_vara() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ac328cdd6d0a189bd43f21a26069dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac328cdd6d0a189bd43f21a26069dba">&#9670;&nbsp;</a></span>pnetcdf_put_vara() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc8e416b7c4629e56ce44edba72dd8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8e416b7c4629e56ce44edba72dd8f4">&#9670;&nbsp;</a></span>pnetcdf_put_vara() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdd66cf70782fa951b961046ceb9c30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd66cf70782fa951b961046ceb9c30f">&#9670;&nbsp;</a></span>pnetcdf_put_vara_all() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara_all </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4dfa3f38e14887b22e75c956af9d47fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfa3f38e14887b22e75c956af9d47fc">&#9670;&nbsp;</a></span>pnetcdf_put_vara_all() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara_all </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63bc6b4ac486e13865da72ac4d67c666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bc6b4ac486e13865da72ac4d67c666">&#9670;&nbsp;</a></span>pnetcdf_put_vara_all() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara_all </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4d23c13842a2e4d3cb017594befe961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d23c13842a2e4d3cb017594befe961">&#9670;&nbsp;</a></span>pnetcdf_put_vara_all() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara_all </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d44a94d51e1ef3fc0a48e28d1002cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d44a94d51e1ef3fc0a48e28d1002cf4">&#9670;&nbsp;</a></span>pnetcdf_put_vara_all() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara_all </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a659649de5302b9aa2387e9cebf1d703f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659649de5302b9aa2387e9cebf1d703f">&#9670;&nbsp;</a></span>pnetcdf_put_vara_all() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara_all </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9ef0b43880c2326a1053502b268fbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ef0b43880c2326a1053502b268fbb0">&#9670;&nbsp;</a></span>pnetcdf_put_vara_all() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara_all </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7f4bc030fcd2da9cc763ba15840dbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f4bc030fcd2da9cc763ba15840dbd1">&#9670;&nbsp;</a></span>pnetcdf_put_vara_all() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara_all </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add6a74b956c15a77d8328b6a67f18891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6a74b956c15a77d8328b6a67f18891">&#9670;&nbsp;</a></span>pnetcdf_put_vara_all() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara_all </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f7cb6bd189f72b74efe4c9767d54283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7cb6bd189f72b74efe4c9767d54283">&#9670;&nbsp;</a></span>pnetcdf_put_vara_all() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::pnetcdf_put_vara_all </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>start</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Offset const&#160;</td>
          <td class="paramname"><em>count</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65c11133710aa7fa34382d68bcaf9f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c11133710aa7fa34382d68bcaf9f96">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a793d39d1cf02a94a6762cb17ba989060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793d39d1cf02a94a6762cb17ba989060">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N, class TLOC , typename std::enable_if&lt; std::is_arithmetic&lt; TLOC &gt;::value, bool &gt;::type  = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TLOC&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f38931b23ab5b1c107992b509b75b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f38931b23ab5b1c107992b509b75b60">&#9670;&nbsp;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca055f3e17da1b57c8966dfb9537b1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca055f3e17da1b57c8966dfb9537b1ab">&#9670;&nbsp;</a></span>set_device_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_device_allocator </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void *(size_t)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's device allocator with the passed function (No Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;. </p>
<p>Follows the same function interface as malloc() </p>

</div>
</div>
<a id="a3c0af7565eb0e0d219ba91dff20b9e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0af7565eb0e0d219ba91dff20b9e90">&#9670;&nbsp;</a></span>set_device_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_device_allocator </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void *(size_t, char const *)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's device allocator with the passed function (WITH Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;. </p>
<p>Similar function interface as malloc but with a string parameter for bookkeeping and reporting. </p>

</div>
</div>
<a id="af56c3c1ec9df98cd97e7cbae04e3c8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56c3c1ec9df98cd97e7cbae04e3c8de">&#9670;&nbsp;</a></span>set_device_deallocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_device_deallocator </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void *)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's device deallocator with the passed function (No Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;. </p>
<p>Follows the same function interface as free() </p>

</div>
</div>
<a id="a0ebe9f97f4b39d1e4e9a1284435984d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebe9f97f4b39d1e4e9a1284435984d6">&#9670;&nbsp;</a></span>set_device_deallocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_device_deallocator </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void *, char const *)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's device deallocator with the passed function (WITH Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;. </p>
<p>Similar function interface as free but with a string parameter for bookkeeping and reporting. </p>

</div>
</div>
<a id="acfa47d0678c8772a89e8f37bba484814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa47d0678c8772a89e8f37bba484814">&#9670;&nbsp;</a></span>set_host_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_host_allocator </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void *(size_t)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's host allocator with the passed function (No Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;. </p>
<p>Follows the same function interface as malloc() </p>

</div>
</div>
<a id="a457a1f8b0af529710be9fd890682dfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457a1f8b0af529710be9fd890682dfcd">&#9670;&nbsp;</a></span>set_host_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_host_allocator </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void *(size_t, char const *)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's host allocator with the passed function (WITH Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;. </p>
<p>Similar function interface as malloc but with a string parameter for bookkeeping and reporting. </p>

</div>
</div>
<a id="a4d5b2f2f9068a7f1d81422b0920e7995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5b2f2f9068a7f1d81422b0920e7995">&#9670;&nbsp;</a></span>set_host_deallocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_host_deallocator </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void *)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's host deallocator with the passed function (No Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;. </p>
<p>Follows the same function interface as free() </p>

</div>
</div>
<a id="a3b0e98e23e4b273339d90de69b1659ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0e98e23e4b273339d90de69b1659ca">&#9670;&nbsp;</a></span>set_host_deallocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_host_deallocator </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void *, char const *)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's host deallocator with the passed function (WITH Label). All future allocations will use the function passed in until the user calls <a class="el" href="namespaceyakl.html#abf58795a80dd0c09827a1a0a4ab6c2f0" title="Return all YAKL allocators to their defaults. If the user has not overridden YAKL&#39;s default allocator...">yakl::set_yakl_allocators_to_default()</a>;. </p>
<p>Similar function interface as free but with a string parameter for bookkeeping and reporting. </p>

</div>
</div>
<a id="aec3d7bb59cc9da9d19c0668034e7a68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3d7bb59cc9da9d19c0668034e7a68c">&#9670;&nbsp;</a></span>set_timer_finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_timer_finalize </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's default timer finalization routine. </p>

</div>
</div>
<a id="aca6b5768d519254c3cbcd84eca12d20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6b5768d519254c3cbcd84eca12d20b">&#9670;&nbsp;</a></span>set_timer_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_timer_init </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's default timer initialization routine. </p>

</div>
</div>
<a id="afc021bc87deafec03ab9c12f20a3ce0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc021bc87deafec03ab9c12f20a3ce0d">&#9670;&nbsp;</a></span>set_timer_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_timer_start </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(char const *)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's default routine to start an individual timer. </p>

</div>
</div>
<a id="a12b1265406af3613ea8f2f0265200ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b1265406af3613ea8f2f0265200ce0">&#9670;&nbsp;</a></span>set_timer_stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_timer_stop </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(char const *)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override YAKL's default routine to stop an individual timer. </p>

</div>
</div>
<a id="abf58795a80dd0c09827a1a0a4ab6c2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf58795a80dd0c09827a1a0a4ab6c2f0">&#9670;&nbsp;</a></span>set_yakl_allocators_to_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::set_yakl_allocators_to_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return all YAKL allocators to their defaults. If the user has not overridden YAKL's default allocators, then this has no effect. </p>

</div>
</div>
<a id="aef4d194a56da2f17208a0b7d521ac7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4d194a56da2f17208a0b7d521ac7fe">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a860d4dcab9d5e50931418a9a1586bb06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860d4dcab9d5e50931418a9a1586bb06">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52a50fe47024438c63a8a6da14d130eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a50fe47024438c63a8a6da14d130eb">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> <a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt;T,N&gt; yakl::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyakl_1_1Pack.html">Pack</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a757af9a71189e007f6afa0c8df1380cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757af9a71189e007f6afa0c8df1380cf">&#9670;&nbsp;</a></span>timer_finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::timer_finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalize the YAKL timers. </p>

</div>
</div>
<a id="a548f5a6d111b18c6541bc82f3913345d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548f5a6d111b18c6541bc82f3913345d">&#9670;&nbsp;</a></span>timer_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::timer_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the YAKL timers. </p>

</div>
</div>
<a id="a22876aa3d7b5d93e2cd9df0110a1f236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22876aa3d7b5d93e2cd9df0110a1f236">&#9670;&nbsp;</a></span>timer_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::timer_start </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>lab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a timer with the given string label. NOTE: Timers must be perfectly nested. </p>

</div>
</div>
<a id="ae2a80175a29130a523e3d44585d046da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a80175a29130a523e3d44585d046da">&#9670;&nbsp;</a></span>timer_stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yakl::timer_stop </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>lab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop a timer with the given string label. NOTE: Timers must be perfectly nested. </p>

</div>
</div>
<a id="aa3cabe73b4f2ca1385233cb75541c687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cabe73b4f2ca1385233cb75541c687">&#9670;&nbsp;</a></span>tridiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real , unsigned int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yakl::tridiagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a non-periodic tridiagional system. </p>
<p>Solves a tridiagonal system with no boundary conditions of the form: </p><div class="fragment"><div class="line">[b(0)   c(0)  0    0      0      0    ] [x(0)  ] = [d(0)  ]</div>
<div class="line">[a(1)   b(1) c(1)  0      0      0    ] [x(1)  ] = [d(1)  ]</div>
<div class="line">[ 0     a(2) b(2) c(2)    0      0    ] [x(2)  ] = [d(2)  ]</div>
<div class="line">[ 0      0   ..  ..  ..   0      0    ] [ .    ] = [ .    ]</div>
<div class="line">[ 0      0      ..  ..  ..       0    ] [ .    ] = [ .    ]</div>
<div class="line">[ 0      0    0   a(n-2) b(n-2) c(n-2)] [x(n-2)] = [d(n-2)]</div>
<div class="line">[ 0      0    0    0     a(n-1) b(n-1)] [x(n-1)] = [d(n-1)]</div>
</div><!-- fragment --><p>This routine stores the result in <code>d()</code>, and as the signature indicates, it overwrites <code>b</code>, <code>c</code>, <code>d</code>.</p>
<p>This uses the Thomas algorithm. </p>

</div>
</div>
<a id="af9374fb79e2fd32acaf9d1f1a5e23775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9374fb79e2fd32acaf9d1f1a5e23775">&#9670;&nbsp;</a></span>tridiagonal_periodic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real , unsigned int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yakl::tridiagonal_periodic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyakl.html#adabbe6df1f315d5e2c1874cf1be0acf2">SArray</a>&lt; real, 1, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a periodic tridiagional solve. Click for more details. </p>
<p>Solves a tridiagonal system with periodic boundary conditions of the form: </p><div class="fragment"><div class="line">[b(0)   c(0)  0    0      0     a(0)  ] [x(0)  ] = [d(0)  ]</div>
<div class="line">[a(1)   b(1) c(1)  0      0      0    ] [x(1)  ] = [d(1)  ]</div>
<div class="line">[ 0     a(2) b(2) c(2)    0      0    ] [x(2)  ] = [d(2)  ]</div>
<div class="line">[ 0      0   ..  ..  ..   0      0    ] [ .    ] = [ .    ]</div>
<div class="line">[ 0      0      ..  ..  ..       0    ] [ .    ] = [ .    ]</div>
<div class="line">[ 0      0    0   a(n-2) b(n-2) c(n-2)] [x(n-2)] = [d(n-2)]</div>
<div class="line">[c(n-1)  0    0    0     a(n-1) b(n-1)] [x(n-1)] = [d(n-1)]</div>
</div><!-- fragment --><p>This routine stores the result in <code>d()</code>, and as the signature indicates, it overwrites <code>b</code>, <code>c</code>, <code>d</code></p>
<p>This uses the Thomas algorithm with the Sherman-Morrison formula. The Sherman-Morrison Formula is as follows:</p>
<p>Separate the tridiagonal + periodic matrix, <code>A</code>, into <code>(B + u*v^T)</code>, where <code>B</code> is strictly tridiagonal, and <code>u*v^T</code> accounts for the non-tridiagonal periodic BCs: </p><div class="fragment"><div class="line">u = [-b(0) , 0 , ... , 0 , c(n-1)    ]^T</div>
<div class="line">v = [1     , 0 , ... , 0 , -a(0)/b(0)]^T</div>
</div><!-- fragment --><p>Now we're solveing the system <code>(B + u*v^T)*x = d</code>, which is identical to <code>A*x=d</code>.</p>
<p>To get the solution, we solve two systems: </p><div class="fragment"><div class="line">(1) B*y=d</div>
<div class="line">(2) B*q=u</div>
</div><!-- fragment --><p>In this code, q is labeled as "tmp". Then, the answer is given by: </p><div class="fragment"><div class="line">x = y - ( (v^T*y) / (1 + v^T*q) ) * q</div>
</div><!-- fragment --><p>Unfortunately, periodic boundary conditions roughly double the amount of work in the tridiagonal solve </p>

</div>
</div>
<a id="ad595f0e5644733d5a1099347da7ce097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad595f0e5644733d5a1099347da7ce097">&#9670;&nbsp;</a></span>use_pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yakl::use_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, then the pool allocator is being used for all device allocations. </p>

</div>
</div>
<a id="a3763ece1d485b7596603c70a3199806f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3763ece1d485b7596603c70a3199806f">&#9670;&nbsp;</a></span>yakl_mainproc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yakl::yakl_mainproc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, this is the main MPI process (task number == 0) </p>

</div>
</div>
<a id="a26dec4d21029959d4e9714098f1d22ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26dec4d21029959d4e9714098f1d22ff">&#9670;&nbsp;</a></span>yakl_throw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="YAKL__defines_8h.html#aa0dd629ffce6d564b19e9313fb91a5ad">YAKL_INLINE</a> void yakl::yakl_throw </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throw an error message. On the host, this throws an exception. On the device, it prints and then forces the program to halt. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9af6abbeffe50631799da258050ff853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af6abbeffe50631799da258050ff853">&#9670;&nbsp;</a></span>COLON</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int yakl::COLON = std::numeric_limits&lt;int&gt;::min()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is just a convenience syntax for slicing <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects to make it clear in the user level code which dimensions are being sliced. </p>

</div>
</div>
<a id="a0437bce10dc5e3816ab24a75e3976a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0437bce10dc5e3816ab24a75e3976a4f">&#9670;&nbsp;</a></span>INDEX_MAX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a> yakl::INDEX_MAX = std::numeric_limits&lt;<a class="el" href="namespaceyakl.html#a172abcdd2d33fa36e969d80e6907173c">index_t</a>&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0690b4d7056faf74747ce4eafd3a0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0690b4d7056faf74747ce4eafd3a0ce">&#9670;&nbsp;</a></span>memDevice</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int yakl::memDevice = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c782101ad6c48bd8c317f61e77abf98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c782101ad6c48bd8c317f61e77abf98">&#9670;&nbsp;</a></span>memHost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int yakl::memHost = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5a358faf3cb27d0a14a15b5c6b83022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a358faf3cb27d0a14a15b5c6b83022">&#9670;&nbsp;</a></span>NETCDF_MODE_NEW</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int yakl::NETCDF_MODE_NEW = NC_NOCLOBBER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa12f0312227bfbba1756585d41a5d87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12f0312227bfbba1756585d41a5d87f">&#9670;&nbsp;</a></span>NETCDF_MODE_READ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int yakl::NETCDF_MODE_READ = NC_NOWRITE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ad851f7ac4bf63a9e912514b4fab4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad851f7ac4bf63a9e912514b4fab4cd">&#9670;&nbsp;</a></span>NETCDF_MODE_REPLACE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int yakl::NETCDF_MODE_REPLACE = NC_CLOBBER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a695e075dc48e0c511320c467d347fd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695e075dc48e0c511320c467d347fd5e">&#9670;&nbsp;</a></span>NETCDF_MODE_WRITE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int yakl::NETCDF_MODE_WRITE = NC_WRITE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a624d250b0cd8562b06641c92090efa8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624d250b0cd8562b06641c92090efa8d">&#9670;&nbsp;</a></span>pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyakl_1_1Gator.html">Gator</a> yakl::pool</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59a958dd81c018c1859580dcb453d31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a958dd81c018c1859580dcb453d31d">&#9670;&nbsp;</a></span>styleC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int yakl::styleC = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template parameter for <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> that specifies it should follow C-style behavior. </p>

</div>
</div>
<a id="a0792e33ef74bcb90e3ed4b847415543d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0792e33ef74bcb90e3ed4b847415543d">&#9670;&nbsp;</a></span>styleDefault</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int yakl::styleDefault = <a class="el" href="namespaceyakl.html#a59a958dd81c018c1859580dcb453d31d">styleC</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default style is C-style for <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> objects. </p>

</div>
</div>
<a id="a48029004bb42b7cc63974ca0433af63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48029004bb42b7cc63974ca0433af63a">&#9670;&nbsp;</a></span>styleFortran</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int yakl::styleFortran = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template parameter for <a class="el" href="classyakl_1_1Array.html" title="This declares the yakl::Array class. Please see the yakl::styleC and yakl::styleFortran template spec...">yakl::Array</a> that specifies it should follow Fortran-style behavior. </p>

</div>
</div>
<a id="acbe95c3cd90819e7b844991450403820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe95c3cd90819e7b844991450403820">&#9670;&nbsp;</a></span>timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyakl_1_1Toney.html">Toney</a> yakl::timer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99a2f92ab5419408dd90d950aad1305c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a2f92ab5419408dd90d950aad1305c">&#9670;&nbsp;</a></span>yakl_mtx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex yakl::yakl_mtx</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
